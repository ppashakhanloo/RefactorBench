[
  {
    "repo": "tiangolo/fastapi",
    "url": "https://github.com/tiangolo/fastapi",
    "instance_id": "exception-handlers-to-handlers",
    "base_commit": "exception-handlers-to-handlers",
    "patch": "N/A",
    "test_patch": "diff --git a/exception-handlers-to-handlers-test.py b/exception-handlers-to-handlers-test.py\nnew file mode 100644\nindex 0000000..6b230f0\n--- /dev/null\n+++ b/exception-handlers-to-handlers-test.py\n@@ -0,0 +1,127 @@\n+import unittest\n+import os\n+import ast\n+\n+class TestExceptionHandlersReference(unittest.TestCase):\n+\n+    def test_de_handling_errors_md(self):\n+        file_path = 'docs/de/docs/tutorial/handling-errors.md'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+        with open(file_path, 'r') as file:\n+            content = file.read()\n+            self.assertNotIn('exception_handlers.py', content, f\"'exception_handlers.py' found in {file_path}\")\n+\n+    def test_em_handling_errors_md(self):\n+        file_path = 'docs/em/docs/tutorial/handling-errors.md'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+        with open(file_path, 'r') as file:\n+            content = file.read()\n+            self.assertNotIn('exception_handlers.py', content, f\"'exception_handlers.py' found in {file_path}\")\n+\n+    def test_en_handling_errors_md(self):\n+        file_path = 'docs/en/docs/tutorial/handling-errors.md'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+        with open(file_path, 'r') as file:\n+            content = file.read()\n+            self.assertNotIn('exception_handlers.py', content, f\"'exception_handlers.py' found in {file_path}\")\n+\n+    def test_ja_handling_errors_md(self):\n+        file_path = 'docs/ja/docs/tutorial/handling-errors.md'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+        with open(file_path, 'r') as file:\n+            content = file.read()\n+            self.assertNotIn('exception_handlers.py', content, f\"'exception_handlers.py' found in {file_path}\")\n+\n+    def test_pt_handling_errors_md(self):\n+        file_path = 'docs/pt/docs/tutorial/handling-errors.md'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+        with open(file_path, 'r') as file:\n+            content = file.read()\n+            self.assertNotIn('exception_handlers.py', content, f\"'exception_handlers.py' found in {file_path}\")\n+\n+    def test_ru_handling_errors_md(self):\n+        file_path = 'docs/ru/docs/tutorial/handling-errors.md'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+        with open(file_path, 'r') as file:\n+            content = file.read()\n+            self.assertNotIn('exception_handlers.py', content, f\"'exception_handlers.py' found in {file_path}\")\n+\n+    def test_zh_handling_errors_md(self):\n+        file_path = 'docs/zh/docs/tutorial/handling-errors.md'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+        with open(file_path, 'r') as file:\n+            content = file.read()\n+            self.assertNotIn('exception_handlers.py', content, f\"'exception_handlers.py' found in {file_path}\")\n+\n+    def test_tutorial006_py(self):\n+        file_path = 'docs_src/handling_errors/tutorial006.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+        with open(file_path, 'r') as file:\n+            content = file.read()\n+            self.assertNotIn('exception_handlers.py', content, f\"'exception_handlers.py' found in {file_path}\")\n+\n+    def test_applications_py(self):\n+        file_path = 'fastapi/applications.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+        with open(file_path, 'r') as file:\n+            content = file.read()\n+            self.assertNotIn('exception_handlers.py', content, f\"'exception_handlers.py' found in {file_path}\")\n+            \n+    def test_handlers_and_exception_handlers_files(self):\n+        handlers_path = 'fastapi/handlers.py'\n+        exception_handlers_path = 'fastapi/exception_handlers.py'\n+        \n+        # Check that fastapi/handlers.py exists\n+        self.assertTrue(os.path.exists(handlers_path), f\"{handlers_path} does not exist\")\n+        \n+        # Check that fastapi/exception_handlers.py does not exist\n+        self.assertFalse(os.path.exists(exception_handlers_path), f\"{exception_handlers_path} should not exist\")\n+\n+    def test_applications_py_has_correct_imports(self):\n+        file_path = 'fastapi/applications.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        import_found = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom):\n+                if node.module == 'fastapi.handlers':\n+                    imported_names = {alias.name for alias in node.names}\n+                    if {\n+                        'http_exception_handler',\n+                        'request_validation_exception_handler',\n+                        'websocket_request_validation_exception_handler'\n+                    }.issubset(imported_names):\n+                        import_found = True\n+                        break\n+\n+        self.assertTrue(import_found, \"The required import statement from 'fastapi.handlers' is not found in 'applications.py'\")\n+\n+    def test_tutorial006_py_has_correct_imports(self):\n+        file_path = 'docs_src/handling_errors/tutorial006.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        import_found = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom):\n+                if node.module == 'fastapi.handlers':\n+                    imported_names = {alias.name for alias in node.names}\n+                    if {\n+                        'http_exception_handler',\n+                        'request_validation_exception_handler'\n+                    }.issubset(imported_names):\n+                        import_found = True\n+                        break\n+\n+        self.assertTrue(import_found, \"The required import statement from 'fastapi.handlers' is not found in 'tutorial006.py'\")\n+\n+\n+if __name__ == '__main__':\n+    unittest.main()",
    "problem_statement": "Rename exceptions_handlers.py to handlers.py and update the entire repository based on this change.",
    "hints_text": "",
    "created_at": "2025-11-03 22:46:32+00:00",
    "language": "Python",
    "Dockerfile": "N/A",
    "test_command": "python3 -m unittest exception-handlers-to-handlers-test.py",
    "task_category": "Refactoring",
    "data_source": "microsoft/RefactorBench",
    "scenario": "brownfield"
  },
  {
    "repo": "tiangolo/fastapi",
    "url": "https://github.com/tiangolo/fastapi",
    "instance_id": "value-is-a-sequence",
    "base_commit": "value-is-a-sequence",
    "patch": "N/A",
    "test_patch": "diff --git a/value-is-a-sequence-test.py b/value-is-a-sequence-test.py\nnew file mode 100644\nindex 0000000..8a0972b\n--- /dev/null\n+++ b/value-is-a-sequence-test.py\n@@ -0,0 +1,98 @@\n+import unittest\n+import os\n+import ast\n+\n+class TestFastAPICompatUtils(unittest.TestCase):\n+\n+    def test_compat_file_exists(self):\n+        # Path to the file where the functions should be defined\n+        file_path = 'fastapi/_compat.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+    def test_value_is_a_sequence_function_exists(self):\n+        # Path to the file where the value_is_a_sequence function should be defined\n+        file_path = 'fastapi/_compat.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Parse the _compat.py file to check for the value_is_a_sequence function\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        value_is_a_sequence_function = None\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.FunctionDef) and node.name == 'value_is_a_sequence':\n+                value_is_a_sequence_function = node\n+                break\n+\n+        self.assertIsNotNone(value_is_a_sequence_function, \"Function 'value_is_a_sequence' not found in _compat.py\")\n+\n+    def test_value_is_sequence_function_does_not_exist(self):\n+        # Path to the file where the value_is_sequence function might have been defined\n+        file_path = 'fastapi/_compat.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Parse the _compat.py file to check that value_is_sequence is no longer present\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        value_is_sequence_function = None\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.FunctionDef) and node.name == 'value_is_sequence':\n+                value_is_sequence_function = node\n+                break\n+\n+        self.assertIsNone(value_is_sequence_function, \"Function 'value_is_sequence' is still present in _compat.py, it should be renamed to 'value_is_a_sequence'\")\n+\n+    def test_import_value_is_a_sequence_in_utils(self):\n+        # Path to the file where the import should be checked\n+        file_path = 'fastapi/dependencies/utils.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Parse the utils.py file to check for the specific import\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        import_found = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom):\n+                if node.module == 'fastapi._compat':\n+                    imported_names = {alias.name for alias in node.names}\n+                    if 'value_is_a_sequence' in imported_names:\n+                        import_found = True\n+                        break\n+\n+        self.assertTrue(import_found, \"'value_is_a_sequence' not imported from 'fastapi._compat' in dependencies/utils.py\")\n+\n+    def test_value_is_sequence_function_does_not_exist_in_utils(self):\n+        # Path to the file where the value_is_sequence function might have been defined\n+        file_path = 'fastapi/dependencies/utils.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Parse the utils.py file to check that value_is_sequence is no longer present\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        value_is_sequence_function = None\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.FunctionDef) and node.name == 'value_is_sequence':\n+                value_is_sequence_function = node\n+                break\n+\n+        self.assertIsNone(value_is_sequence_function, \"Function 'value_is_sequence' is still present in utils.py, it should be renamed to 'value_is_a_sequence'\")\n+\n+if __name__ == '__main__':\n+    unittest.main()",
    "problem_statement": "Rename value_is_sequence to value_is_a_sequence and update usage in the repo.",
    "hints_text": "",
    "created_at": "2025-11-03 22:46:32+00:00",
    "language": "Python",
    "Dockerfile": "N/A",
    "test_command": "python3 -m unittest value-is-a-sequence-test.py",
    "task_category": "Refactoring",
    "data_source": "microsoft/RefactorBench",
    "scenario": "brownfield"
  },
  {
    "repo": "tiangolo/fastapi",
    "url": "https://github.com/tiangolo/fastapi",
    "instance_id": "params-to-param",
    "base_commit": "params-to-param",
    "patch": "N/A",
    "test_patch": "diff --git a/params-to-param-test.py b/params-to-param-test.py\nnew file mode 100644\nindex 0000000..5ed77bd\n--- /dev/null\n+++ b/params-to-param-test.py\n@@ -0,0 +1,284 @@\n+import unittest\n+import os\n+import ast\n+\n+class TestFastAPIImportRefactor(unittest.TestCase):\n+\n+    def test_compat_file_exists(self):\n+        # Path to the file where the import should be checked\n+        file_path = 'fastapi/_compat.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+    def test_no_params_import_in_compat(self):\n+        # Path to the file where the import should be checked\n+        file_path = 'fastapi/_compat.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Parse the _compat.py file to check for the absence of `from fastapi import params`\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom) and node.module == 'fastapi':\n+                imported_names = {alias.name for alias in node.names}\n+                self.assertNotIn('params', imported_names, \"'params' should not be imported from 'fastapi' in _compat.py\")\n+                self.assertIn('param', imported_names, \"'param' should be imported from 'fastapi' in _compat.py\")\n+\n+    def test_no_params_usage_in_compat(self):\n+        # Path to the file where the import should be checked\n+        file_path = 'fastapi/_compat.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Parse the _compat.py file to check that `params.` is not used and `param.` is used instead\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.Attribute) and isinstance(node.value, ast.Name):\n+                self.assertNotEqual(node.value.id, 'params', \"'params.' should not be used in _compat.py\")\n+                if node.value.id == 'param':\n+                    self.assertEqual(node.value.id, 'param', \"'param.' should be used in _compat.py\")\n+\n+    def test_routing_file_exists(self):\n+        # Path to the file where the import should be checked\n+        file_path = 'fastapi/routing.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+    def test_no_params_import_in_routing(self):\n+        # Path to the file where the import should be checked\n+        file_path = 'fastapi/routing.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Parse the routing.py file to check for the absence of `from fastapi import params`\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom) and node.module == 'fastapi':\n+                imported_names = {alias.name for alias in node.names}\n+                self.assertNotIn('params', imported_names, \"'params' should not be imported from 'fastapi' in routing.py\")\n+                self.assertIn('param', imported_names, \"'param' should be imported from 'fastapi' in routing.py\")\n+\n+    def test_no_params_usage_in_routing(self):\n+        # Path to the file where the import should be checked\n+        file_path = 'fastapi/routing.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Parse the routing.py file to check that `params.` is not used and `param.` is used instead\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.Attribute) and isinstance(node.value, ast.Name):\n+                self.assertNotEqual(node.value.id, 'params', \"'params.' should not be used in routing.py\")\n+                if node.value.id == 'param':\n+                    self.assertEqual(node.value.id, 'param', \"'param.' should be used in routing.py\")\n+\n+    def test_param_functions_file_exists(self):\n+        # Path to the file where the import should be checked\n+        file_path = 'fastapi/param_functions.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+    def test_no_params_import_in_param_functions(self):\n+        # Path to the file where the import should be checked\n+        file_path = 'fastapi/param_functions.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Parse the param_functions.py file to check for the absence of `from fastapi import params`\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom) and node.module == 'fastapi':\n+                imported_names = {alias.name for alias in node.names}\n+                self.assertNotIn('params', imported_names, \"'params' should not be imported from 'fastapi' in param_functions.py\")\n+                self.assertIn('param', imported_names, \"'param' should be imported from 'fastapi' in param_functions.py\")\n+\n+    def test_no_params_usage_in_param_functions(self):\n+        # Path to the file where the import should be checked\n+        file_path = 'fastapi/param_functions.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Parse the param_functions.py file to check that `params.` is not used and `param.` is used instead\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.Attribute) and isinstance(node.value, ast.Name):\n+                self.assertNotEqual(node.value.id, 'params', \"'params.' should not be used in param_functions.py\")\n+                if node.value.id == 'param':\n+                    self.assertEqual(node.value.id, 'param', \"'param.' should be used in param_functions.py\")\n+\n+    def test_dependencies_utils_file_exists(self):\n+        # Path to the file where the import should be checked\n+        file_path = 'fastapi/dependencies/utils.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+    def test_no_params_import_in_dependencies_utils(self):\n+        # Path to the file where the import should be checked\n+        file_path = 'fastapi/dependencies/utils.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Parse the utils.py file to check for the absence of `from fastapi import params`\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom) and node.module == 'fastapi':\n+                imported_names = {alias.name for alias in node.names}\n+                self.assertNotIn('params', imported_names, \"'params' should not be imported from 'fastapi' in utils.py\")\n+                self.assertIn('param', imported_names, \"'param' should be imported from 'fastapi' in utils.py\")\n+\n+    def test_no_params_usage_in_dependencies_utils(self):\n+        # Path to the file where the import should be checked\n+        file_path = 'fastapi/dependencies/utils.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Parse the utils.py file to check that `params.` is not used and `param.` is used instead\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.Attribute) and isinstance(node.value, ast.Name):\n+                self.assertNotEqual(node.value.id, 'params', \"'params.' should not be used in utils.py\")\n+                if node.value.id == 'param':\n+                    self.assertEqual(node.value.id, 'param', \"'param.' should be used in utils.py\")\n+\n+    def test_openapi_utils_file_exists(self):\n+        # Path to the file where the import should be checked\n+        file_path = 'fastapi/openapi/utils.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+    def test_no_params_import_in_openapi_utils(self):\n+        # Path to the file where the import should be checked\n+        file_path = 'fastapi/openapi/utils.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Parse the openapi/utils.py file to check for the absence of `from fastapi.params import`\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom) and node.module == 'fastapi.params':\n+                self.fail(\"'from fastapi.params import' should not be used in openapi/utils.py\")\n+            if isinstance(node, ast.ImportFrom) and node.module == 'fastapi.param':\n+                self.assertTrue(True)\n+\n+    def test_applications_file_exists(self):\n+        # Path to the file where the import should be checked\n+        file_path = 'fastapi/applications.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+    def test_no_params_import_in_applications(self):\n+        # Path to the file where the import should be checked\n+        file_path = 'fastapi/applications.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Parse the applications.py file to check for the absence of `from fastapi.params import`\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom) and node.module == 'fastapi.params':\n+                self.fail(\"'from fastapi.params import' should not be used in applications.py\")\n+            if isinstance(node, ast.ImportFrom) and node.module == 'fastapi.param':\n+                self.assertTrue(True)\n+\n+    def test_test_param_class_file_exists(self):\n+        # Path to the file where the import should be checked\n+        file_path = 'tests/test_param_class.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+    def test_no_params_import_in_test_param_class(self):\n+        # Path to the file where the import should be checked\n+        file_path = 'tests/test_param_class.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Parse the test_param_class.py file to check for the absence of `from fastapi.params import`\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom) and node.module == 'fastapi.params':\n+                self.fail(\"'from fastapi.params import' should not be used in test_param_class.py\")\n+            if isinstance(node, ast.ImportFrom) and node.module == 'fastapi.param':\n+                self.assertTrue(True)\n+\n+    def test_test_params_repr_file_exists(self):\n+        # Path to the file where the import should be checked\n+        file_path = 'tests/test_params_repr.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+    def test_no_params_import_in_test_params_repr(self):\n+        # Path to the file where the import should be checked\n+        file_path = 'tests/test_params_repr.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Parse the test_params_repr.py file to check for the absence of `from fastapi.params import`\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom) and node.module == 'fastapi.params':\n+                self.fail(\"'from fastapi.params import' should not be used in test_params_repr.py\")\n+            if isinstance(node, ast.ImportFrom) and node.module == 'fastapi.param':\n+                self.assertTrue(True)\n+                \n+    def test_fastapi_param_file_exists(self):\n+        # Path to the fastapi/param.py file\n+        file_path = 'fastapi/param.py'\n+\n+        # Check if the param.py file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist, but it should.\")\n+\n+    def test_fastapi_params_file_does_not_exist(self):\n+        # Path to the fastapi/params.py file\n+        file_path = 'fastapi/params.py'\n+\n+        # Check if the params.py file does not exist\n+        self.assertFalse(os.path.exists(file_path), f\"{file_path} exists, but it should not.\")\n+\n+\n+\n+if __name__ == '__main__':\n+    unittest.main()",
    "problem_statement": "Rename params.py to param.py and then update the whole repo based on that new name change.",
    "hints_text": "",
    "created_at": "2025-11-03 22:46:32+00:00",
    "language": "Python",
    "Dockerfile": "N/A",
    "test_command": "python3 -m unittest params-to-param-test.py",
    "task_category": "Refactoring",
    "data_source": "microsoft/RefactorBench",
    "scenario": "brownfield"
  },
  {
    "repo": "tiangolo/fastapi",
    "url": "https://github.com/tiangolo/fastapi",
    "instance_id": "openapi-get-utils",
    "base_commit": "openapi-get-utils",
    "patch": "N/A",
    "test_patch": "diff --git a/openapi-get-utils-test.py b/openapi-get-utils-test.py\nnew file mode 100644\nindex 0000000..86a66db\n--- /dev/null\n+++ b/openapi-get-utils-test.py\n@@ -0,0 +1,115 @@\n+import unittest\n+import os\n+import ast\n+\n+class TestFastAPIGetUtils(unittest.TestCase):\n+\n+    def test_get_utils_file_exists(self):\n+        # Path to the file where the get_utils.py should be defined\n+        file_path = 'fastapi/openapi/get_utils.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+    def test_utils_file_does_not_exist(self):\n+        # Path to the file where the old utils.py should no longer be present\n+        file_path = 'fastapi/openapi/utils.py'\n+\n+        # Check if the file does not exist\n+        self.assertFalse(os.path.exists(file_path), f\"{file_path} should not exist\")\n+\n+    def test_generate_operation_id_warning(self):\n+        # Path to the file where the generate_operation_id function is defined\n+        file_path = 'fastapi/openapi/get_utils.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Parse the get_utils.py file to check for the generate_operation_id function and its warning\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        generate_operation_id_function = None\n+        warning_found = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.FunctionDef) and node.name == 'generate_operation_id':\n+                generate_operation_id_function = node\n+                for body_node in node.body:\n+                    if isinstance(body_node, ast.Expr) and isinstance(body_node.value, ast.Call):\n+                        if (isinstance(body_node.value.func, ast.Attribute) and \n+                            body_node.value.func.attr == 'warn' and\n+                            isinstance(body_node.value.args[0], ast.Str) and\n+                            \"fastapi.openapi.get_utils.generate_operation_id() was deprecated, \"\n+                            \"it is not used internally, and will be removed soon\" in body_node.value.args[0].s):\n+                            warning_found = True\n+                            break\n+                break\n+\n+        self.assertIsNotNone(generate_operation_id_function, \"Function 'generate_operation_id' not found in get_utils.py\")\n+        self.assertTrue(warning_found, \"The expected deprecation warning message is not found in the 'generate_operation_id' function\")\n+\n+    \n+    def test_extending_openapi_md_de_docs(self):\n+        file_path = 'docs/de/docs/how-to/extending-openapi.md'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            content = file.read()\n+        \n+        self.assertNotIn('openapi.utils', content, f\"'openapi.utils' found in {file_path}\")\n+        self.assertIn('openapi.get_utils', content, f\"'openapi.get_utils' not found in {file_path}\")\n+\n+    def test_extending_openapi_md_em_docs(self):\n+        file_path = 'docs/em/docs/how-to/extending-openapi.md'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            content = file.read()\n+\n+        self.assertNotIn('openapi.utils', content, f\"'openapi.utils' found in {file_path}\")\n+        self.assertIn('openapi.get_utils', content, f\"'openapi.get_utils' not found in {file_path}\")\n+\n+    def test_extending_openapi_md_en_docs(self):\n+        file_path = 'docs/en/docs/how-to/extending-openapi.md'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            content = file.read()\n+\n+        self.assertNotIn('openapi.utils', content, f\"'openapi.utils' found in {file_path}\")\n+        self.assertIn('openapi.get_utils', content, f\"'openapi.get_utils' not found in {file_path}\")\n+\n+    def test_tutorial001_py(self):\n+        file_path = 'docs_src/extending_openapi/tutorial001.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            content = file.read()\n+\n+        self.assertNotIn('openapi.utils', content, f\"'openapi.utils' found in {file_path}\")\n+        self.assertIn('openapi.get_utils', content, f\"'openapi.get_utils' not found in {file_path}\")\n+\n+    def test_applications_py(self):\n+        file_path = 'fastapi/applications.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            content = file.read()\n+\n+        self.assertNotIn('openapi.utils', content, f\"'openapi.utils' found in {file_path}\")\n+        self.assertIn('openapi.get_utils', content, f\"'openapi.get_utils' not found in {file_path}\")\n+\n+    def test_test_additional_responses_bad_py(self):\n+        file_path = 'tests/test_additional_responses_bad.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            content = file.read()\n+\n+        self.assertNotIn('openapi.utils', content, f\"'openapi.utils' found in {file_path}\")\n+        self.assertIn('openapi.get_utils', content, f\"'openapi.get_utils' not found in {file_path}\")\n+\n+\n+if __name__ == '__main__':\n+    unittest.main()",
    "problem_statement": "Rename utils.py in openapi to get_utils.py and then update all the references throughout the repository with the new file name.",
    "hints_text": "",
    "created_at": "2025-11-03 22:46:32+00:00",
    "language": "Python",
    "Dockerfile": "N/A",
    "test_command": "python3 -m unittest openapi-get-utils-test.py",
    "task_category": "Refactoring",
    "data_source": "microsoft/RefactorBench",
    "scenario": "brownfield"
  },
  {
    "repo": "tiangolo/fastapi",
    "url": "https://github.com/tiangolo/fastapi",
    "instance_id": "add-log-parameter-generate-option-id-for-path",
    "base_commit": "add-log-parameter-generate-option-id-for-path",
    "patch": "N/A",
    "test_patch": "diff --git a/add-log-parameter-generate-option-id-for-path-test.py b/add-log-parameter-generate-option-id-for-path-test.py\nnew file mode 100644\nindex 0000000..601bef1\n--- /dev/null\n+++ b/add-log-parameter-generate-option-id-for-path-test.py\n@@ -0,0 +1,109 @@\n+import unittest\n+import os\n+import ast\n+\n+class TestFastAPIUtils(unittest.TestCase):\n+\n+    def test_utils_file_exists(self):\n+        # Path to the file where the functions should be defined\n+        file_path = 'fastapi/utils.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+    def test_generate_operation_id_for_path_has_log_parameter_with_default_false(self):\n+        # Path to the file where the generate_operation_id_for_path function should be defined\n+        file_path = 'fastapi/utils.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Parse the utils.py file to check for the generate_operation_id_for_path function and its parameters\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        generate_operation_id_for_path_function = None\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.FunctionDef) and node.name == 'generate_operation_id_for_path':\n+                generate_operation_id_for_path_function = node\n+                break\n+\n+        # Check if the function is defined\n+        self.assertIsNotNone(generate_operation_id_for_path_function, \"Function 'generate_operation_id_for_path' not found in utils.py\")\n+\n+        # Check if the function has a 'log' parameter with a default value of False\n+        parameter_found = False\n+        for kwarg in generate_operation_id_for_path_function.args.kwonlyargs:\n+            if kwarg.arg == 'log':\n+                # Find the corresponding default value index\n+                default_value_index = generate_operation_id_for_path_function.args.kwonlyargs.index(kwarg)\n+                default_value = generate_operation_id_for_path_function.args.kw_defaults[default_value_index]\n+                \n+                if isinstance(default_value, ast.Constant) and default_value.value is False:\n+                    parameter_found = True\n+                break\n+\n+        self.assertTrue(parameter_found, \"'log' parameter with default value False not found in 'generate_operation_id_for_path' function\")\n+\n+    def test_openapi_utils_file_exists(self):\n+        # Path to the file where the import should be checked\n+        file_path = 'fastapi/openapi/utils.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+    def test_import_from_fastapi_utils(self):\n+        # Path to the file where the import should be checked\n+        file_path = 'fastapi/openapi/utils.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Parse the utils.py file to check for the specific import\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        import_found = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom) and node.module == 'fastapi.utils':\n+                imported_names = {alias.name for alias in node.names}\n+                if {'deep_dict_update', 'generate_operation_id_for_path', 'is_body_allowed_for_status_code'}.issubset(imported_names):\n+                    import_found = True\n+                    break\n+\n+        self.assertTrue(import_found, \"The required import statement from 'fastapi.utils' is not found in 'fastapi/openapi/utils.py'\")\n+\n+    def test_generate_operation_id_for_path_calls_log_true(self):\n+        # Path to the file where the function calls should be checked\n+        file_path = 'fastapi/openapi/utils.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Parse the utils.py file to check for calls to generate_operation_id_for_path\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        # Find all calls to generate_operation_id_for_path\n+        calls_with_log_true = True\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.Call) and isinstance(node.func, ast.Name) and node.func.id == 'generate_operation_id_for_path':\n+                # Check if the call has the argument log=True\n+                has_log_true = False\n+                for keyword in node.keywords:\n+                    if keyword.arg == 'log' and isinstance(keyword.value, ast.Constant) and keyword.value.value is True:\n+                        has_log_true = True\n+                        break\n+                \n+                if not has_log_true:\n+                    calls_with_log_true = False\n+                    break\n+\n+        self.assertTrue(calls_with_log_true, \"Not all calls to 'generate_operation_id_for_path' have 'log=True' in 'fastapi/openapi/utils.py'\")\n+\n+    \n+if __name__ == '__main__':\n+    unittest.main()",
    "problem_statement": "Add a log boolean parameter in the generate_option_id_for_path function and keep the base case false. For all calls through the codebase make log=True.",
    "hints_text": "",
    "created_at": "2025-11-03 22:46:32+00:00",
    "language": "Python",
    "Dockerfile": "N/A",
    "test_command": "python3 -m unittest add-log-parameter-generate-option-id-for-path-test.py",
    "task_category": "Refactoring",
    "data_source": "microsoft/RefactorBench",
    "scenario": "brownfield"
  },
  {
    "repo": "tiangolo/fastapi",
    "url": "https://github.com/tiangolo/fastapi",
    "instance_id": "get-auth-scheme-param",
    "base_commit": "get-auth-scheme-param",
    "patch": "N/A",
    "test_patch": "diff --git a/get-auth-scheme-param-test.py b/get-auth-scheme-param-test.py\nnew file mode 100644\nindex 0000000..cc0ff24\n--- /dev/null\n+++ b/get-auth-scheme-param-test.py\n@@ -0,0 +1,116 @@\n+import unittest\n+import os\n+import ast\n+\n+class TestFastAPISecurityUtils(unittest.TestCase):\n+\n+    def test_utils_file_exists(self):\n+        # Path to the file where the functions should be defined\n+        file_path = 'fastapi/security/utils.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+    def test_get_auth_scheme_param_function_exists(self):\n+        # Path to the file where the get_auth_scheme_param function should be defined\n+        file_path = 'fastapi/security/utils.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Parse the utils.py file to check for the get_auth_scheme_param function\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        get_auth_scheme_param_function = None\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.FunctionDef) and node.name == 'get_auth_scheme_param':\n+                get_auth_scheme_param_function = node\n+                break\n+\n+        self.assertIsNotNone(get_auth_scheme_param_function, \"Function 'get_auth_scheme_param' not found in utils.py\")\n+\n+    def test_get_authorization_scheme_param_function_does_not_exist(self):\n+        # Path to the file where the get_authorization_scheme_param function might have been defined\n+        file_path = 'fastapi/security/utils.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Parse the utils.py file to check that get_authorization_scheme_param is no longer present\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        get_authorization_scheme_param_function = None\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.FunctionDef) and node.name == 'get_authorization_scheme_param':\n+                get_authorization_scheme_param_function = node\n+                break\n+\n+        self.assertIsNone(get_authorization_scheme_param_function, \"Function 'get_authorization_scheme_param' is still present in utils.py, it should be renamed to 'get_auth_scheme_param'\")\n+\n+    def test_oauth2_file_exists(self):\n+        # Path to the file where the import should be checked\n+        file_path = 'fastapi/security/oauth2.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+    def test_import_get_auth_scheme_param(self):\n+        # Path to the file where the import should be checked\n+        file_path = 'fastapi/security/oauth2.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Parse the oauth2.py file to check for the specific import\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        import_found = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom):\n+                if node.module == 'fastapi.security.utils':\n+                    imported_names = {alias.name for alias in node.names}\n+                    if 'get_auth_scheme_param' in imported_names:\n+                        import_found = True\n+                        break\n+\n+        self.assertTrue(import_found, \"'get_auth_scheme_param' not imported from 'fastapi.security.utils' in oauth2.py\")\n+\n+    def test_http_file_exists(self):\n+        # Path to the file where the import should be checked\n+        file_path = 'fastapi/security/http.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+    def test_import_get_auth_scheme_param(self):\n+        # Path to the file where the import should be checked\n+        file_path = 'fastapi/security/http.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Parse the http.py file to check for the specific import\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        import_found = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom):\n+                if node.module == 'fastapi.security.utils':\n+                    imported_names = {alias.name for alias in node.names}\n+                    if 'get_auth_scheme_param' in imported_names:\n+                        import_found = True\n+                        break\n+\n+        self.assertTrue(import_found, \"'get_auth_scheme_param' not imported from 'fastapi.security.utils' in http.py\")\n+\n+    \n+if __name__ == '__main__':\n+    unittest.main()",
    "problem_statement": "Rename get_authorization_scheme_param to get_auth_scheme_param and update the usages throughout the repo.",
    "hints_text": "",
    "created_at": "2025-11-03 22:46:32+00:00",
    "language": "Python",
    "Dockerfile": "N/A",
    "test_command": "python3 -m unittest get-auth-scheme-param-test.py",
    "task_category": "Refactoring",
    "data_source": "microsoft/RefactorBench",
    "scenario": "brownfield"
  },
  {
    "repo": "celery/celery",
    "url": "https://github.com/celery/celery",
    "instance_id": "autoretry-to-retry",
    "base_commit": "autoretry-to-retry",
    "patch": "N/A",
    "test_patch": "diff --git a/autoretry-to-retry-test.py b/autoretry-to-retry-test.py\nnew file mode 100644\nindex 0000000..901937b\n--- /dev/null\n+++ b/autoretry-to-retry-test.py\n@@ -0,0 +1,96 @@\n+import unittest\n+import os\n+import ast\n+import json\n+\n+class TestCeleryRetryDocumentation(unittest.TestCase):\n+\n+    def test_autoretry_file_does_not_exist(self):\n+        # Path to the file that should not exist\n+        file_path = 'celery/app/autoretry.py'\n+\n+        # Check if the file does not exist\n+        self.assertFalse(os.path.exists(file_path), f\"{file_path} should not exist\")\n+\n+    def test_retry_file_exists(self):\n+        # Path to the file that should exist\n+        file_path = 'celery/app/retry.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+    def test_docs_reference_does_not_contain_autoretry(self):\n+        # Path to the documentation file that should be checked\n+        docs_path = 'docs/reference/index.rst'\n+\n+        # Check if the documentation file exists\n+        self.assertTrue(os.path.exists(docs_path), f\"{docs_path} does not exist\")\n+\n+        # Read the content of the documentation file\n+        with open(docs_path, 'r') as file:\n+            content = file.read()\n+\n+        # Ensure 'celery.app.autoretry' is not in the documentation\n+        self.assertNotIn('celery.app.autoretry', content, \"'celery.app.autoretry' found in docs/reference/index.rst\")\n+\n+        # Ensure 'celery.app.retry' is in the documentation\n+        self.assertIn('celery.app.retry', content, \"'celery.app.retry' not found in docs/reference/index.rst\")\n+\n+    def test_base_imports_add_autoretry_behaviour(self):\n+        # Path to the file that should be checked\n+        file_path = 'celery/app/base.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Parse the base.py file to check for the specific import\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        import_found = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom):\n+                if node.module == 'retry':\n+                    imported_names = {alias.name for alias in node.names}\n+                    if 'add_autoretry_behaviour' in imported_names:\n+                        import_found = True\n+                        break\n+\n+        self.assertTrue(import_found, \"'from .retry import add_autoretry_behaviour' not found in base.py\")\n+\n+    def test_autoretry_rst_deleted(self):\n+        # Path to the documentation file that should be deleted\n+        rst_path = 'docs/reference/celery.app.autoretry.rst'\n+\n+        # Check if the file does not exist\n+        self.assertFalse(os.path.exists(rst_path), f\"{rst_path} should be deleted\")\n+\n+    def test_retry_rst_added(self):\n+        # Path to the new documentation file that should be added\n+        rst_path = 'docs/reference/celery.app.retry.rst'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(rst_path), f\"{rst_path} should exist\")\n+        \n+    def test_bandit_json_contains_retry_and_not_autoretry(self):\n+        # Path to the bandit.json file that should be checked\n+        bandit_path = 'bandit.json'\n+\n+        # Check if the bandit.json file exists\n+        self.assertTrue(os.path.exists(bandit_path), f\"{bandit_path} does not exist\")\n+\n+        # Read the content of the bandit.json file as text\n+        with open(bandit_path, 'r') as file:\n+            content = file.read()\n+\n+        # Check that \"celery/app/retry.py\" is in the content\n+        self.assertIn(\"celery/app/retry.py\", content, \"'celery/app/retry.py' not found in bandit.json\")\n+\n+        # Check that \"celery/app/autoretry.py\" is not in the content\n+        self.assertNotIn(\"celery/app/autoretry.py\", content, \"'celery/app/autoretry.py' should not be found in bandit.json\")\n+\n+\n+\n+if __name__ == '__main__':\n+    unittest.main()",
    "problem_statement": "Rename autoretry.py to retry.py and update the repository accordingly.",
    "hints_text": "",
    "created_at": "2025-11-03 22:46:32+00:00",
    "language": "Python",
    "Dockerfile": "N/A",
    "test_command": "python3 -m unittest autoretry-to-retry-test.py",
    "task_category": "Refactoring",
    "data_source": "microsoft/RefactorBench",
    "scenario": "brownfield"
  },
  {
    "repo": "celery/celery",
    "url": "https://github.com/celery/celery",
    "instance_id": "rename-host-format",
    "base_commit": "rename-host-format",
    "patch": "N/A",
    "test_patch": "diff --git a/rename-host-format-test.py b/rename-host-format-test.py\nnew file mode 100644\nindex 0000000..b7285ad\n--- /dev/null\n+++ b/rename-host-format-test.py\n@@ -0,0 +1,157 @@\n+import unittest\n+import os\n+import ast\n+\n+class TestCeleryUtilsNodenames(unittest.TestCase):\n+\n+    def test_nodenames_file_exists(self):\n+        # Path to the file where the format_host function should be defined\n+        file_path = 'celery/utils/nodenames.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+    def test_format_host_function_exists(self):\n+        # Path to the file where the format_host function should be defined\n+        file_path = 'celery/utils/nodenames.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Check if format_host function is defined in nodenames.py\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        format_host_function = None\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.FunctionDef) and node.name == 'format_host':\n+                format_host_function = node\n+                break\n+\n+        self.assertIsNotNone(format_host_function, \"Function 'format_host' not found in nodenames.py\")\n+\n+    def test_format_host_in_all_declaration(self):\n+        # Path to the file where the __all__ declaration should be checked\n+        file_path = 'celery/utils/nodenames.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Check if format_host is included in __all__ in nodenames.py\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        all_declaration = None\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.Assign):\n+                for target in node.targets:\n+                    if isinstance(target, ast.Name) and target.id == '__all__':\n+                        all_declaration = node.value\n+                        break\n+\n+        self.assertIsNotNone(all_declaration, \"__all__ declaration not found in nodenames.py\")\n+        \n+        if isinstance(all_declaration, ast.List) or isinstance(all_declaration, ast.Tuple):\n+            elements = {element.s for element in all_declaration.elts if isinstance(element, ast.Str)}\n+            self.assertIn('format_host', elements, \"'format_host' not found in __all__ declaration in nodenames.py\")\n+        else:\n+            self.fail(\"__all__ is not a list or tuple in nodenames.py\")\n+    \n+    def test_worker_imports_nodenames_functions(self):\n+        # Path to the file where the import should be checked\n+        file_path = 'celery/bin/worker.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Parse the worker.py file to check for the specific import\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        import_found = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom):\n+                if node.module == 'celery.utils.nodenames':\n+                    imported_names = {alias.name for alias in node.names}\n+                    if {'default_nodename', 'format_host', 'node_format'}.issubset(imported_names):\n+                        import_found = True\n+                        break\n+\n+        self.assertTrue(import_found, \"'default_nodename', 'format_host', and 'node_format' not imported from 'celery.utils.nodenames' in worker.py\")\n+\n+    def test_format_host_not_called_in_worker(self):\n+        # Path to the file where the function call should be checked\n+        file_path = 'celery/bin/worker.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Parse the worker.py file to check if format_host is called\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        format_host_called = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.Call):\n+                if isinstance(node.func, ast.Name) and node.func.id == 'host_format':\n+                    format_host_called = True\n+                    break\n+                elif isinstance(node.func, ast.Attribute) and node.func.attr == 'host_format':\n+                    format_host_called = True\n+                    break\n+\n+        self.assertFalse(format_host_called, \"'host_format' should not be called in worker.py\")\n+        \n+    def test_multi_imports_nodenames_functions(self):\n+        # Path to the file where the import should be checked\n+        file_path = 'celery/apps/multi.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Parse the multi.py file to check for the specific import\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        import_found = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom):\n+                if node.module == 'celery.utils.nodenames':\n+                    imported_names = {alias.name for alias in node.names}\n+                    if {'gethostname', 'format_host', 'node_format', 'nodesplit'}.issubset(imported_names):\n+                        import_found = True\n+                        break\n+\n+        self.assertTrue(import_found, \"'gethostname', 'format_host', 'node_format', and 'nodesplit' not imported from 'celery.utils.nodenames' in multi.py\")\n+\n+    def test_format_host_not_called_in_multi(self):\n+        # Path to the file where the function call should be checked\n+        file_path = 'celery/apps/multi.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Parse the worker.py file to check if format_host is called\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        format_host_called = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.Call):\n+                if isinstance(node.func, ast.Name) and node.func.id == 'host_format':\n+                    format_host_called = True\n+                    break\n+                elif isinstance(node.func, ast.Attribute) and node.func.attr == 'host_format':\n+                    format_host_called = True\n+                    break\n+\n+        self.assertFalse(format_host_called, \"'host_format' should not be called in worker.py\")\n+    \n+if __name__ == '__main__':\n+    unittest.main()",
    "problem_statement": "Rename host_format in nodenames.py to format_host and update the entire repository accordingly.",
    "hints_text": "",
    "created_at": "2025-11-03 22:46:32+00:00",
    "language": "Python",
    "Dockerfile": "N/A",
    "test_command": "python3 -m unittest rename-host-format-test.py",
    "task_category": "Refactoring",
    "data_source": "microsoft/RefactorBench",
    "scenario": "brownfield"
  },
  {
    "repo": "celery/celery",
    "url": "https://github.com/celery/celery",
    "instance_id": "truncate-text",
    "base_commit": "truncate-text",
    "patch": "N/A",
    "test_patch": "diff --git a/truncate-text-test.py b/truncate-text-test.py\nnew file mode 100644\nindex 0000000..2fb8736\n--- /dev/null\n+++ b/truncate-text-test.py\n@@ -0,0 +1,237 @@\n+import unittest\n+import os\n+import ast\n+\n+class TestCeleryUtils(unittest.TestCase):\n+\n+    def test_truncate_text_function_exists(self):\n+        # Path to the file where the truncate_text function should be defined\n+        file_path = 'celery/utils/text.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Check if truncate_text function is defined in text.py\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        truncate_text_function = None\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.FunctionDef) and node.name == 'truncate_text':\n+                truncate_text_function = node\n+                break\n+\n+        self.assertIsNotNone(truncate_text_function, \"Function 'truncate_text' not found in text.py\")\n+\n+    def test_truncate_text_in_all(self):\n+        # Path to the file where the __all__ declaration should be defined\n+        file_path = 'celery/utils/text.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Check if truncate_text is included in __all__ in text.py\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        all_found = False\n+        truncate_text_in_all = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.Assign):\n+                for target in node.targets:\n+                    if isinstance(target, ast.Name) and target.id == '__all__':\n+                        all_found = True\n+                        if isinstance(node.value, ast.Tuple):\n+                            for element in node.value.elts:\n+                                if isinstance(element, ast.Str) and element.s == 'truncate_text':\n+                                    truncate_text_in_all = True\n+                                    break\n+\n+        self.assertTrue(all_found, \"__all__ declaration not found in text.py\")\n+        self.assertTrue(truncate_text_in_all, \"'truncate_text' not found in __all__ declaration in text.py\")\n+\n+    def test_import_truncate_text_in_saferepr(self):\n+        # Path to the file where the import should be checked\n+        file_path = 'celery/utils/saferepr.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Check if truncate_text is imported from text.py in saferepr.py\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        import_found = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom):\n+                if node.module == 'text' and any(alias.name == 'truncate_text' for alias in node.names):\n+                    import_found = True\n+                    break\n+\n+        self.assertTrue(import_found, \"'truncate_text' not imported from 'text.py' in saferepr.py\")\n+\n+    def test_import_truncate_text_in_concurrency_base(self):\n+        # Path to the file where the import should be checked\n+        file_path = 'celery/concurrency/base.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Check if truncate_text is imported from celery.utils.text in base.py\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        import_found = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom):\n+                if (node.module == 'celery.utils.text' and\n+                        any(alias.name == 'truncate_text' for alias in node.names)):\n+                    import_found = True\n+                    break\n+\n+        self.assertTrue(import_found, \"'truncate_text' not imported from 'celery.utils.text' in base.py\")\n+\n+    def test_import_remove_repeating_from_task_and_truncate_text_in_canvas(self):\n+        # Path to the file where the import should be checked\n+        file_path = 'celery/canvas.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Check if remove_repeating_from_task and truncate_text are imported from celery.utils.text in canvas.py\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        import_found = False\n+        truncate_text_found = False\n+        remove_repeating_found = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom):\n+                if node.module == 'celery.utils.text':\n+                    imported_names = {alias.name for alias in node.names}\n+                    truncate_text_found = 'truncate_text' in imported_names\n+                    remove_repeating_found = 'remove_repeating_from_task' in imported_names\n+                    if truncate_text_found and remove_repeating_found:\n+                        import_found = True\n+                        break\n+\n+        self.assertTrue(import_found, \"'truncate_text' and 'remove_repeating_from_task' not imported from 'celery.utils.text' in canvas.py\")\n+\n+    def test_import_truncate_text_in_testing_manager(self):\n+        # Path to the file where the import should be checked\n+        file_path = 'celery/contrib/testing/manager.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Check if truncate_text is imported from celery.utils.text in manager.py\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        import_found = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom):\n+                if node.module == 'celery.utils.text' and any(alias.name == 'truncate_text' for alias in node.names):\n+                    import_found = True\n+                    break\n+\n+        self.assertTrue(import_found, \"'truncate_text' not imported from 'celery.utils.text' in manager.py\")\n+\n+    def test_import_abbr_abbrtask_ensure_newlines_indent_pretty_truncate_text_in_test_text(self):\n+        # Path to the file where the import should be checked\n+        file_path = 't/unit/utils/test_text.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Check if the specified functions are imported from celery.utils.text in test_text.py\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        import_found = False\n+        imported_functions = {\n+            'abbr', 'abbrtask', 'ensure_newlines',\n+            'indent', 'pretty', 'truncate_text'\n+        }\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom):\n+                if node.module == 'celery.utils.text':\n+                    imported_names = {alias.name for alias in node.names}\n+                    if imported_functions.issubset(imported_names):\n+                        import_found = True\n+                        break\n+\n+        self.assertTrue(import_found, (\n+            \"'abbr', 'abbrtask', 'ensure_newlines', 'indent', \"\n+            \"'pretty', and 'truncate_text' not imported from \"\n+            \"'celery.utils.text' in test_text.py\"\n+        ))\n+    \n+    def test_import_truncate_text_in_consumer(self):\n+        # Path to the file where the import should be checked\n+        file_path = 'celery/worker/consumer/consumer.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Check if truncate_text is imported from celery.utils.text in consumer.py\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        import_found = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom):\n+                if node.module == 'celery.utils.text' and any(alias.name == 'truncate_text' for alias in node.names):\n+                    import_found = True\n+                    break\n+\n+        self.assertTrue(import_found, \"'truncate_text' not imported from 'celery.utils.text' in consumer.py\")\n+\n+    def test_saferepr_function_truncate_handling(self):\n+        # Path to the file where the _saferepr function should be defined\n+        file_path = 'celery/utils/saferepr.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Parse the saferepr.py file to find the _saferepr function\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        saferepr_function = None\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.FunctionDef) and node.name == '_saferepr':\n+                saferepr_function = node\n+                break\n+\n+        self.assertIsNotNone(saferepr_function, \"Function '_saferepr' not found in saferepr.py\")\n+\n+        # Check the _saferepr function for correct usage of truncate_text and rest2.truncate\n+        truncate_text_found = False\n+        rest2_truncate_found = False\n+        truncate_text_confusion = False\n+\n+        for node in ast.walk(saferepr_function):\n+            if isinstance(node, ast.Call) and isinstance(node.func, ast.Name) and node.func.id == 'truncate_text':\n+                truncate_text_found = True\n+            if isinstance(node, ast.Attribute) and node.attr == 'truncate':\n+                rest2_truncate_found = True\n+                if isinstance(node.value, ast.Name) and node.value.id == 'truncate_text':\n+                    truncate_text_confusion = True\n+\n+        self.assertTrue(truncate_text_found, \"'truncate_text' not used correctly in _saferepr function\")\n+        self.assertTrue(rest2_truncate_found, \"'rest2.truncate' not used in _saferepr function\")\n+        self.assertFalse(truncate_text_confusion, \"'truncate_text' confused with 'rest2.truncate' in _saferepr function\")\n+\n+    \n+if __name__ == '__main__':\n+    unittest.main()",
    "problem_statement": "Rename truncate in text.py to truncate_text and update all the usages of the function throughout the repository.",
    "hints_text": "",
    "created_at": "2025-11-03 22:46:32+00:00",
    "language": "Python",
    "Dockerfile": "N/A",
    "test_command": "python3 -m unittest truncate-text-test.py",
    "task_category": "Refactoring",
    "data_source": "microsoft/RefactorBench",
    "scenario": "brownfield"
  },
  {
    "repo": "celery/celery",
    "url": "https://github.com/celery/celery",
    "instance_id": "expand-router-string-to-utils",
    "base_commit": "expand-router-string-to-utils",
    "patch": "N/A",
    "test_patch": "diff --git a/expand-router-string-to-utils-test.py b/expand-router-string-to-utils-test.py\nnew file mode 100644\nindex 0000000..92feab6\n--- /dev/null\n+++ b/expand-router-string-to-utils-test.py\n@@ -0,0 +1,91 @@\n+import unittest\n+import os\n+import ast\n+\n+class TestCeleryUtils(unittest.TestCase):\n+\n+    def test_utils_file_exists(self):\n+        # Path to the file where the expand_router_string function should be defined\n+        file_path = 'celery/app/utils.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+    def test_expand_router_string_function_exists(self):\n+        # Path to the file where the expand_router_string function should be defined\n+        file_path = 'celery/app/utils.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Check if expand_router_string function is defined in utils.py\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        expand_router_string_function = None\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.FunctionDef) and node.name == 'expand_router_string':\n+                expand_router_string_function = node\n+                break\n+\n+        self.assertIsNotNone(expand_router_string_function, \"Function 'expand_router_string' not found in utils.py\")\n+\n+    def test_expand_router_string_in_all_declaration(self):\n+        # Path to the file where the __all__ declaration should be checked\n+        file_path = 'celery/app/utils.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Check if expand_router_string is included in __all__ in utils.py\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        all_declaration = None\n+\n+        # Look for the __all__ assignment\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.Assign):\n+                for target in node.targets:\n+                    if isinstance(target, ast.Name) and target.id == '__all__':\n+                        all_declaration = node\n+                        break\n+            if all_declaration:\n+                break\n+\n+        # Verify that __all__ is found and that expand_router_string is included\n+        self.assertIsNotNone(all_declaration, \"__all__ declaration not found in utils.py\")\n+\n+        # Extract the names from the __all__ declaration\n+        if isinstance(all_declaration.value, (ast.Tuple, ast.List)):\n+            all_elements = {elt.s for elt in all_declaration.value.elts if isinstance(elt, ast.Str)}\n+            self.assertIn('expand_router_string', all_elements, \"'expand_router_string' not found in __all__ declaration in utils.py\")\n+        else:\n+            self.fail(\"__all__ declaration is not a tuple or list in utils.py\")\n+\n+    def test_import_expand_router_string_in_routes(self):\n+        # Path to the file where the import should be checked\n+        file_path = 'celery/app/routes.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Parse the routes.py file to check for the specific import\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        import_found = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom):\n+                if node.module == 'celery.app.utils':\n+                    imported_names = {alias.name for alias in node.names}\n+                    if 'expand_router_string' in imported_names:\n+                        import_found = True\n+                        break\n+\n+        self.assertTrue(import_found, \"'expand_router_string' not imported from 'celery.app.utils' in routes.py\")\n+\n+if __name__ == '__main__':\n+    unittest.main()",
    "problem_statement": "Move expand_router_string to celery/app/utils.py and import it into routes.",
    "hints_text": "",
    "created_at": "2025-11-03 22:46:32+00:00",
    "language": "Python",
    "Dockerfile": "N/A",
    "test_command": "python3 -m unittest expand-router-string-to-utils-test.py",
    "task_category": "Refactoring",
    "data_source": "microsoft/RefactorBench",
    "scenario": "brownfield"
  },
  {
    "repo": "celery/celery",
    "url": "https://github.com/celery/celery",
    "instance_id": "object-mro-lookup",
    "base_commit": "object-mro-lookup",
    "patch": "N/A",
    "test_patch": "diff --git a/object-mro-lookup-test.py b/object-mro-lookup-test.py\nnew file mode 100644\nindex 0000000..c56916e\n--- /dev/null\n+++ b/object-mro-lookup-test.py\n@@ -0,0 +1,76 @@\n+import unittest\n+import os\n+import ast\n+\n+class TestWorkerRequestImports(unittest.TestCase):\n+\n+    def test_trace_imports_in_test_request(self):\n+        # Path to the file where the import should be checked\n+        file_path = 't/unit/worker/test_request.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Parse the test_request.py file to check for the specific import\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        expected_imports = {'TraceInfo', 'build_tracer', 'fast_trace_task',\n+                            'reset_worker_optimizations', 'setup_worker_optimizations',\n+                            'trace_task', 'trace_task_ret'}\n+        actual_imports = set()\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom):\n+                if node.module == 'celery.app.trace':\n+                    actual_imports.update({alias.name for alias in node.names})\n+\n+        missing_imports = expected_imports - actual_imports\n+        self.assertFalse(missing_imports, f\"Missing imports from 'celery.app.trace': {', '.join(missing_imports)}\")\n+\n+    def test_mro_lookup_import_in_test_request(self):\n+        # Path to the file where the import should be checked\n+        file_path = 't/unit/worker/test_request.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Parse the test_request.py file to check for the specific import\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        import_found = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom):\n+                if node.module == 'celery.utils.objects' and 'mro_lookup' in {alias.name for alias in node.names}:\n+                    import_found = True\n+                    break\n+\n+        self.assertTrue(import_found, \"'mro_lookup' not imported from 'celery.utils.objects' in test_request.py\")\n+\n+    \n+    def test_mro_lookup_import_in_trace(self):\n+        # Path to the file where the import should be checked\n+        file_path = 'celery/app/trace.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Parse the trace.py file to check for the specific import\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        import_found = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom):\n+                if node.module == 'celery.utils.objects' and 'mro_lookup' in {alias.name for alias in node.names}:\n+                    import_found = True\n+                    break\n+\n+        self.assertTrue(import_found, \"'mro_lookup' not imported from 'celery.utils.objects' in trace.py\")\n+\n+\n+if __name__ == '__main__':\n+    unittest.main()",
    "problem_statement": "Resolve the relay import in test_request of mro_lookup to just import from the file it was defined in.",
    "hints_text": "",
    "created_at": "2025-11-03 22:46:32+00:00",
    "language": "Python",
    "Dockerfile": "N/A",
    "test_command": "python3 -m unittest object-mro-lookup-test.py",
    "task_category": "Refactoring",
    "data_source": "microsoft/RefactorBench",
    "scenario": "brownfield"
  },
  {
    "repo": "celery/celery",
    "url": "https://github.com/celery/celery",
    "instance_id": "dump-message-to-serialization",
    "base_commit": "dump-message-to-serialization",
    "patch": "N/A",
    "test_patch": "diff --git a/dump-message-to-serialization-test.py b/dump-message-to-serialization-test.py\nnew file mode 100644\nindex 0000000..160c10f\n--- /dev/null\n+++ b/dump-message-to-serialization-test.py\n@@ -0,0 +1,72 @@\n+import unittest\n+import os\n+import ast\n+\n+class TestCeleryDumpMessage(unittest.TestCase):\n+\n+    def test_amqp_does_not_contain_dump_message(self):\n+        # Path to the file where dump_message should not be defined\n+        file_path = 'celery/bin/amqp.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Parse the amqp.py file to check for the dump_message function definition\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        dump_message_function = None\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.FunctionDef) and node.name == 'dump_message':\n+                dump_message_function = node\n+                break\n+\n+        self.assertIsNone(dump_message_function, \"Function 'dump_message' should not be found in amqp.py\")\n+\n+    def test_serialization_contains_dump_message(self):\n+        # Path to the file where dump_message should be defined\n+        file_path = 'celery/utils/serialization.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Parse the serialization.py file to check for the dump_message function definition\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        dump_message_function = None\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.FunctionDef) and node.name == 'dump_message':\n+                dump_message_function = node\n+                break\n+\n+        self.assertIsNotNone(dump_message_function, \"Function 'dump_message' not found in serialization.py\")\n+\n+    def test_amqp_imports_dump_message(self):\n+        # Path to the file where the import should be checked\n+        file_path = 'celery/bin/amqp.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Parse the amqp.py file to check for the specific import\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        import_found = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom):\n+                if node.module == 'celery.utils.serialization':\n+                    imported_names = {alias.name for alias in node.names}\n+                    if 'dump_message' in imported_names:\n+                        import_found = True\n+                        break\n+\n+        self.assertTrue(import_found, \"'dump_message' not imported from 'celery.utils.serialization' in amqp.py\")\n+\n+\n+if __name__ == '__main__':\n+    unittest.main()",
    "problem_statement": "Move dump_message to utils serialization.py and update the repo based on the new location.",
    "hints_text": "",
    "created_at": "2025-11-03 22:46:32+00:00",
    "language": "Python",
    "Dockerfile": "N/A",
    "test_command": "python3 -m unittest dump-message-to-serialization-test.py",
    "task_category": "Refactoring",
    "data_source": "microsoft/RefactorBench",
    "scenario": "brownfield"
  },
  {
    "repo": "celery/celery",
    "url": "https://github.com/celery/celery",
    "instance_id": "combine-unpickle-task",
    "base_commit": "combine-unpickle-task",
    "patch": "N/A",
    "test_patch": "diff --git a/combine-unpickle-task-test.py b/combine-unpickle-task-test.py\nnew file mode 100644\nindex 0000000..a537b5b\n--- /dev/null\n+++ b/combine-unpickle-task-test.py\n@@ -0,0 +1,139 @@\n+import unittest\n+import os\n+import ast\n+\n+class TestCeleryRegistry(unittest.TestCase):\n+    \n+    def test_unpickle_task_exists(self):\n+        # Path to the file where the _unpickle_task function should be defined\n+        file_path = 'celery/app/registry.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Parse the registry.py file to check for the _unpickle_task function\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        unpickle_task_function = None\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.FunctionDef) and node.name == '_unpickle_task':\n+                unpickle_task_function = node\n+                break\n+\n+        self.assertIsNotNone(unpickle_task_function, \"Function '_unpickle_task' not found in registry.py\")\n+\n+    def test_unpickle_task_v2_not_exists(self):\n+        # Path to the file where the _unpickle_task_v2 function should be defined\n+        file_path = 'celery/app/registry.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Parse the registry.py file to check for the _unpickle_task_v2 function\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        unpickle_task_v2_function = None\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.FunctionDef) and node.name == '_unpickle_task_v2':\n+                unpickle_task_v2_function = node\n+                break\n+\n+        self.assertIsNone(unpickle_task_v2_function, \"Function '_unpickle_task_v2' was found in registry.py, but it should not exist\")\n+\n+    def test_import_unpickle_task_in_task_py(self):\n+        # Path to the task.py file\n+        file_path = 'celery/app/task.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Parse the task.py file to check for the specific import\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        import_found = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom):\n+                if node.module == 'registry':\n+                    imported_names = {alias.name for alias in node.names}\n+                    if '_unpickle_task' in imported_names:\n+                        import_found = True\n+                        break\n+\n+        self.assertTrue(import_found, \"'from .registry import _unpickle_task' not found in task.py\")\n+\n+    def test_import_unpickle_task_in_test_registry(self):\n+        # Path to the test_registry.py file\n+        file_path = 't/unit/app/test_registry.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Parse the test_registry.py file to check for the specific import\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        import_found = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom):\n+                if node.module == 'celery.app.registry':\n+                    imported_names = {alias.name for alias in node.names}\n+                    if '_unpickle_task' in imported_names:\n+                        import_found = True\n+                        break\n+\n+        self.assertTrue(import_found, \"'from celery.app.registry import _unpickle_task' not found in test_registry.py\")\n+\n+    def test_class_test_unpickle_test_exists(self):\n+        # Path to the test_registry.py file\n+        file_path = 't/unit/app/test_registry.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Parse the test_registry.py file to check for the TestUnpickleTest class\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        class_found = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ClassDef) and node.name == 'test_unpickle_task':\n+                class_found = True\n+                break\n+\n+        self.assertTrue(class_found, \"Class 'test_unpickle_task' not found in test_registry.py\")\n+\n+    def test_function_test_unpickle_exists_in_test_unpickle_test(self):\n+        # Path to the test_registry.py file\n+        file_path = 't/unit/app/test_registry.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Parse the test_registry.py file to check for the test_unpickle function within TestUnpickleTest class\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        test_unpickle_function_found = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ClassDef) and node.name == 'test_unpickle_task':\n+                for class_node in node.body:\n+                    if isinstance(class_node, ast.FunctionDef) and class_node.name == 'test_unpickle':\n+                        test_unpickle_function_found = True\n+                        break\n+                break\n+\n+        self.assertTrue(test_unpickle_function_found, \"Function 'test_unpickle' not found in class 'TestUnpickleTest' in test_registry.py\")\n+\n+\n+\n+if __name__ == '__main__':\n+    unittest.main()",
    "problem_statement": "Combine _unpickle_task and _unpickle_task_v2 and put the _unpickle_task_v2 implementation in _unpickle_task. Update the tests to remove all references to the versons, but have the same core tests.",
    "hints_text": "",
    "created_at": "2025-11-03 22:46:32+00:00",
    "language": "Python",
    "Dockerfile": "N/A",
    "test_command": "python3 -m unittest combine-unpickle-task-test.py",
    "task_category": "Refactoring",
    "data_source": "microsoft/RefactorBench",
    "scenario": "brownfield"
  },
  {
    "repo": "celery/celery",
    "url": "https://github.com/celery/celery",
    "instance_id": "add-log-parameter-node-format",
    "base_commit": "add-log-parameter-node-format",
    "patch": "N/A",
    "test_patch": "diff --git a/add-log-parameter-node-format-test.py b/add-log-parameter-node-format-test.py\nnew file mode 100644\nindex 0000000..194f85e\n--- /dev/null\n+++ b/add-log-parameter-node-format-test.py\n@@ -0,0 +1,95 @@\n+import unittest\n+import os\n+import ast\n+\n+class TestCeleryUtils(unittest.TestCase):\n+\n+    def test_node_format_has_log_parameter(self):\n+        # Path to the file where the node_format function should be defined\n+        file_path = 'celery/utils/nodenames.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Check if node_format function is defined in nodenames.py\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        node_format_function = None\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.FunctionDef) and node.name == 'node_format':\n+                node_format_function = node\n+                break\n+\n+        self.assertIsNotNone(node_format_function, \"Function 'node_format' not found in nodenames.py\")\n+\n+        # Check if the log parameter exists with a default value of False\n+        log_param_found = False\n+        for arg in node_format_function.args.args:\n+            if arg.arg == 'log' and isinstance(arg.annotation, ast.Name) and arg.annotation.id == 'bool':\n+                default_index = node_format_function.args.args.index(arg) - len(node_format_function.args.args) + len(node_format_function.args.defaults)\n+                if default_index >= 0:\n+                    default_value = node_format_function.args.defaults[default_index]\n+                    if isinstance(default_value, ast.Constant) and default_value.value is False:\n+                        log_param_found = True\n+                        break\n+\n+        self.assertTrue(log_param_found, \"Parameter 'log: bool = False' not found in 'node_format' function\")\n+\n+    def test_node_format_calls_in_worker_have_log_true(self):\n+        # Path to the file where the node_format calls should be checked\n+        file_path = 'celery/bin/worker.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Parse the worker.py file to find all calls to node_format\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        node_format_calls_with_log_true = True\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.Call) and isinstance(node.func, ast.Name) and node.func.id == 'node_format':\n+                # Check if 'log=True' is among the arguments\n+                log_param_found = False\n+                for kw in node.keywords:\n+                    if kw.arg == 'log' and isinstance(kw.value, ast.Constant) and kw.value.value is True:\n+                        log_param_found = True\n+                        break\n+                if not log_param_found:\n+                    node_format_calls_with_log_true = False\n+                    break\n+\n+        self.assertTrue(node_format_calls_with_log_true, \"Not all 'node_format' calls in worker.py have 'log=True'\")\n+\n+    def test_node_format_calls_in_log_have_log_true(self):\n+        # Path to the file where the node_format calls should be checked\n+        file_path = 'celery/app/log.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Parse the log.py file to find all calls to node_format\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        node_format_calls_with_log_true = True\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.Call) and isinstance(node.func, ast.Name) and node.func.id == 'node_format':\n+                # Check if 'log=True' is among the arguments\n+                log_param_found = False\n+                for kw in node.keywords:\n+                    if kw.arg == 'log' and isinstance(kw.value, ast.Constant) and kw.value.value is True:\n+                        log_param_found = True\n+                        break\n+                if not log_param_found:\n+                    node_format_calls_with_log_true = False\n+                    break\n+\n+        self.assertTrue(node_format_calls_with_log_true, \"Not all 'node_format' calls in log.py have 'log=True'\")\n+\n+if __name__ == '__main__':\n+    unittest.main()",
    "problem_statement": "Add a log boolean parameter to node_format and make the base case False, make all calls throughout the repo log=True",
    "hints_text": "",
    "created_at": "2025-11-03 22:46:32+00:00",
    "language": "Python",
    "Dockerfile": "N/A",
    "test_command": "python3 -m unittest add-log-parameter-node-format-test.py",
    "task_category": "Refactoring",
    "data_source": "microsoft/RefactorBench",
    "scenario": "brownfield"
  },
  {
    "repo": "celery/celery",
    "url": "https://github.com/celery/celery",
    "instance_id": "evaluate-promises-to-serialization",
    "base_commit": "evaluate-promises-to-serialization",
    "patch": "N/A",
    "test_patch": "diff --git a/evaluate-promises-to-serialization-test.py b/evaluate-promises-to-serialization-test.py\nnew file mode 100644\nindex 0000000..5245d97\n--- /dev/null\n+++ b/evaluate-promises-to-serialization-test.py\n@@ -0,0 +1,82 @@\n+import unittest\n+import os\n+import ast\n+\n+class TestCelerySerializationUtils(unittest.TestCase):\n+\n+    def test_serialization_utils_file_exists(self):\n+        # Path to the file where the evaluate_promises function should be defined\n+        file_path = 'celery/utils/serialization.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+    def test_evaluate_promises_function_exists(self):\n+        # Path to the file where the evaluate_promises function should be defined\n+        file_path = 'celery/utils/serialization.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Check if evaluate_promises function is defined in serialization.py\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        evaluate_promises_function = None\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.FunctionDef) and node.name == 'evaluate_promises':\n+                evaluate_promises_function = node\n+                break\n+\n+        self.assertIsNotNone(evaluate_promises_function, \"Function 'evaluate_promises' not found in serialization.py\")\n+\n+\n+    def test_import_evaluate_promises(self):\n+        # Path to the file where the import should be checked\n+        file_path = 'celery/utils/functional.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Parse the serialization.py file to check for the specific import\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        import_found = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom):\n+                if node.module == 'celery.utils.serialization':\n+                    imported_names = {alias.name for alias in node.names}\n+                    if 'evaluate_promises' in imported_names:\n+                        import_found = True\n+                        break\n+\n+        self.assertTrue(import_found, \"'evaluate_promises' not imported from 'celery.utils.serialization' in functional.py\")\n+\n+    def test_import_promise_from_vine(self):\n+        # Path to the file where the import should be checked\n+        file_path = 'celery/utils/serialization.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Parse the serialization.py file to check for the specific import\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        import_found = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom) and node.module == 'vine':\n+                imported_names = {alias.name for alias in node.names}\n+                if 'promise' in imported_names:\n+                    import_found = True\n+                    break\n+\n+        self.assertTrue(import_found, \"'promise' not imported from 'vine' in serialization.py\")\n+\n+    \n+if __name__ == '__main__':\n+    unittest.main()",
    "problem_statement": "Can you move evaluate_promises from functional into serialization.py and update usage of it.",
    "hints_text": "",
    "created_at": "2025-11-03 22:46:32+00:00",
    "language": "Python",
    "Dockerfile": "N/A",
    "test_command": "python3 -m unittest evaluate-promises-to-serialization-test.py",
    "task_category": "Refactoring",
    "data_source": "microsoft/RefactorBench",
    "scenario": "brownfield"
  },
  {
    "repo": "celery/celery",
    "url": "https://github.com/celery/celery",
    "instance_id": "add-log-parameter-get-digest-algorithm",
    "base_commit": "add-log-parameter-get-digest-algorithm",
    "patch": "N/A",
    "test_patch": "diff --git a/add-log-parameter-get-digest-algorithm-test.py b/add-log-parameter-get-digest-algorithm-test.py\nnew file mode 100644\nindex 0000000..77fc968\n--- /dev/null\n+++ b/add-log-parameter-get-digest-algorithm-test.py\n@@ -0,0 +1,136 @@\n+import unittest\n+import os\n+import ast\n+\n+class TestCelerySecurityUtils(unittest.TestCase):\n+\n+    def test_get_digest_algorithm_function_exists(self):\n+        # Path to the file where the get_digest_algorithm function should be defined\n+        file_path = 'celery/security/utils.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Check if get_digest_algorithm function is defined in utils.py\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        get_digest_algorithm_function = None\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.FunctionDef) and node.name == 'get_digest_algorithm':\n+                get_digest_algorithm_function = node\n+                break\n+\n+        self.assertIsNotNone(get_digest_algorithm_function, \"Function 'get_digest_algorithm' not found in utils.py\")\n+\n+    def test_get_digest_algorithm_has_log_parameter(self):\n+        # Path to the file where the get_digest_algorithm function should be defined\n+        file_path = 'celery/security/utils.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Check if get_digest_algorithm function has a log boolean parameter in utils.py\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        get_digest_algorithm_function = None\n+        log_param_found = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.FunctionDef) and node.name == 'get_digest_algorithm':\n+                get_digest_algorithm_function = node\n+                for arg in get_digest_algorithm_function.args.args:\n+                    if arg.arg == 'log':\n+                        log_param_found = True\n+                        break\n+                break\n+\n+        self.assertIsNotNone(get_digest_algorithm_function, \"Function 'get_digest_algorithm' not found in utils.py\")\n+        self.assertTrue(log_param_found, \"'log' parameter not found in 'get_digest_algorithm' function\")\n+\n+    def test_log_parameter_is_false(self):\n+        # Path to the file where the get_digest_algorithm function should be defined\n+        file_path = 'celery/security/utils.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Check if log parameter is set to False by default in get_digest_algorithm function in utils.py\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        get_digest_algorithm_function = None\n+        log_param_is_false = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.FunctionDef) and node.name == 'get_digest_algorithm':\n+                get_digest_algorithm_function = node\n+                for arg, default in zip(get_digest_algorithm_function.args.args, get_digest_algorithm_function.args.defaults):\n+                    if arg.arg == 'log':\n+                        if isinstance(default, ast.Constant) and default.value is False:\n+                            log_param_is_false = True\n+                        break\n+                break\n+\n+        self.assertIsNotNone(get_digest_algorithm_function, \"Function 'get_digest_algorithm' not found in utils.py\")\n+        self.assertTrue(log_param_is_false, \"'log' parameter does not have a default value of 'False' in 'get_digest_algorithm' function\")\n+\n+    def test_get_digest_algorithm_calls_have_log_true(self):\n+        # Path to the file where the get_digest_algorithm calls should be checked\n+        file_path = 'celery/security/serialization.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Parse the serialization.py file to find all calls to get_digest_algorithm\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        log_true_for_all_calls = True\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.Call) and isinstance(node.func, ast.Name) and node.func.id == 'get_digest_algorithm':\n+                log_arg_found = False\n+                for keyword in node.keywords:\n+                    if keyword.arg == 'log' and isinstance(keyword.value, ast.Constant) and keyword.value.value is True:\n+                        log_arg_found = True\n+                        break\n+                if not log_arg_found:\n+                    log_true_for_all_calls = False\n+                    break\n+\n+        self.assertTrue(log_true_for_all_calls, \"Not all calls to 'get_digest_algorithm' have 'log=True' in serialization.py\")\n+\n+    def test_get_digest_algorithm_calls_log_false_or_not_passed(self):\n+        # Path to the file where the get_digest_algorithm calls should be checked\n+        file_path = 't/unit/security/test_key.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Parse the test_key.py file to find all calls to get_digest_algorithm\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        log_valid_for_all_calls = True\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.Call) and isinstance(node.func, ast.Name) and node.func.id == 'get_digest_algorithm':\n+                log_arg_found = False\n+                log_arg_is_false = False\n+                for keyword in node.keywords:\n+                    if keyword.arg == 'log':\n+                        log_arg_found = True\n+                        if isinstance(keyword.value, ast.Constant) and keyword.value.value is False:\n+                            log_arg_is_false = True\n+                        break\n+                if log_arg_found and not log_arg_is_false:\n+                    log_valid_for_all_calls = False\n+                    break\n+\n+        self.assertTrue(log_valid_for_all_calls, \"Not all calls to 'get_digest_algorithm' have 'log=False' or no 'log' argument in test_key.py\")\n+\n+if __name__ == '__main__':\n+    unittest.main()",
    "problem_statement": "Can you add a log boolean parameter to get_digest_algorithm and keep the base as log=False and then in all references except testing files make log=True",
    "hints_text": "",
    "created_at": "2025-11-03 22:46:32+00:00",
    "language": "Python",
    "Dockerfile": "N/A",
    "test_command": "python3 -m unittest add-log-parameter-get-digest-algorithm-test.py",
    "task_category": "Refactoring",
    "data_source": "microsoft/RefactorBench",
    "scenario": "brownfield"
  },
  {
    "repo": "celery/celery",
    "url": "https://github.com/celery/celery",
    "instance_id": "annotation-utils",
    "base_commit": "annotation-utils",
    "patch": "N/A",
    "test_patch": "diff --git a/annotation-utils-test.py b/annotation-utils-test.py\nnew file mode 100644\nindex 0000000..81d39d0\n--- /dev/null\n+++ b/annotation-utils-test.py\n@@ -0,0 +1,178 @@\n+import unittest\n+import os\n+import ast\n+\n+class TestCeleryAnnotationsUtils(unittest.TestCase):\n+\n+    def test_annotations_utils_file_exists(self):\n+        # Path to the file where the resolve_all function should be defined\n+        file_path = 'celery/app/annotations_utils.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+    def test_resolve_all_function_exists(self):\n+        # Path to the file where the resolve_all function should be defined\n+        file_path = 'celery/app/annotations_utils.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Check if resolve_all function is defined in annotations_utils.py\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        resolve_all_function = None\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.FunctionDef) and node.name == 'resolve_all':\n+                resolve_all_function = node\n+                break\n+\n+        self.assertIsNotNone(resolve_all_function, \"Function 'resolve_all' not found in annotations_utils.py\")\n+\n+    def test_resolve_all_in_all_declaration(self):\n+        # Path to the file where the __all__ declaration should be checked\n+        file_path = 'celery/app/annotations_utils.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Check if resolve_all is included in __all__ in annotations_utils.py\n+        with open(file_path, 'r') as file:\n+            content = file.read()\n+\n+        # Look for the exact __all__ declaration\n+        expected_all_declaration = \"__all__ = ('resolve_all')\"\n+        self.assertIn(expected_all_declaration, content, f\"{expected_all_declaration} not found in annotations_utils.py\")\n+\n+    def test_import_first_match_and_first_match_any(self):\n+        # Path to the file where the import should be checked\n+        file_path = 'celery/app/annotations_utils.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Parse the annotations_utils.py file to check for the specific import\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        import_found = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom):\n+                if node.module == 'celery.app.annotations':\n+                    imported_names = {alias.name for alias in node.names}\n+                    if {'_first_match', '_first_match_any'}.issubset(imported_names):\n+                        import_found = True\n+                        break\n+\n+        self.assertTrue(import_found, \"'_first_match' and '_first_match_any' not imported from 'celery.app.annotations' in annotations_utils.py\")\n+\n+    def test_annotations_all_declaration(self):\n+        # Path to the file where the __all__ declaration should be checked\n+        file_path = 'celery/app/annotations.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Check if __all__ includes 'MapAnnotation' and 'prepare' in annotations.py\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        all_found = False\n+        mapannotation_in_all = False\n+        prepare_in_all = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.Assign):\n+                for target in node.targets:\n+                    if isinstance(target, ast.Name) and target.id == '__all__':\n+                        all_found = True\n+                        if isinstance(node.value, ast.Tuple) or isinstance(node.value, ast.List):\n+                            elements = {element.s for element in node.value.elts if isinstance(element, ast.Str)}\n+                            mapannotation_in_all = 'MapAnnotation' in elements\n+                            prepare_in_all = 'prepare' in elements\n+                            break\n+\n+        self.assertTrue(all_found, \"__all__ declaration not found in annotations.py\")\n+        self.assertTrue(mapannotation_in_all, \"'MapAnnotation' not found in __all__ declaration in annotations.py\")\n+        self.assertTrue(prepare_in_all, \"'prepare' not found in __all__ declaration in annotations.py\")\n+\n+    def test_mapannotation_class_exists(self):\n+        # Path to the file where the MapAnnotation class should be defined\n+        file_path = 'celery/app/annotations.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Parse the annotations.py file to check for the MapAnnotation class\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        mapannotation_class = None\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ClassDef) and node.name == 'MapAnnotation':\n+                mapannotation_class = node\n+                break\n+\n+        self.assertIsNotNone(mapannotation_class, \"Class 'MapAnnotation' not found in annotations.py\")\n+\n+    def test_prepare_function_exists(self):\n+        # Path to the file where the prepare function should be defined\n+        file_path = 'celery/app/annotations.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Parse the annotations.py file to check for the prepare function\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        prepare_function = None\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.FunctionDef) and node.name == 'prepare':\n+                prepare_function = node\n+                break\n+\n+        self.assertIsNotNone(prepare_function, \"Function 'prepare' not found in annotations.py\")\n+\n+    def test_first_match_and_first_match_any_assignments(self):\n+        # Path to the file where the assignments should be checked\n+        file_path = 'celery/app/annotations.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Parse the annotations.py file to check for _first_match and _first_match_any assignments\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        first_match_assignment = None\n+        first_match_any_assignment = None\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.Assign):\n+                for target in node.targets:\n+                    if isinstance(target, ast.Name):\n+                        if target.id == '_first_match' and isinstance(node.value, ast.Call):\n+                            if isinstance(node.value.func, ast.Name) and node.value.func.id == 'firstmethod':\n+                                if (len(node.value.args) == 1 and \n+                                    isinstance(node.value.args[0], ast.Str) and \n+                                    node.value.args[0].s == 'annotate'):\n+                                    first_match_assignment = node\n+                        elif target.id == '_first_match_any' and isinstance(node.value, ast.Call):\n+                            if isinstance(node.value.func, ast.Name) and node.value.func.id == 'firstmethod':\n+                                if (len(node.value.args) == 1 and \n+                                    isinstance(node.value.args[0], ast.Str) and \n+                                    node.value.args[0].s == 'annotate_any'):\n+                                    first_match_any_assignment = node\n+\n+        self.assertIsNotNone(first_match_assignment, \"'_first_match = firstmethod('annotate')' not found in annotations.py\")\n+        self.assertIsNotNone(first_match_any_assignment, \"'_first_match_any = firstmethod('annotate_any')' not found in annotations.py\")\n+\n+\n+if __name__ == '__main__':\n+    unittest.main()",
    "problem_statement": "Can you move only resolve_all from annotations to a new file called annotations_utils.py. Make sure to import the match functions from celery.app.annotations",
    "hints_text": "",
    "created_at": "2025-11-03 22:46:32+00:00",
    "language": "Python",
    "Dockerfile": "N/A",
    "test_command": "python3 -m unittest annotation-utils-test.py",
    "task_category": "Refactoring",
    "data_source": "microsoft/RefactorBench",
    "scenario": "brownfield"
  },
  {
    "repo": "celery/celery",
    "url": "https://github.com/celery/celery",
    "instance_id": "ensure_serialize",
    "base_commit": "ensure_serialize",
    "patch": "N/A",
    "test_patch": "diff --git a/ensure_serialize-test.py b/ensure_serialize-test.py\nnew file mode 100644\nindex 0000000..83da5b3\n--- /dev/null\n+++ b/ensure_serialize-test.py\n@@ -0,0 +1,214 @@\n+import unittest\n+import os\n+import ast\n+\n+class TestCeleryUtils(unittest.TestCase):\n+\n+    def test_ensure_serialize_function_exists(self):\n+        # Path to the file where the ensure_serialize function should be defined\n+        file_path = 'celery/utils/serialization.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Check if ensure_serialize function is defined in serialization.py\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        ensure_serialize_function = None\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.FunctionDef) and node.name == 'ensure_serialize':\n+                ensure_serialize_function = node\n+                break\n+\n+        self.assertIsNotNone(ensure_serialize_function, \"Function 'ensure_serialize' not found in serialization.py\")\n+\n+    def test_ensure_serialization_function_does_not_exist(self):\n+        # Path to the file where the ensure_serialization function should not be defined\n+        file_path = 'celery/utils/serialization.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Check if ensure_serialization function is not defined in serialization.py\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        ensure_serialization_function = None\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.FunctionDef) and node.name == 'ensure_serialization':\n+                ensure_serialization_function = node\n+                break\n+\n+        self.assertIsNone(ensure_serialization_function, \"Function 'ensure_serialization' should not be present in serialization.py\")\n+\n+    def test_ensure_serialize_usage_count(self):\n+        # Path to the file where the ensure_serialize function usage should be checked\n+        file_path = 'celery/utils/serialization.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Parse the serialization.py file to count the usages of ensure_serialize\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        ensure_serialize_usages = 0\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.Call) and isinstance(node.func, ast.Name) and node.func.id == 'ensure_serialize':\n+                ensure_serialize_usages += 1\n+\n+        self.assertEqual(ensure_serialize_usages, 1, \"There should be exactly one usage of 'ensure_serialize' in serialization.py\")\n+\n+    def test_required_imports_in_base(self):\n+        # Path to the file where the imports should be checked\n+        file_path = 'celery/backends/base.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Parse the base.py file to check for the required imports\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        required_imports = {\n+            'create_exception_cls': False,\n+            'ensure_serialize': False,\n+            'get_pickleable_exception': False,\n+            'get_pickled_exception': False,\n+            'raise_with_context': False,\n+        }\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom) and node.module == 'celery.utils.serialization':\n+                for name in node.names:\n+                    if name.name in required_imports:\n+                        required_imports[name.name] = True\n+\n+        for import_name, is_imported in required_imports.items():\n+            self.assertTrue(is_imported, f\"'{import_name}' is not imported from 'celery.utils.serialization' in base.py\")\n+\n+    def test_class_test_ensure_serialize_exists(self):\n+        # Path to the file where the test_ensure_serialize class should be defined\n+        file_path = 't/unit/utils/test_serialization.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Parse the test_serialization.py file to check for the class definition\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        class_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ClassDef) and node.name == 'test_ensure_serialize':\n+                class_found = True\n+                break\n+\n+        self.assertTrue(class_found, \"Class 'test_ensure_serialize' not found in test_serialization.py\")\n+\n+    def test_methods_exist_in_test_ensure_serialize(self):\n+        # Path to the file where the methods should be defined in the test_ensure_serialize class\n+        file_path = 't/unit/utils/test_serialization.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Parse the test_serialization.py file to check for the method definitions\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        methods_found = {'test_json_py3': False, 'test_pickle': False}\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ClassDef) and node.name == 'test_ensure_serialize':\n+                for method in node.body:\n+                    if isinstance(method, ast.FunctionDef):\n+                        if method.name in methods_found:\n+                            methods_found[method.name] = True\n+                break\n+\n+        for method_name, found in methods_found.items():\n+            self.assertTrue(found, f\"Method '{method_name}' not found in class 'test_ensure_serialize'\")\n+\n+    def test_ensure_serialize_used_in_methods(self):\n+        # Path to the file where the ensure_serialize function usage should be checked in the test methods\n+        file_path = 't/unit/utils/test_serialization.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Parse the test_serialization.py file to check for ensure_serialize usage\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        ensure_serialize_usage_found = {'test_json_py3': False, 'test_pickle': False}\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ClassDef) and node.name == 'test_ensure_serialize':\n+                for method in node.body:\n+                    if isinstance(method, ast.FunctionDef):\n+                        for subnode in ast.walk(method):\n+                            if isinstance(subnode, ast.Call) and isinstance(subnode.func, ast.Name) and subnode.func.id == 'ensure_serialize':\n+                                ensure_serialize_usage_found[method.name] = True\n+                break\n+\n+        for method_name, found in ensure_serialize_usage_found.items():\n+            self.assertTrue(found, f\"'ensure_serialize' not used in method '{method_name}'\")\n+\n+    def test_required_imports_in_test_serialization(self):\n+        # Path to the file where the imports should be checked\n+        file_path = 't/unit/utils/test_serialization.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Parse the test_serialization.py file to check for the required imports\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        required_imports = {\n+            'STRTOBOOL_DEFAULT_TABLE': False,\n+            'UnpickleableExceptionWrapper': False,\n+            'ensure_serialize': False,\n+            'get_pickleable_etype': False,\n+            'jsonify': False,\n+            'strtobool': False,\n+        }\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom) and node.module == 'celery.utils.serialization':\n+                for name in node.names:\n+                    if name.name in required_imports:\n+                        required_imports[name.name] = True\n+\n+        for import_name, is_imported in required_imports.items():\n+            self.assertTrue(is_imported, f\"'{import_name}' is not imported from 'celery.utils.serialization' in test_serialization.py\")\n+\n+    def test_serialization_ensure_serialize_used_in_test_base(self):\n+        # Path to the file where serialization.ensure_serialize usage should be checked\n+        file_path = 't/unit/backends/test_base.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Parse the test_base.py file to check for serialization.ensure_serialize usage\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        ensure_serialize_usage_found = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.Call) and isinstance(node.func, ast.Attribute):\n+                if (isinstance(node.func.value, ast.Name) and node.func.value.id == 'serialization' \n+                    and node.func.attr == 'ensure_serialize'):\n+                    ensure_serialize_usage_found = True\n+                    break\n+\n+        self.assertTrue(ensure_serialize_usage_found, \"'serialization.ensure_serialize' not used in test_base.py\")\n+\n+\n+    \n+if __name__ == '__main__':\n+    unittest.main()",
    "problem_statement": "Rename ensure_serializable to ensure_serialize and then update all the references and functions throughout the codebase accordingly.",
    "hints_text": "",
    "created_at": "2025-11-03 22:46:32+00:00",
    "language": "Python",
    "Dockerfile": "N/A",
    "test_command": "python3 -m unittest ensure_serialize-test.py",
    "task_category": "Refactoring",
    "data_source": "microsoft/RefactorBench",
    "scenario": "brownfield"
  },
  {
    "repo": "scrapy/scrapy",
    "url": "https://github.com/scrapy/scrapy",
    "instance_id": "add-log-parameter-disconnect-all",
    "base_commit": "add-log-parameter-disconnect-all",
    "patch": "N/A",
    "test_patch": "diff --git a/add-log-parameter-disconnect-all-test.py b/add-log-parameter-disconnect-all-test.py\nnew file mode 100644\nindex 0000000..2ee8ba9\n--- /dev/null\n+++ b/add-log-parameter-disconnect-all-test.py\n@@ -0,0 +1,142 @@\n+import unittest\n+import os\n+import ast\n+import hashlib\n+\n+class TestScrapyMigration(unittest.TestCase):\n+\n+    def test_disconnect_all_has_log_param(self):\n+        # Path to the file where the function is defined\n+        file_path = 'scrapy/utils/signal.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Check if the function is defined in signal.py and has a boolean parameter 'log'\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        function_found = False\n+        log_param_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.FunctionDef) and node.name == 'disconnect_all':\n+                function_found = True\n+                # Check if 'log' is a parameter and if its default value is boolean\n+                for arg in node.args.args:\n+                    if arg.arg == 'log':\n+                        log_param_found = True\n+                        # Check if 'log' has a default value and if it's boolean\n+                        if node.args.defaults:\n+                            log_default_value = node.args.defaults[-1]\n+                            if isinstance(log_default_value, ast.Constant) and isinstance(log_default_value.value, bool):\n+                                log_param_found = True\n+                                break\n+\n+        self.assertTrue(function_found, \"Function 'disconnect_all' not found in signal.py\")\n+        self.assertTrue(log_param_found, \"Function 'disconnect_all' does not have a boolean parameter 'log'\")\n+\n+    def test_test_engine_imports_disconnect_all(self):\n+        # Path to the test_engine file\n+        tests_file_path = 'tests/test_engine.py' \n+\n+        # Check if the test file exists\n+        self.assertTrue(os.path.exists(tests_file_path), f\"Test file {tests_file_path} does not exist\")\n+\n+        # Check if the import statement for disconnect_all is present\n+        with open(tests_file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        import_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom):\n+                if node.module == 'scrapy.utils.signal' and \\\n+                   any(alias.name == 'disconnect_all' for alias in node.names):\n+                    import_found = True\n+                    break\n+\n+        self.assertTrue(import_found, \"Import 'from scrapy.utils.signal import disconnect_all' not found in test_engine.py\")\n+\n+    def test_test_pipeline_media_imports_disconnect_all(self):\n+        # Path to the test_pipeline_media file\n+        tests_file_path = 'tests/test_pipeline_media.py' \n+\n+        # Check if the test file exists\n+        self.assertTrue(os.path.exists(tests_file_path), f\"Test file {tests_file_path} does not exist\")\n+\n+        # Check if the import statement for disconnect_all is present\n+        with open(tests_file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        import_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom):\n+                if node.module == 'scrapy.utils.signal' and \\\n+                   any(alias.name == 'disconnect_all' for alias in node.names):\n+                    import_found = True\n+                    break\n+\n+        self.assertTrue(import_found, \"Import 'from scrapy.utils.signal import disconnect_all' not found in test_pipeline_media.py\")\n+\n+    def test_signalmanager_file_unchanged(self):\n+        # Path to the signalmanager.py file\n+        file_path = 'scrapy/signalmanager.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Calculate the hash of the file\n+        with open(file_path, 'rb') as file:\n+            file_content = file.read()\n+            file_hash = hashlib.sha256(file_content).hexdigest()\n+\n+        # The expected hash for the unchanged file\n+        expected_hash = '5f8681de29fccd22e2b0aa50a6255ab22d81e5abdddb43c46ef059cb2cc4532c'  # Replace with the actual hash value\n+\n+        # Check if the file hash matches the expected hash\n+        self.assertEqual(file_hash, expected_hash, \"The signalmanager.py file has been modified\")\n+\n+    def test_disconnect_all_log_param_in_test_engine(self):\n+        # Path to the test_engine file\n+        tests_file_path = 'tests/test_engine.py'\n+\n+        # Check if the test file exists\n+        self.assertTrue(os.path.exists(tests_file_path), f\"Test file {tests_file_path} does not exist\")\n+\n+        # Check if the disconnect_all function is called with the 'log' parameter\n+        with open(tests_file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        log_param_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.Call) and isinstance(node.func, ast.Name) and node.func.id == 'disconnect_all':\n+                for keyword in node.keywords:\n+                    if keyword.arg == 'log':\n+                        log_param_found = True\n+                        break\n+\n+        self.assertTrue(log_param_found, \"The 'disconnect_all' function is not called with the 'log' parameter in test_engine.py\")\n+\n+    def test_disconnect_all_log_param_in_test_pipeline_media(self):\n+        # Path to the test_pipeline_media file\n+        tests_file_path = 'tests/test_pipeline_media.py'\n+\n+        # Check if the test file exists\n+        self.assertTrue(os.path.exists(tests_file_path), f\"Test file {tests_file_path} does not exist\")\n+\n+        # Check if the disconnect_all function is called with the 'log' parameter\n+        with open(tests_file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        log_param_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.Call) and isinstance(node.func, ast.Name) and node.func.id == 'disconnect_all':\n+                for keyword in node.keywords:\n+                    if keyword.arg == 'log':\n+                        log_param_found = True\n+                        break\n+\n+        self.assertTrue(log_param_found, \"The 'disconnect_all' function is not called with the 'log' parameter in test_pipeline_media.py\")\n+\n+\n+if __name__ == '__main__':\n+    unittest.main()",
    "problem_statement": "Add a logging parameter to disconnect_all in signal.py in utils. Make the base case true and make sure any calls in tests have log=False",
    "hints_text": "",
    "created_at": "2025-11-03 22:46:32+00:00",
    "language": "Python",
    "Dockerfile": "N/A",
    "test_command": "python3 -m unittest add-log-parameter-disconnect-all-test.py",
    "task_category": "Refactoring",
    "data_source": "microsoft/RefactorBench",
    "scenario": "brownfield"
  },
  {
    "repo": "scrapy/scrapy",
    "url": "https://github.com/scrapy/scrapy",
    "instance_id": "parameterize-gunzip",
    "base_commit": "parameterize-gunzip",
    "patch": "N/A",
    "test_patch": "diff --git a/parameterize-gunzip-test.py b/parameterize-gunzip-test.py\nnew file mode 100644\nindex 0000000..8429e0d\n--- /dev/null\n+++ b/parameterize-gunzip-test.py\n@@ -0,0 +1,245 @@\n+import unittest\n+import os\n+import ast\n+\n+class TestScrapyMigration(unittest.TestCase):\n+\n+    def test_gunzipparams_class_exists(self):\n+        # Path to the file where the class should be defined\n+        file_path = 'scrapy/utils/gz.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Check if the GunzipParams class is defined in gz.py\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        class_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ClassDef) and node.name == 'GunzipParams':\n+                class_found = True\n+                break\n+\n+        self.assertTrue(class_found, \"Class 'GunzipParams' not found in gz.py\")\n+\n+    def test_gunzipparams_has_data_and_max_size(self):\n+        # Path to the file where the class should be defined\n+        file_path = 'scrapy/utils/gz.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Check if the GunzipParams class has self.data and self.max_size attributes\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        class_node = None\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ClassDef) and node.name == 'GunzipParams':\n+                class_node = node\n+                break\n+\n+        self.assertIsNotNone(class_node, \"Class 'GunzipParams' not found in gz.py\")\n+\n+        data_found = False\n+        max_size_found = False\n+        for node in ast.walk(class_node):\n+            if isinstance(node, ast.Assign):\n+                for target in node.targets:\n+                    if isinstance(target, ast.Attribute) and target.attr == 'data':\n+                        data_found = True\n+                    if isinstance(target, ast.Attribute) and target.attr == 'max_size':\n+                        max_size_found = True\n+\n+        self.assertTrue(data_found, \"Attribute 'self.data' not found in GunzipParams class\")\n+        self.assertTrue(max_size_found, \"Attribute 'self.max_size' not found in GunzipParams class\")\n+\n+    def test_gunzip_function_signature(self):\n+        # Path to the file where the function should be defined\n+        file_path = 'scrapy/utils/gz.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Check if the gunzip function has the correct signature\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        function_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.FunctionDef) and node.name == 'gunzip':\n+                # Check function parameters\n+                args = node.args\n+                if len(args.args) == 1 and isinstance(args.args[0].annotation, ast.Name) and args.args[0].annotation.id == 'GunzipParams':\n+                    # Check return type\n+                    if isinstance(node.returns, ast.Name) and node.returns.id == 'bytes':\n+                        function_found = True\n+                        break\n+\n+        self.assertTrue(function_found, \"Function 'gunzip' with signature 'def gunzip(params: GunzipParams) -> bytes' not found in gz.py\")\n+\n+    def test_gunzip_in_sitemapspider(self):\n+        # Path to the file where SitemapSpider should be defined\n+        file_path = 'scrapy/spiders/sitemap.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Check if the SitemapSpider class has a method _get_sitemap_body that uses gunzip with GunzipParams\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        sitemapspider_class = None\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ClassDef) and node.name == 'SitemapSpider':\n+                sitemapspider_class = node\n+                break\n+\n+        self.assertIsNotNone(sitemapspider_class, \"Class 'SitemapSpider' not found in sitemap.py\")\n+\n+        method_found = False\n+        gunzip_params_used = False\n+        for node in ast.walk(sitemapspider_class):\n+            if isinstance(node, ast.FunctionDef) and node.name == '_get_sitemap_body':\n+                method_found = True\n+                for inner_node in ast.walk(node):\n+                    if isinstance(inner_node, ast.Call) and isinstance(inner_node.func, ast.Name) and inner_node.func.id == 'gunzip':\n+                        if len(inner_node.args) == 1:\n+                            arg = inner_node.args[0]\n+                            # Check if the argument passed to gunzip is an instance of GunzipParams\n+                            if isinstance(arg, ast.Name) or (isinstance(arg, ast.Attribute) and arg.attr == 'GunzipParams'):\n+                                gunzip_params_used = True\n+                                break\n+\n+        self.assertTrue(method_found, \"Method '_get_sitemap_body' not found in SitemapSpider class\")\n+        self.assertTrue(gunzip_params_used, \"gunzip function inside '_get_sitemap_body' does not use a 'GunzipParams' object as a parameter\")\n+\n+    def test_imports_in_sitemap(self):\n+        # Path to the file where the imports should be defined\n+        file_path = 'scrapy/spiders/sitemap.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Check if the correct import statement is present\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        imports_found = {\n+            \"GunzipParams\": False,\n+            \"gunzip\": False,\n+            \"gzip_magic_number\": False\n+        }\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom) and node.module == 'scrapy.utils.gz':\n+                for alias in node.names:\n+                    if alias.name in imports_found:\n+                        imports_found[alias.name] = True\n+\n+        for import_name, found in imports_found.items():\n+            self.assertTrue(found, f\"Import '{import_name}' not found in sitemap.py\")\n+\n+    def test_imports_in_test_utils_gz(self):\n+        # Path to the test file where the imports should be defined\n+        test_file_path = 'tests/test_utils_gz.py'\n+\n+        # Check if the test file exists\n+        self.assertTrue(os.path.exists(test_file_path), f\"{test_file_path} does not exist\")\n+\n+        # Check if the correct import statement is present\n+        with open(test_file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        imports_found = {\n+            \"GunzipParams\": False,\n+            \"gunzip\": False,\n+            \"gzip_magic_number\": False\n+        }\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom) and node.module == 'scrapy.utils.gz':\n+                for alias in node.names:\n+                    if alias.name in imports_found:\n+                        imports_found[alias.name] = True\n+\n+        for import_name, found in imports_found.items():\n+            self.assertTrue(found, f\"Import '{import_name}' not found in test_utils_gz.py\")\n+\n+    def test_gunzipparams_used_in_test_utils_gz(self):\n+        # Path to the test file where gunzip should be used with GunzipParams\n+        test_file_path = 'tests/test_utils_gz.py'\n+\n+        # Check if the test file exists\n+        self.assertTrue(os.path.exists(test_file_path), f\"{test_file_path} does not exist\")\n+\n+        # Check if the gunzip function is used with GunzipParams in the test file\n+        with open(test_file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        gunzip_params_used = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.Call) and isinstance(node.func, ast.Name) and node.func.id == 'gunzip':\n+                if len(node.args) == 1:\n+                    arg = node.args[0]\n+                    # Check if the argument passed to gunzip is an instance of GunzipParams\n+                    if isinstance(arg, ast.Name) or (isinstance(arg, ast.Attribute) and arg.attr == 'GunzipParams'):\n+                        gunzip_params_used = True\n+                        break\n+\n+        self.assertTrue(gunzip_params_used, \"gunzip function in 'test_utils_gz.py' does not use a 'GunzipParams' object as a parameter\")\n+\n+    def test_imports_in_test_downloadermiddleware_httpcompression(self):\n+        # Path to the test file where the imports should be defined\n+        test_file_path = 'tests/test_downloadermiddleware_httpcompression.py'\n+\n+        # Check if the test file exists\n+        self.assertTrue(os.path.exists(test_file_path), f\"{test_file_path} does not exist\")\n+\n+        # Check if the correct import statement is present\n+        with open(test_file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        imports_found = {\n+            \"GunzipParams\": False,\n+            \"gunzip\": False\n+        }\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom) and node.module == 'scrapy.utils.gz':\n+                for alias in node.names:\n+                    if alias.name in imports_found:\n+                        imports_found[alias.name] = True\n+\n+        for import_name, found in imports_found.items():\n+            self.assertTrue(found, f\"Import '{import_name}' not found in test_downloadermiddleware_httpcompression.py\")\n+    \n+    def test_gunzipparams_used_in_httpcompression_middleware(self):\n+        # Path to the middleware file where gunzip should be used with GunzipParams\n+        middleware_file_path = 'scrapy/downloadermiddlewares/httpcompression.py'\n+\n+        # Check if the middleware file exists\n+        self.assertTrue(os.path.exists(middleware_file_path), f\"{middleware_file_path} does not exist\")\n+\n+        # Check if the gunzip function is used with GunzipParams in the middleware file\n+        with open(middleware_file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        gunzip_params_used = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.Call) and isinstance(node.func, ast.Name) and node.func.id == 'gunzip':\n+                if len(node.args) == 1:\n+                    arg = node.args[0]\n+                    # Check if the argument passed to gunzip is an instance of GunzipParams\n+                    if isinstance(arg, ast.Name) or (isinstance(arg, ast.Attribute) and arg.attr == 'GunzipParams'):\n+                        gunzip_params_used = True\n+                        break\n+\n+        self.assertTrue(gunzip_params_used, \"gunzip function in 'httpcompression.py' does not use a 'GunzipParams' object as a parameter\")\n+\n+\n+\n+\n+if __name__ == '__main__':\n+    unittest.main()",
    "problem_statement": "Encapsulate the parameters in gunzip into a new class called GunzipParams and update all references within the repository to create a GunzipParams object.",
    "hints_text": "",
    "created_at": "2025-11-03 22:46:32+00:00",
    "language": "Python",
    "Dockerfile": "N/A",
    "test_command": "python3 -m unittest parameterize-gunzip-test.py",
    "task_category": "Refactoring",
    "data_source": "microsoft/RefactorBench",
    "scenario": "brownfield"
  },
  {
    "repo": "scrapy/scrapy",
    "url": "https://github.com/scrapy/scrapy",
    "instance_id": "genspider-functions-to-utils-url",
    "base_commit": "genspider-functions-to-utils-url",
    "patch": "N/A",
    "test_patch": "diff --git a/genspider-functions-to-utils-url-test.py b/genspider-functions-to-utils-url-test.py\nnew file mode 100644\nindex 0000000..7fe2ce8\n--- /dev/null\n+++ b/genspider-functions-to-utils-url-test.py\n@@ -0,0 +1,96 @@\n+import unittest\n+import os\n+import ast\n+\n+class TestFunctionMigration(unittest.TestCase):\n+\n+    def test_functions_moved_to_utils_url(self):\n+        # Path to the file where the functions should be moved\n+        utils_url_path = 'scrapy/utils/url.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(utils_url_path), f\"{utils_url_path} does not exist\")\n+\n+        # Check if the functions are defined in url.py\n+        with open(utils_url_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        functions_to_check = ['verify_url_scheme', 'sanitize_module_name', 'extract_domain']\n+        functions_found = {function: False for function in functions_to_check}\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.FunctionDef) and node.name in functions_found:\n+                functions_found[node.name] = True\n+\n+        for function, found in functions_found.items():\n+            self.assertTrue(found, f\"Function '{function}' not found in url.py\")\n+\n+    def test_functions_removed_from_genspider(self):\n+        # Path to the file where the functions should be removed from\n+        genspider_path = 'scrapy/commands/genspider.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(genspider_path), f\"{genspider_path} does not exist\")\n+\n+        # Check if the functions are not defined in genspider.py\n+        with open(genspider_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        functions_to_check = ['verify_url_scheme', 'sanitize_module_name', 'extract_domain']\n+        functions_found = {function: False for function in functions_to_check}\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.FunctionDef) and node.name in functions_found:\n+                functions_found[node.name] = True\n+\n+        for function, found in functions_found.items():\n+            self.assertFalse(found, f\"Function '{function}' should not be found in genspider.py\")\n+\n+    def test_utils_url_imports_string(self):\n+        # Path to the file where the string module should be imported\n+        utils_url_path = 'scrapy/utils/url.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(utils_url_path), f\"{utils_url_path} does not exist\")\n+\n+        # Check if the string module is imported in url.py\n+        with open(utils_url_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        string_import_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.Import) or isinstance(node, ast.ImportFrom):\n+                if isinstance(node, ast.Import):\n+                    if any(alias.name == 'string' for alias in node.names):\n+                        string_import_found = True\n+                        break\n+                elif isinstance(node, ast.ImportFrom) and node.module == 'string':\n+                    string_import_found = True\n+                    break\n+\n+        self.assertTrue(string_import_found, \"The 'string' module is not imported in url.py\")\n+\n+    def test_genspider_imports_from_utils_url(self):\n+        # Path to the file where the imports should be present\n+        genspider_path = 'scrapy/commands/genspider.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(genspider_path), f\"{genspider_path} does not exist\")\n+\n+        # Check if the required imports are present in genspider.py\n+        with open(genspider_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        import_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom) and node.module == 'scrapy.utils.url':\n+                imported_functions = {alias.name for alias in node.names}\n+                if {'extract_domain', 'sanitize_module_name', 'verify_url_scheme'}.issubset(imported_functions):\n+                    import_found = True\n+                    break\n+\n+        self.assertTrue(import_found, \n+            \"The imports 'from scrapy.utils.url import extract_domain, sanitize_module_name, verify_url_scheme' were not found in genspider.py\")\n+\n+if __name__ == '__main__':\n+    unittest.main()",
    "problem_statement": "move the url functions outside of the main class in commands/genspider to utils url and update the imports accordingly.",
    "hints_text": "",
    "created_at": "2025-11-03 22:46:32+00:00",
    "language": "Python",
    "Dockerfile": "N/A",
    "test_command": "python3 -m unittest genspider-functions-to-utils-url-test.py",
    "task_category": "Refactoring",
    "data_source": "microsoft/RefactorBench",
    "scenario": "brownfield"
  },
  {
    "repo": "scrapy/scrapy",
    "url": "https://github.com/scrapy/scrapy",
    "instance_id": "rename-engine-status",
    "base_commit": "rename-engine-status",
    "patch": "N/A",
    "test_patch": "diff --git a/rename-engine-status-test.py b/rename-engine-status-test.py\nnew file mode 100644\nindex 0000000..50dcbf5\n--- /dev/null\n+++ b/rename-engine-status-test.py\n@@ -0,0 +1,151 @@\n+import unittest\n+import os\n+import ast\n+\n+class TestScrapyMigration(unittest.TestCase):\n+\n+    def setUp(self):\n+        # Paths to the relevant files\n+        self.engine_file_path = 'scrapy/utils/engine.py'\n+        self.debug_file_path = 'scrapy/extensions/debug.py'\n+        self.telnet_file_path = 'scrapy/extensions/telnet.py'\n+        self.memusage_file_path = 'scrapy/extensions/memusage.py'\n+        self.docs_file_path = 'docs/topics/extensions.rst'\n+        self.crawl_test_file_path = 'tests/test_crawl.py'\n+\n+        # Check if the engine.py file exists\n+        self.assertTrue(os.path.exists(self.engine_file_path), f\"{self.engine_file_path} does not exist\")\n+\n+        # Check if the debug.py file exists\n+        self.assertTrue(os.path.exists(self.debug_file_path), f\"{self.debug_file_path} does not exist\")\n+\n+        # Check if the telnet.py file exists\n+        self.assertTrue(os.path.exists(self.telnet_file_path), f\"{self.telnet_file_path} does not exist\")\n+\n+        # Check if the memusage.py file exists\n+        self.assertTrue(os.path.exists(self.memusage_file_path), f\"{self.memusage_file_path} does not exist\")\n+\n+        # Check if the extensions.rst file exists\n+        self.assertTrue(os.path.exists(self.docs_file_path), f\"{self.docs_file_path} does not exist\")\n+\n+        # Check if the test_crawl.py file exists\n+        self.assertTrue(os.path.exists(self.crawl_test_file_path), f\"{self.crawl_test_file_path} does not exist\")\n+\n+    def test_get_engine_status_function_exists(self):\n+        with open(self.engine_file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+        function_found = any(\n+            isinstance(node, ast.FunctionDef) and node.name == '_get_engine_status'\n+            for node in ast.walk(tree)\n+        )\n+        self.assertTrue(function_found, \"Function '_get_engine_status' not found in engine.py\")\n+\n+    def test_format_engine_status_function_exists(self):\n+        with open(self.engine_file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+        function_found = any(\n+            isinstance(node, ast.FunctionDef) and node.name == '_format_engine_status'\n+            for node in ast.walk(tree)\n+        )\n+        self.assertTrue(function_found, \"Function '_format_engine_status' not found in engine.py\")\n+\n+    def test_print_engine_status_function_exists(self):\n+        with open(self.engine_file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+        function_found = any(\n+            isinstance(node, ast.FunctionDef) and node.name == '_print_engine_status'\n+            for node in ast.walk(tree)\n+        )\n+        self.assertTrue(function_found, \"Function '_print_engine_status' not found in engine.py\")\n+\n+    def test_debug_imports_format_engine_status(self):\n+        with open(self.debug_file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+        import_found = any(\n+            isinstance(node, ast.ImportFrom) and node.module == 'scrapy.utils.engine' and\n+            any(alias.name == '_format_engine_status' for alias in node.names)\n+            for node in ast.walk(tree)\n+        )\n+        self.assertTrue(import_found, \"Import 'from scrapy.utils.engine import _format_engine_status' not found in debug.py\")\n+\n+    def test_telnet_imports_print_engine_status(self):\n+        with open(self.telnet_file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+        import_found = any(\n+            isinstance(node, ast.ImportFrom) and node.module == 'scrapy.utils.engine' and\n+            any(alias.name == '_print_engine_status' for alias in node.names)\n+            for node in ast.walk(tree)\n+        )\n+        self.assertTrue(import_found, \"Import 'from scrapy.utils.engine import _print_engine_status' not found in telnet.py\")\n+\n+    def test_memusage_imports_get_engine_status(self):\n+        with open(self.memusage_file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+        import_found = any(\n+            isinstance(node, ast.ImportFrom) and node.module == 'scrapy.utils.engine' and\n+            any(alias.name == '_get_engine_status' for alias in node.names)\n+            for node in ast.walk(tree)\n+        )\n+        self.assertTrue(import_found, \"Import 'from scrapy.utils.engine import _get_engine_status' not found in memusage.py\")\n+\n+    def test_docs_references_get_engine_status(self):\n+        # Check if the docs file contains the specific phrase\n+        with open(self.docs_file_path, 'r') as file:\n+            content = file.read()\n+        self.assertIn('(using ``scrapy.utils.engine._get_engine_status()``)', content,\n+                      \"Reference to 'scrapy.utils.engine._get_engine_status' not found in extensions.rst\")\n+\n+    def test_crawl_test_file_imports_and_usage(self):\n+        with open(self.crawl_test_file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        imports_found = {\n+            '_get_engine_status': False,\n+            '_format_engine_status': False,\n+        }\n+\n+        usage_found = {\n+            '_get_engine_status': False,\n+            '_format_engine_status': False,\n+        }\n+\n+        # Walk through the AST tree\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ClassDef) and node.name == 'CrawlTestCase':\n+                # Inside the CrawlTestCase class, look for functions\n+                for class_node in node.body:\n+                    if isinstance(class_node, ast.FunctionDef):\n+                        # Check for imports within functions\n+                        for func_node in class_node.body:\n+                            if isinstance(func_node, ast.ImportFrom) and func_node.module == 'scrapy.utils.engine':\n+                                for alias in func_node.names:\n+                                    if alias.name == '_get_engine_status':\n+                                        imports_found['_get_engine_status'] = True\n+                                    if alias.name == '_format_engine_status':\n+                                        imports_found['_format_engine_status'] = True\n+                        # Check for calls to functions inside this function\n+                        for func_node in class_node.body:\n+                            if isinstance(func_node, ast.FunctionDef):\n+                                # Look for calls to other functions within the nested function\n+                                for nested_func_node in ast.walk(func_node):\n+                                    if isinstance(nested_func_node, ast.Call):\n+                                        # Check if it's a direct call\n+                                        if isinstance(nested_func_node.func, ast.Name):\n+                                            if nested_func_node.func.id == '_get_engine_status':\n+                                                usage_found['_get_engine_status'] = True\n+                                            if nested_func_node.func.id == '_format_engine_status':\n+                                                usage_found['_format_engine_status'] = True\n+                                        # Check if it's a method call (e.g., object._get_engine_status())\n+                                        elif isinstance(nested_func_node.func, ast.Attribute):\n+                                            if nested_func_node.func.attr == '_get_engine_status':\n+                                                usage_found['_get_engine_status'] = True\n+                                            if nested_func_node.func.attr == '_format_engine_status':\n+                                                usage_found['_format_engine_status'] = True\n+\n+        self.assertTrue(imports_found['_get_engine_status'], \"Import 'from scrapy.utils.engine import _get_engine_status' not found in CrawlTestCase class in test_crawl.py\")\n+        self.assertTrue(imports_found['_format_engine_status'], \"Import 'from scrapy.utils.engine import _format_engine_status' not found in CrawlTestCase class in test_crawl.py\")\n+        self.assertTrue(usage_found['_get_engine_status'], \"'_get_engine_status' is not used in CrawlTestCase class in test_crawl.py\")\n+        self.assertTrue(usage_found['_format_engine_status'], \"'_format_engine_status' is not used in CrawlTestCase class in test_crawl.py\")\n+\n+if __name__ == '__main__':\n+    unittest.main()",
    "problem_statement": "For all the engine_status functions within scrapy/utils/engine.py, can you start them with an underscore to indicate to only use them in scrapy. Update all the references in the repo with these new function names.",
    "hints_text": "",
    "created_at": "2025-11-03 22:46:32+00:00",
    "language": "Python",
    "Dockerfile": "N/A",
    "test_command": "python3 -m unittest rename-engine-status-test.py",
    "task_category": "Refactoring",
    "data_source": "microsoft/RefactorBench",
    "scenario": "brownfield"
  },
  {
    "repo": "scrapy/scrapy",
    "url": "https://github.com/scrapy/scrapy",
    "instance_id": "not-supported-exception-to-unsupported",
    "base_commit": "not-supported-exception-to-unsupported",
    "patch": "N/A",
    "test_patch": "diff --git a/not-supported-exception-to-unsupported-test.py b/not-supported-exception-to-unsupported-test.py\nnew file mode 100644\nindex 0000000..8ecae04\n--- /dev/null\n+++ b/not-supported-exception-to-unsupported-test.py\n@@ -0,0 +1,170 @@\n+import unittest\n+import os\n+import ast\n+\n+class TestScrapyMigration(unittest.TestCase):\n+\n+    def test_not_supported_not_imported_in_downloader_init(self):\n+        file_path = 'scrapy/core/downloader/handlers/__init__.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        not_supported_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom):\n+                if any(alias.name == 'NotSupported' for alias in node.names):\n+                    not_supported_found = True\n+                    break\n+\n+        self.assertFalse(not_supported_found, f\"Import 'NotSupported' found in {file_path}\")\n+\n+    def test_not_supported_not_imported_in_http_response_init(self):\n+        file_path = 'scrapy/http/response/__init__.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        not_supported_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom):\n+                if any(alias.name == 'NotSupported' for alias in node.names):\n+                    not_supported_found = True\n+                    break\n+\n+        self.assertFalse(not_supported_found, f\"Import 'NotSupported' found in {file_path}\")\n+\n+    def test_not_supported_not_imported_in_feed_spiders(self):\n+        file_path = 'scrapy/spiders/feed.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        not_supported_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom):\n+                if any(alias.name == 'NotSupported' for alias in node.names):\n+                    not_supported_found = True\n+                    break\n+\n+        self.assertFalse(not_supported_found, f\"Import 'NotSupported' found in {file_path}\")\n+\n+    def test_not_supported_not_imported_in_test_http_response(self):\n+        file_path = 'tests/test_http_response.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        not_supported_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom):\n+                if any(alias.name == 'NotSupported' for alias in node.names):\n+                    not_supported_found = True\n+                    break\n+\n+        self.assertFalse(not_supported_found, f\"Import 'NotSupported' found in {file_path}\")\n+\n+    def test_unsupported_class_defined_in_exceptions(self):\n+        file_path = 'scrapy/exceptions.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        class_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ClassDef) and node.name == 'Unsupported':\n+                # Check if Unsupported inherits from Exception\n+                if any(isinstance(base, ast.Name) and base.id == 'Exception' for base in node.bases):\n+                    class_found = True\n+                    break\n+\n+        self.assertTrue(class_found, \"Class 'Unsupported(Exception)' not found in exceptions.py\")\n+\n+    def test_not_supported_replaced_with_unsupported_in_exceptions_rst(self):\n+        file_path = 'docs/topics/exceptions.rst'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            content = file.read()\n+\n+        not_supported_present = 'NotSupported' in content\n+        unsupported_present = 'Unsupported' in content\n+\n+        self.assertFalse(not_supported_present, \"The term 'NotSupported' is still present in exceptions.rst\")\n+        self.assertTrue(unsupported_present, \"The term 'Unsupported' is not present in exceptions.rst\")\n+\n+    def test_unsupported_exception_used_in_downloader_init(self):\n+        file_path = 'scrapy/core/downloader/handlers/__init__.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        unsupported_used = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.Raise) and isinstance(node.exc, ast.Call):\n+                if isinstance(node.exc.func, ast.Name) and node.exc.func.id == 'Unsupported':\n+                    unsupported_used = True\n+                    break\n+\n+        self.assertTrue(unsupported_used, f\"Unsupported exception is not used in {file_path}\")\n+\n+    def test_unsupported_exception_used_in_http_response_init(self):\n+        file_path = 'scrapy/http/response/__init__.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        unsupported_used = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.Raise) and isinstance(node.exc, ast.Call):\n+                if isinstance(node.exc.func, ast.Name) and node.exc.func.id == 'Unsupported':\n+                    unsupported_used = True\n+                    break\n+\n+        self.assertTrue(unsupported_used, f\"Unsupported exception is not used in {file_path}\")\n+\n+    def test_unsupported_exception_used_in_feed_spiders(self):\n+        file_path = 'scrapy/spiders/feed.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        unsupported_used = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.Raise) and isinstance(node.exc, ast.Call):\n+                if isinstance(node.exc.func, ast.Name) and node.exc.func.id == 'Unsupported':\n+                    unsupported_used = True\n+                    break\n+\n+        self.assertTrue(unsupported_used, f\"Unsupported exception is not used in {file_path}\")\n+\n+    def test_unsupported_exception_used_in_test_http_response(self):\n+        file_path = 'tests/test_http_response.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        unsupported_used = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.Call):\n+                # Check if the call is assertRaisesRegex\n+                if isinstance(node.func, ast.Attribute) and node.func.attr == 'assertRaisesRegex':\n+                    # Check if the first argument is Unsupported\n+                    if isinstance(node.args[0], ast.Name) and node.args[0].id == 'Unsupported':\n+                        unsupported_used = True\n+                        break\n+\n+        self.assertTrue(unsupported_used, \"assertRaisesRegex with Unsupported exception is not used in test_http_response.py\")\n+\n+\n+if __name__ == '__main__':\n+    unittest.main()",
    "problem_statement": "Change the NotSupported exception to Unsupported and update the repository references with the new exception.",
    "hints_text": "",
    "created_at": "2025-11-03 22:46:32+00:00",
    "language": "Python",
    "Dockerfile": "N/A",
    "test_command": "python3 -m unittest not-supported-exception-to-unsupported-test.py",
    "task_category": "Refactoring",
    "data_source": "microsoft/RefactorBench",
    "scenario": "brownfield"
  },
  {
    "repo": "scrapy/scrapy",
    "url": "https://github.com/scrapy/scrapy",
    "instance_id": "new-downloadermiddlewares-utils",
    "base_commit": "new-downloadermiddlewares-utils",
    "patch": "N/A",
    "test_patch": "diff --git a/new-downloadermiddlewares-utils-test.py b/new-downloadermiddlewares-utils-test.py\nnew file mode 100644\nindex 0000000..7735bdf\n--- /dev/null\n+++ b/new-downloadermiddlewares-utils-test.py\n@@ -0,0 +1,118 @@\n+import unittest\n+import os\n+import ast\n+\n+class TestScrapyMigration(unittest.TestCase):\n+\n+    def test_downloadermiddlewares_file_exists(self):\n+        # Path to the file where the functions should be located\n+        file_path = 'scrapy/utils/downloadermiddlewares.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+    def test_get_status_size_function_exists(self):\n+        # Path to the file where the function should be located\n+        file_path = 'scrapy/utils/downloadermiddlewares.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Check if the function is defined in downloadermiddlewares.py\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        function_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.FunctionDef) and node.name == 'get_status_size':\n+                function_found = True\n+                break\n+\n+        self.assertTrue(function_found, \"Function 'get_status_size' not found in downloadermiddlewares.py\")\n+\n+    def test_get_header_size_function_exists(self):\n+        # Path to the file where the function should be located\n+        file_path = 'scrapy/utils/downloadermiddlewares.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Check if the function is defined in downloadermiddlewares.py\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        function_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.FunctionDef) and node.name == 'get_header_size':\n+                function_found = True\n+                break\n+\n+        self.assertTrue(function_found, \"Function 'get_header_size' not found in downloadermiddlewares.py\")\n+\n+    def test_downloadermiddlewares_imports(self):\n+        # Path to the file where the imports should be located\n+        file_path = 'scrapy/utils/downloadermiddlewares.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Parse the file and check for imports\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        required_imports = {\n+            'typing': {'Dict', 'List', 'Tuple', 'Union'},\n+            'twisted.web.http': set(),\n+            'scrapy.utils.python': {'to_bytes'}\n+        }\n+\n+        imports_found = {\n+            'typing': set(),\n+            'twisted.web.http': set(),\n+            'scrapy.utils.python': set()\n+        }\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom):\n+                if node.module == 'typing':\n+                    for alias in node.names:\n+                        if alias.name in required_imports['typing']:\n+                            imports_found['typing'].add(alias.name)\n+                elif node.module == 'twisted.web.http':\n+                    imports_found['twisted.web.http'] = set()\n+                elif node.module == 'scrapy.utils.python':\n+                    for alias in node.names:\n+                        if alias.name == 'to_bytes':\n+                            imports_found['scrapy.utils.python'].add(alias.name)\n+\n+        # Check that all required imports were found\n+        for module, names in required_imports.items():\n+            if names:\n+                self.assertTrue(names.issubset(imports_found[module]), f\"Missing imports from '{module}': {names - imports_found[module]}\")\n+            else:\n+                self.assertTrue(imports_found[module] == names, f\"Missing imports from '{module}'\")\n+\n+    def test_stats_imports_get_size_functions(self):\n+        # Path to the stats file where the import should be located\n+        file_path = 'scrapy/downloadermiddlewares/stats.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Parse the file and check for the specific import\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        import_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom):\n+                if node.module == 'scrapy.utils.downloadermiddlewares' and \\\n+                   any(alias.name == 'get_header_size' for alias in node.names) and \\\n+                   any(alias.name == 'get_status_size' for alias in node.names):\n+                    import_found = True\n+                    break\n+\n+        self.assertTrue(import_found, \"Import 'from scrapy.utils.downloadermiddlewares import get_header_size, get_status_size' not found in stats.py\")\n+\n+if __name__ == '__main__':\n+    unittest.main()",
    "problem_statement": "Create a new utils file called downloadermiddlewares.py and move the functions outside the class in stats.py in downloadermiddlewares to it and import them correctly.",
    "hints_text": "",
    "created_at": "2025-11-03 22:46:32+00:00",
    "language": "Python",
    "Dockerfile": "N/A",
    "test_command": "python3 -m unittest new-downloadermiddlewares-utils-test.py",
    "task_category": "Refactoring",
    "data_source": "microsoft/RefactorBench",
    "scenario": "brownfield"
  },
  {
    "repo": "scrapy/scrapy",
    "url": "https://github.com/scrapy/scrapy",
    "instance_id": "new-verify-reactor-class",
    "base_commit": "new-verify-reactor-class",
    "patch": "N/A",
    "test_patch": "diff --git a/new-verify-reactor-class-test.py b/new-verify-reactor-class-test.py\nnew file mode 100644\nindex 0000000..1abb16c\n--- /dev/null\n+++ b/new-verify-reactor-class-test.py\n@@ -0,0 +1,281 @@\n+import unittest\n+import os\n+import ast\n+\n+class TestVerifyReactorMigration(unittest.TestCase):\n+\n+    def test_verify_reactor_class_exists(self):\n+        # Path to the file where the class should be located\n+        file_path = 'scrapy/utils/reactor.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Check if the class VerifyReactor is defined in reactor.py\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        class_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ClassDef) and node.name == 'VerifyReactor':\n+                class_found = True\n+                break\n+\n+        self.assertTrue(class_found, \"Class 'VerifyReactor' not found in reactor.py\")\n+\n+    def test_verify_reactor_methods_exist(self):\n+        # Path to the file where the class should be located\n+        file_path = 'scrapy/utils/reactor.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Check if the methods are defined in the VerifyReactor class\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        methods_found = {'verify_installed_reactor': False,\n+                         'verify_installed_asyncio_event_loop': False,\n+                         'is_asyncio_reactor_installed': False}\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ClassDef) and node.name == 'VerifyReactor':\n+                for class_node in node.body:\n+                    if isinstance(class_node, ast.FunctionDef) and class_node.name in methods_found:\n+                        methods_found[class_node.name] = True\n+\n+        for method, found in methods_found.items():\n+            self.assertTrue(found, f\"Method '{method}' not found in VerifyReactor class\")\n+\n+    def test_defer_imports_verify_reactor(self):\n+        # Path to the defer file where the imports should be located\n+        defer_file_path = 'scrapy/utils/defer.py'\n+\n+        # Check if the defer file exists\n+        self.assertTrue(os.path.exists(defer_file_path), f\"{defer_file_path} does not exist\")\n+\n+        # Check if the import statement is correct\n+        with open(defer_file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        imports_found = {\n+            '_get_asyncio_event_loop': False,\n+            'VerifyReactor': False\n+        }\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom):\n+                if node.module == 'scrapy.utils.reactor':\n+                    for alias in node.names:\n+                        if alias.name in imports_found:\n+                            imports_found[alias.name] = True\n+\n+        for imp, found in imports_found.items():\n+            self.assertTrue(found, f\"Import '{imp}' from 'scrapy.utils.reactor' not found in defer.py\")\n+\n+    def test_crawler_imports_verify_reactor(self):\n+        # Path to the crawler file where the imports should be located\n+        crawler_file_path = 'scrapy/crawler.py'\n+\n+        # Check if the crawler file exists\n+        self.assertTrue(os.path.exists(crawler_file_path), f\"{crawler_file_path} does not exist\")\n+\n+        # Check if the import statement is correct\n+        with open(crawler_file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        imports_found = {\n+            'install_reactor': False,\n+            'VerifyReactor': False\n+        }\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom):\n+                if node.module == 'scrapy.utils.reactor':\n+                    for alias in node.names:\n+                        if alias.name in imports_found:\n+                            imports_found[alias.name] = True\n+\n+        for imp, found in imports_found.items():\n+            self.assertTrue(found, f\"Import '{imp}' from 'scrapy.utils.reactor' not found in crawler.py\")\n+\n+    def test_asyncio_docs_mention_verify_reactor(self):\n+        # Path to the docs file where the statement should be located\n+        docs_file_path = 'docs/topics/asyncio.rst'\n+\n+        # Check if the docs file exists\n+        self.assertTrue(os.path.exists(docs_file_path), f\"{docs_file_path} does not exist\")\n+\n+        # Check if the specific line is present in the file\n+        with open(docs_file_path, 'r') as file:\n+            content = file.read()\n+\n+        self.assertIn(\n+            \"if not VerifyReactor.is_asyncio_reactor_installed():\",\n+            content,\n+            \"Line 'if not VerifyReactor.is_asyncio_reactor_installed():' not found in asyncio.rst\"\n+        )\n+\n+    def test_utils_asyncio_imports_verify_reactor(self):\n+        # Path to the test_utils_asyncio file where the imports should be located\n+        test_utils_asyncio_file_path = 'tests/test_utils_asyncio.py'\n+\n+        # Check if the test_utils_asyncio file exists\n+        self.assertTrue(os.path.exists(test_utils_asyncio_file_path), f\"{test_utils_asyncio_file_path} does not exist\")\n+\n+        # Check if the import statement is correct\n+        with open(test_utils_asyncio_file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        imports_found = {\n+            'install_reactor': False,\n+            'VerifyReactor': False,\n+            'set_asyncio_event_loop': False\n+        }\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom):\n+                if node.module == 'scrapy.utils.reactor':\n+                    for alias in node.names:\n+                        if alias.name in imports_found:\n+                            imports_found[alias.name] = True\n+\n+        for imp, found in imports_found.items():\n+            self.assertTrue(found, f\"Import '{imp}' from 'scrapy.utils.reactor' not found in test_utils_asyncio.py\")\n+\n+    def test_shell_imports_verify_reactor(self):\n+        # Path to the shell file where the imports should be located\n+        shell_file_path = 'scrapy/shell.py'\n+\n+        # Check if the shell file exists\n+        self.assertTrue(os.path.exists(shell_file_path), f\"{shell_file_path} does not exist\")\n+\n+        # Check if the import statement is correct\n+        with open(shell_file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        imports_found = {\n+            'VerifyReactor': False,\n+            'set_asyncio_event_loop': False\n+        }\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom):\n+                if node.module == 'scrapy.utils.reactor':\n+                    for alias in node.names:\n+                        if alias.name in imports_found:\n+                            imports_found[alias.name] = True\n+\n+        for imp, found in imports_found.items():\n+            self.assertTrue(found, f\"Import '{imp}' from 'scrapy.utils.reactor' not found in shell.py\")\n+\n+    def test_crawler_class_has_verify_reactor_logic(self):\n+        # Path to the crawler file where the logic should be located\n+        crawler_file_path = 'scrapy/crawler.py'\n+\n+        # Check if the crawler file exists\n+        self.assertTrue(os.path.exists(crawler_file_path), f\"{crawler_file_path} does not exist\")\n+\n+        # Parse the crawler file to analyze the AST\n+        with open(crawler_file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        class_found = False\n+        method_found = False\n+        logic_found = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ClassDef) and node.name == 'Crawler':\n+                class_found = True\n+                for class_node in node.body:\n+                    if isinstance(class_node, ast.FunctionDef):\n+                        method_found = True\n+                        for method_node in ast.walk(class_node):\n+                            if isinstance(method_node, ast.If):\n+                                if isinstance(method_node.test, ast.Name) and method_node.test.id == 'reactor_class':\n+                                    for stmt in method_node.body:\n+                                        if isinstance(stmt, ast.Expr):\n+                                            if isinstance(stmt.value, ast.Call):\n+                                                if isinstance(stmt.value.func, ast.Attribute) and stmt.value.func.attr == 'verify_installed_reactor':\n+                                                    logic_found = True\n+                                                    break\n+                        if logic_found:\n+                            break\n+\n+        self.assertTrue(class_found, \"Class 'Crawler' not found in crawler.py\")\n+        self.assertTrue(method_found, \"No methods found in 'Crawler' class\")\n+        self.assertTrue(logic_found, \"VerifyReactor logic not found in any method of 'Crawler' class\")\n+        \n+    def test_deferred_from_coro_has_verify_reactor_logic(self):\n+        # Path to the defer file where the logic should be located\n+        defer_file_path = 'scrapy/utils/defer.py'\n+\n+        # Check if the defer file exists\n+        self.assertTrue(os.path.exists(defer_file_path), f\"{defer_file_path} does not exist\")\n+\n+        # Parse the defer file to analyze the AST\n+        with open(defer_file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        verify_reactor_prefix_found = True\n+\n+        # Traverse the AST to find occurrences of is_asyncio_reactor_installed\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.Call) and isinstance(node.func, ast.Attribute):\n+                if node.func.attr == 'is_asyncio_reactor_installed':\n+                    # Check if the prefix is VerifyReactor\n+                    if not (isinstance(node.func.value, ast.Name) and node.func.value.id == 'VerifyReactor'):\n+                        verify_reactor_prefix_found = False\n+                        break\n+\n+        self.assertTrue(verify_reactor_prefix_found, \"Found 'is_asyncio_reactor_installed' not prefixed by 'VerifyReactor' in defer.py\")\n+    def test_utils_asyncio_has_verify_reactor_logic(self):\n+        # Path to the test_utils_asyncio file where the logic should be located\n+        test_utils_asyncio_file_path = 'tests/test_utils_asyncio.py'\n+\n+        # Check if the test_utils_asyncio file exists\n+        self.assertTrue(os.path.exists(test_utils_asyncio_file_path), f\"{test_utils_asyncio_file_path} does not exist\")\n+\n+        # Parse the test_utils_asyncio file to analyze the AST\n+        with open(test_utils_asyncio_file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        verify_reactor_prefix_found = True\n+\n+        # Traverse the AST to find occurrences of is_asyncio_reactor_installed\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.Call) and isinstance(node.func, ast.Attribute):\n+                if node.func.attr == 'is_asyncio_reactor_installed':\n+                    # Check if the prefix is VerifyReactor\n+                    if not (isinstance(node.func.value, ast.Name) and node.func.value.id == 'VerifyReactor'):\n+                        verify_reactor_prefix_found = False\n+                        break\n+\n+        self.assertTrue(verify_reactor_prefix_found, \"Found 'is_asyncio_reactor_installed' not prefixed by 'VerifyReactor' in test_utils_asyncio.py\")\n+    \n+    def test_shell_has_verify_reactor_logic(self):\n+        # Path to the shell file where the logic should be located\n+        shell_file_path = 'scrapy/shell.py'\n+\n+        # Check if the shell file exists\n+        self.assertTrue(os.path.exists(shell_file_path), f\"{shell_file_path} does not exist\")\n+\n+        # Parse the shell file to analyze the AST\n+        with open(shell_file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        verify_reactor_prefix_found = True\n+\n+        # Traverse the AST to find occurrences of is_asyncio_reactor_installed\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.Call) and isinstance(node.func, ast.Attribute):\n+                if node.func.attr == 'is_asyncio_reactor_installed':\n+                    # Check if the prefix is VerifyReactor\n+                    if not (isinstance(node.func.value, ast.Name) and node.func.value.id == 'VerifyReactor'):\n+                        verify_reactor_prefix_found = False\n+                        break\n+\n+        self.assertTrue(verify_reactor_prefix_found, \"Found 'is_asyncio_reactor_installed' not prefixed by 'VerifyReactor' in shell.py\")\n+\n+if __name__ == '__main__':\n+    unittest.main()",
    "problem_statement": "Create a new class called VerifyReactor for the verify_installed and is_asyncio_reactor_installed functions within the reactor.py in utils and update the calls of the functions and docs in the repository accordingly.",
    "hints_text": "",
    "created_at": "2025-11-03 22:46:32+00:00",
    "language": "Python",
    "Dockerfile": "N/A",
    "test_command": "python3 -m unittest new-verify-reactor-class-test.py",
    "task_category": "Refactoring",
    "data_source": "microsoft/RefactorBench",
    "scenario": "brownfield"
  },
  {
    "repo": "scrapy/scrapy",
    "url": "https://github.com/scrapy/scrapy",
    "instance_id": "new-spider-utils-in-spiders",
    "base_commit": "new-spider-utils-in-spiders",
    "patch": "N/A",
    "test_patch": "diff --git a/new-spider-utils-in-spiders-test.py b/new-spider-utils-in-spiders-test.py\nnew file mode 100644\nindex 0000000..23bdbd7\n--- /dev/null\n+++ b/new-spider-utils-in-spiders-test.py\n@@ -0,0 +1,122 @@\n+import unittest\n+import os\n+import ast\n+\n+class TestScrapyMigration(unittest.TestCase):\n+\n+    def setUp(self):\n+        # Paths to the relevant files\n+        self.spider_utils_path = 'scrapy/spiders/spider_utils.py'\n+        self.sitemap_path = 'scrapy/spiders/sitemap.py'\n+        self.crawl_path = 'scrapy/spiders/crawl.py'\n+\n+        # Check if the spider_utils file exists\n+        self.assertTrue(os.path.exists(self.spider_utils_path), f\"{self.spider_utils_path} does not exist\")\n+\n+        # Parse the spider_utils file into an AST tree\n+        with open(self.spider_utils_path, 'r') as file:\n+            self.spider_utils_tree = ast.parse(file.read())\n+\n+        # Check if the sitemap file exists\n+        self.assertTrue(os.path.exists(self.sitemap_path), f\"{self.sitemap_path} does not exist\")\n+\n+        # Parse the sitemap file into an AST tree\n+        with open(self.sitemap_path, 'r') as file:\n+            self.sitemap_tree = ast.parse(file.read())\n+\n+        # Check if the crawl file exists\n+        self.assertTrue(os.path.exists(self.crawl_path), f\"{self.crawl_path} does not exist\")\n+\n+        # Parse the crawl file into an AST tree\n+        with open(self.crawl_path, 'r') as file:\n+            self.crawl_tree = ast.parse(file.read())\n+\n+    def _function_exists(self, tree, function_name):\n+        \"\"\"Helper function to check if a function exists in the AST.\"\"\"\n+        return any(\n+            isinstance(node, ast.FunctionDef) and node.name == function_name\n+            for node in ast.walk(tree)\n+        )\n+\n+    def _import_exists(self, tree, module_name, import_names):\n+        \"\"\"Helper function to check if a specific import statement exists.\"\"\"\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom) and node.module == module_name:\n+                imported_names = [alias.name for alias in node.names]\n+                if all(name in imported_names for name in import_names):\n+                    return True\n+        return False\n+\n+    def test_identity_function_exists(self):\n+        self.assertTrue(\n+            self._function_exists(self.spider_utils_tree, '_identity'),\n+            \"Function '_identity' not found in spider_utils.py\"\n+        )\n+\n+    def test_get_method_function_exists(self):\n+        self.assertTrue(\n+            self._function_exists(self.spider_utils_tree, '_get_method'),\n+            \"Function '_get_method' not found in spider_utils.py\"\n+        )\n+\n+    def test_regex_function_exists(self):\n+        self.assertTrue(\n+            self._function_exists(self.spider_utils_tree, 'regex'),\n+            \"Function 'regex' not found in spider_utils.py\"\n+        )\n+\n+    def test_iterloc_function_exists(self):\n+        self.assertTrue(\n+            self._function_exists(self.spider_utils_tree, 'iterloc'),\n+            \"Function 'iterloc' not found in spider_utils.py\"\n+        )\n+\n+    def test_required_imports_exist(self):\n+        required_imports = [\n+            ('import re', []),\n+            ('typing', ['Any', 'Dict', 'Iterable', 'Callable', 'Optional', 'TypeVar', 'Union']),\n+            ('scrapy.http', ['Request', 'Response']),\n+            ('scrapy.spiders', ['Spider'])\n+        ]\n+\n+        for module, imports in required_imports:\n+            if module == 'import re':  # Handle standard imports separately\n+                self.assertTrue(\n+                    any(isinstance(node, ast.Import) and any(alias.name == 're' for alias in node.names)\n+                        for node in ast.walk(self.spider_utils_tree)),\n+                    \"Required import 'import re' not found in spider_utils.py\"\n+                )\n+            else:\n+                self.assertTrue(\n+                    self._import_exists(self.spider_utils_tree, module, imports),\n+                    f\"Required import 'from {module} import {', '.join(imports)}' not found in spider_utils.py\"\n+                )\n+\n+    def test_t_alias_exists(self):\n+        alias_found = any(\n+            isinstance(node, ast.Assign) and\n+            any(target.id == '_T' for target in node.targets)\n+            for node in ast.walk(self.spider_utils_tree)\n+        )\n+        self.assertTrue(alias_found, \"Alias '_T' not found in spider_utils.py\")\n+\n+    def test_sitemap_imports_spider_utils(self):\n+        import_found = self._import_exists(\n+            self.sitemap_tree, 'scrapy.spiders.spider_utils', ['regex', 'iterloc']\n+        )\n+        self.assertTrue(\n+            import_found,\n+            \"Import 'from scrapy.spiders.spider_utils import regex, iterloc' not found in sitemap.py\"\n+        )\n+\n+    def test_crawl_imports_spider_utils(self):\n+        import_found = self._import_exists(\n+            self.crawl_tree, 'scrapy.spiders.spider_utils', ['_get_method', '_identity', '_identity_process_request']\n+        )\n+        self.assertTrue(\n+            import_found,\n+            \"Import 'from scrapy.spiders.spider_utils import _get_method, _identity, _identity_process_request' not found in crawl.py\"\n+        )\n+\n+if __name__ == '__main__':\n+    unittest.main()",
    "problem_statement": "Create a new file called spider_utils.py in scrapy/spiders and take all functions outside of a class in all the files in scrapy/spider and put them in it. Update all the imports accordingly, and don't change variable names",
    "hints_text": "",
    "created_at": "2025-11-03 22:46:32+00:00",
    "language": "Python",
    "Dockerfile": "N/A",
    "test_command": "python3 -m unittest new-spider-utils-in-spiders-test.py",
    "task_category": "Refactoring",
    "data_source": "microsoft/RefactorBench",
    "scenario": "brownfield"
  },
  {
    "repo": "scrapy/scrapy",
    "url": "https://github.com/scrapy/scrapy",
    "instance_id": "sitemap-url-to-url",
    "base_commit": "sitemap-url-to-url",
    "patch": "N/A",
    "test_patch": "diff --git a/sitemap-url-to-url-test.py b/sitemap-url-to-url-test.py\nnew file mode 100644\nindex 0000000..1fb0f5b\n--- /dev/null\n+++ b/sitemap-url-to-url-test.py\n@@ -0,0 +1,69 @@\n+import unittest\n+import os\n+import ast\n+\n+class TestScrapyMigration(unittest.TestCase):\n+\n+    def test_sitemap_urls_from_robots_moved(self):\n+        # Path to the file where the function should be moved\n+        file_path = 'scrapy/utils/url.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Check if the function is defined in url.py\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        function_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.FunctionDef) and node.name == 'sitemap_urls_from_robots':\n+                function_found = True\n+                break\n+\n+        self.assertTrue(function_found, \"Function 'sitemap_urls_from_robots' not found in url.py\")\n+\n+    def test_tests_py_imports_updated(self):\n+        # Path to the test file\n+        tests_file_path = 'tests/test_utils_sitemap.py' \n+\n+        # Check if the test file exists\n+        self.assertTrue(os.path.exists(tests_file_path), f\"Test file {tests_file_path} does not exist\")\n+\n+        # Check if the import statement is correct\n+        with open(tests_file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        import_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom):\n+                if node.module == 'scrapy.utils.url' and \\\n+                   any(alias.name == 'sitemap_urls_from_robots' for alias in node.names):\n+                    import_found = True\n+                    break\n+\n+        self.assertTrue(import_found, \"Import 'from scrapy.utils.url import sitemap_urls_from_robots' not found in test_utils_sitemap.py\")\n+\n+    def test_spider_import_updated(self):\n+        # Path to the spider file\n+        spider_file_path = 'scrapy/spiders/sitemap.py'\n+\n+        # Check if the spider file exists\n+        self.assertTrue(os.path.exists(spider_file_path), f\"Spider file {spider_file_path} does not exist\")\n+\n+        # Check if the correct import statement is present\n+        with open(spider_file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        import_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom):\n+                if node.module == 'scrapy.utils.url' and \\\n+                   any(alias.name == 'sitemap_urls_from_robots' for alias in node.names):\n+                    import_found = True\n+                    break\n+\n+        self.assertTrue(import_found, \"Import 'from scrapy.utils.url import sitemap_urls_from_robots' not found in sitemap.py\")\n+\n+if __name__ == '__main__':\n+    unittest.main()",
    "problem_statement": "move sitemap_urls_from_robots.py in sitemap.py to url.py and update the repository references accordingly. Keep the tests in the same place just change the imports.",
    "hints_text": "",
    "created_at": "2025-11-03 22:46:32+00:00",
    "language": "Python",
    "Dockerfile": "N/A",
    "test_command": "python3 -m unittest sitemap-url-to-url-test.py",
    "task_category": "Refactoring",
    "data_source": "microsoft/RefactorBench",
    "scenario": "brownfield"
  },
  {
    "repo": "scrapy/scrapy",
    "url": "https://github.com/scrapy/scrapy",
    "instance_id": "add-log-parameter-job-dir",
    "base_commit": "add-log-parameter-job-dir",
    "patch": "N/A",
    "test_patch": "diff --git a/add-log-parameter-job-dir-test.py b/add-log-parameter-job-dir-test.py\nnew file mode 100644\nindex 0000000..ee0aed9\n--- /dev/null\n+++ b/add-log-parameter-job-dir-test.py\n@@ -0,0 +1,131 @@\n+import unittest\n+import os\n+import ast\n+\n+class TestScrapyMigration(unittest.TestCase):\n+\n+    def test_job_dir_has_log_parameter(self):\n+        # Path to the file where the job_dir function is defined\n+        file_path = 'scrapy/utils/job.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Check if the job_dir function has a log parameter\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        job_dir_function = None\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.FunctionDef) and node.name == 'job_dir':\n+                job_dir_function = node\n+                break\n+\n+        self.assertIsNotNone(job_dir_function, \"Function 'job_dir' not found in job.py\")\n+\n+        log_param_found = False\n+        for arg in job_dir_function.args.args:\n+            if arg.arg == 'log':\n+                log_param_found = True\n+                break\n+\n+        self.assertTrue(log_param_found, \"Parameter 'log' not found in 'job_dir' function\")\n+\n+    def test_logging_imported_in_job(self):\n+        # Path to the file where logging should be imported\n+        file_path = 'scrapy/utils/job.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Check if logging is imported in job.py\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        logging_import_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.Import):\n+                for alias in node.names:\n+                    if alias.name == 'logging':\n+                        logging_import_found = True\n+                        break\n+\n+        self.assertTrue(logging_import_found, \"Import 'import logging' not found in job.py\")\n+\n+    def test_job_dir_call_in_dupefilters_has_log_false(self):\n+        # Path to the file where job_dir is called\n+        file_path = 'scrapy/dupefilters.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Check if job_dir is called with log=False in dupefilters.py\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        job_dir_call_found = False\n+        log_param_found = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.Call) and isinstance(node.func, ast.Name) and node.func.id == 'job_dir':\n+                job_dir_call_found = True\n+                for kw in node.keywords:\n+                    if kw.arg == 'log' and isinstance(kw.value, ast.Constant) and kw.value.value is False:\n+                        log_param_found = True\n+                        break\n+\n+        self.assertTrue(job_dir_call_found, \"Call to 'job_dir' not found in dupefilters.py\")\n+        self.assertTrue(log_param_found, \"Call to 'job_dir' in dupefilters.py does not have 'log=False'\")\n+\n+    def test_job_dir_call_in_spiderstate_has_log_false(self):\n+        # Path to the file where job_dir is called\n+        file_path = 'scrapy/extensions/spiderstate.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Check if job_dir is called with log=False in spiderstate.py\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        job_dir_call_found = False\n+        log_param_found = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.Call) and isinstance(node.func, ast.Name) and node.func.id == 'job_dir':\n+                job_dir_call_found = True\n+                for kw in node.keywords:\n+                    if kw.arg == 'log' and isinstance(kw.value, ast.Constant) and kw.value.value is False:\n+                        log_param_found = True\n+                        break\n+\n+        self.assertTrue(job_dir_call_found, \"Call to 'job_dir' not found in spiderstate.py\")\n+        self.assertTrue(log_param_found, \"Call to 'job_dir' in spiderstate.py does not have 'log=False'\")\n+\n+    def test_job_dir_call_in_scheduler_has_log_false(self):\n+        # Path to the file where job_dir is called\n+        file_path = 'scrapy/core/scheduler.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Check if job_dir is called with log=False in scheduler.py\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        job_dir_call_found = False\n+        log_param_found = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.Call) and isinstance(node.func, ast.Name) and node.func.id == 'job_dir':\n+                job_dir_call_found = True\n+                for kw in node.keywords:\n+                    if kw.arg == 'log' and isinstance(kw.value, ast.Constant) and kw.value.value is False:\n+                        log_param_found = True\n+                        break\n+\n+        self.assertTrue(job_dir_call_found, \"Call to 'job_dir' not found in scheduler.py\")\n+        self.assertTrue(log_param_found, \"Call to 'job_dir' in scheduler.py does not have 'log=False'\")\n+\n+if __name__ == '__main__':\n+    unittest.main()",
    "problem_statement": "Add a boolean log parameter to job_dir with the base as True and update all references in the repo to have log=False.",
    "hints_text": "",
    "created_at": "2025-11-03 22:46:32+00:00",
    "language": "Python",
    "Dockerfile": "N/A",
    "test_command": "python3 -m unittest add-log-parameter-job-dir-test.py",
    "task_category": "Refactoring",
    "data_source": "microsoft/RefactorBench",
    "scenario": "brownfield"
  },
  {
    "repo": "scrapy/scrapy",
    "url": "https://github.com/scrapy/scrapy",
    "instance_id": "rename-processtest-testproc",
    "base_commit": "rename-processtest-testproc",
    "patch": "N/A",
    "test_patch": "diff --git a/rename-processtest-testproc-test.py b/rename-processtest-testproc-test.py\nnew file mode 100644\nindex 0000000..58db162\n--- /dev/null\n+++ b/rename-processtest-testproc-test.py\n@@ -0,0 +1,146 @@\n+import unittest\n+import os\n+import ast\n+\n+class TestScrapyMigration(unittest.TestCase):\n+\n+    def test_testproc_class_exists(self):\n+        # Path to the file where the class should be defined\n+        file_path = 'scrapy/utils/testproc.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Check if the TestProc class is defined in testproc.py\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        testproc_class_found = False\n+        processtest_class_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ClassDef):\n+                if node.name == 'TestProc':\n+                    testproc_class_found = True\n+                if node.name == 'ProcessTest':\n+                    processtest_class_found = True\n+\n+        self.assertTrue(testproc_class_found, \"Class 'TestProc' not found in testproc.py\")\n+        self.assertFalse(processtest_class_found, \"Class 'ProcessTest' should not exist in testproc.py\")\n+\n+    def test_testproc_methods_exist(self):\n+        # Path to the file where the TestProc class is defined\n+        file_path = 'scrapy/utils/testproc.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Check if the TestProc class has execute and _process_finished methods\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        testproc_class_node = None\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ClassDef) and node.name == 'TestProc':\n+                testproc_class_node = node\n+                break\n+\n+        self.assertIsNotNone(testproc_class_node, \"Class 'TestProc' not found in testproc.py\")\n+\n+        execute_method_found = False\n+        process_finished_method_found = False\n+        for node in ast.walk(testproc_class_node):\n+            if isinstance(node, ast.FunctionDef):\n+                if node.name == 'execute':\n+                    execute_method_found = True\n+                if node.name == '_process_finished':\n+                    process_finished_method_found = True\n+\n+        self.assertTrue(execute_method_found, \"Method 'execute' not found in TestProc class\")\n+        self.assertTrue(process_finished_method_found, \"Method '_process_finished' not found in TestProc class\")\n+\n+    def test_testproc_import_in_fetch(self):\n+        # Path to the test file\n+        tests_file_path = 'tests/test_command_fetch.py'\n+\n+        # Check if the test file exists\n+        self.assertTrue(os.path.exists(tests_file_path), f\"Test file {tests_file_path} does not exist\")\n+\n+        # Check if the import statement for TestProc is correct\n+        with open(tests_file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        import_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom):\n+                if node.module == 'scrapy.utils.testproc' and \\\n+                   any(alias.name == 'TestProc' for alias in node.names):\n+                    import_found = True\n+                    break\n+\n+        self.assertTrue(import_found, \"Import 'from scrapy.utils.testproc import TestProc' not found in test_command_fetch.py\")\n+\n+    def test_testproc_import_in_parse(self):\n+        # Path to the test file\n+        tests_file_path = 'tests/test_command_parse.py'\n+\n+        # Check if the test file exists\n+        self.assertTrue(os.path.exists(tests_file_path), f\"Test file {tests_file_path} does not exist\")\n+\n+        # Check if the import statement for TestProc is correct\n+        with open(tests_file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        import_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom):\n+                if node.module == 'scrapy.utils.testproc' and \\\n+                   any(alias.name == 'TestProc' for alias in node.names):\n+                    import_found = True\n+                    break\n+\n+        self.assertTrue(import_found, \"Import 'from scrapy.utils.testproc import TestProc' not found in test_command_parse.py\")\n+\n+    def test_testproc_import_in_shell(self):\n+        # Path to the test file\n+        tests_file_path = 'tests/test_command_shell.py'\n+\n+        # Check if the test file exists\n+        self.assertTrue(os.path.exists(tests_file_path), f\"Test file {tests_file_path} does not exist\")\n+\n+        # Check if the import statement for TestProc is correct\n+        with open(tests_file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        import_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom):\n+                if node.module == 'scrapy.utils.testproc' and \\\n+                   any(alias.name == 'TestProc' for alias in node.names):\n+                    import_found = True\n+                    break\n+\n+        self.assertTrue(import_found, \"Import 'from scrapy.utils.testproc import TestProc' not found in test_command_shell.py\")\n+\n+    def test_testproc_import_in_version(self):\n+        # Path to the test file\n+        tests_file_path = 'tests/test_command_version.py'\n+\n+        # Check if the test file exists\n+        self.assertTrue(os.path.exists(tests_file_path), f\"Test file {tests_file_path} does not exist\")\n+\n+        # Check if the import statement for TestProc is correct\n+        with open(tests_file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        import_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom):\n+                if node.module == 'scrapy.utils.testproc' and \\\n+                   any(alias.name == 'TestProc' for alias in node.names):\n+                    import_found = True\n+                    break\n+\n+        self.assertTrue(import_found, \"Import 'from scrapy.utils.testproc import TestProc' not found in test_command_version.py\")\n+\n+if __name__ == '__main__':\n+    unittest.main()",
    "problem_statement": "Rename the ProcessTest class in scrapy/utils/testproc.py to testproc as that is what the file is named itself. Update all references in the repo accordingly.",
    "hints_text": "",
    "created_at": "2025-11-03 22:46:32+00:00",
    "language": "Python",
    "Dockerfile": "N/A",
    "test_command": "python3 -m unittest rename-processtest-testproc-test.py",
    "task_category": "Refactoring",
    "data_source": "microsoft/RefactorBench",
    "scenario": "brownfield"
  },
  {
    "repo": "scrapy/scrapy",
    "url": "https://github.com/scrapy/scrapy",
    "instance_id": "rename-description-commands",
    "base_commit": "rename-description-commands",
    "patch": "N/A",
    "test_patch": "diff --git a/rename-description-commands-test.py b/rename-description-commands-test.py\nnew file mode 100644\nindex 0000000..d789eff\n--- /dev/null\n+++ b/rename-description-commands-test.py\n@@ -0,0 +1,245 @@\n+import unittest\n+import os\n+import ast\n+\n+class TestScrapyMigration(unittest.TestCase):\n+\n+    def test_scrapy_command_class_exists(self):\n+        # Path to the file where the ScrapyCommand class should be defined\n+        file_path = 'scrapy/commands/__init__.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Check if the class is defined in __init__.py\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        class_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ClassDef) and node.name == 'ScrapyCommand':\n+                class_found = True\n+                break\n+\n+        self.assertTrue(class_found, \"Class 'ScrapyCommand' not found in __init__.py\")\n+\n+    def test_scrapy_command_has_short_description(self):\n+        # Path to the file where the ScrapyCommand class should be defined\n+        file_path = 'scrapy/commands/__init__.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Check if the class and function are defined in __init__.py\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        class_node = None\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ClassDef) and node.name == 'ScrapyCommand':\n+                class_node = node\n+                break\n+\n+        self.assertIsNotNone(class_node, \"Class 'ScrapyCommand' not found in __init__.py\")\n+\n+        # Check if short_description function exists\n+        function_found = False\n+        for node in class_node.body:\n+            if isinstance(node, ast.FunctionDef) and node.name == 'short_description':\n+                function_found = True\n+                break\n+\n+        self.assertTrue(function_found, \"Function 'short_description' not found in ScrapyCommand class\")\n+\n+    def test_scrapy_command_has_long_description(self):\n+        # Path to the file where the ScrapyCommand class should be defined\n+        file_path = 'scrapy/commands/__init__.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Check if the class and function are defined in __init__.py\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        class_node = None\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ClassDef) and node.name == 'ScrapyCommand':\n+                class_node = node\n+                break\n+\n+        self.assertIsNotNone(class_node, \"Class 'ScrapyCommand' not found in __init__.py\")\n+\n+        # Check if long_description function exists\n+        function_found = False\n+        for node in class_node.body:\n+            if isinstance(node, ast.FunctionDef) and node.name == 'long_description':\n+                function_found = True\n+                break\n+\n+        self.assertTrue(function_found, \"Function 'long_description' not found in ScrapyCommand class\")\n+        \n+    def check_command_has_short_description(self, file_path):\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Check if the Command class and short_description function are defined\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        class_node = None\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ClassDef) and node.name == 'Command':\n+                class_node = node\n+                break\n+\n+        self.assertIsNotNone(class_node, f\"Class 'Command' not found in {file_path}\")\n+\n+        function_found = False\n+        for node in class_node.body:\n+            if isinstance(node, ast.FunctionDef) and node.name == 'short_description':\n+                function_found = True\n+                break\n+\n+        self.assertTrue(function_found, f\"Function 'short_description' not found in Command class in {file_path}\")\n+\n+\n+    def test_all_command_files(self):\n+        files_to_check = [\n+            'bench.py', 'check.py', 'crawl.py', 'edit.py',\n+            'fetch.py', 'genspider.py', 'list.py', 'parse.py', 'runspider.py',\n+            'settings.py', 'shell.py', 'startproject.py', 'version.py', 'view.py'\n+        ]\n+\n+        base_path = 'scrapy/commands/'\n+\n+        for file_name in files_to_check:\n+            with self.subTest(file=file_name):\n+                file_path = os.path.join(base_path, file_name)\n+                self.check_command_has_short_description(file_path)\n+                \n+    def check_command_has_long_description(self, file_path):\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Check if the Command class and short_description function are defined\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        class_node = None\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ClassDef) and node.name == 'Command':\n+                class_node = node\n+                break\n+\n+        self.assertIsNotNone(class_node, f\"Class 'Command' not found in {file_path}\")\n+\n+        function_found = False\n+        for node in class_node.body:\n+            if isinstance(node, ast.FunctionDef) and node.name == 'long_description':\n+                function_found = True\n+                break\n+\n+        self.assertTrue(function_found, f\"Function 'long_description' not found in Command class in {file_path}\")\n+\n+\n+    def test_all_long_command_files(self):\n+        files_to_check = [\n+            'edit.py',\n+            'fetch.py', 'runspider.py',\n+            'shell.py',  'view.py'\n+        ]\n+\n+        base_path = 'scrapy/commands/'\n+\n+        for file_name in files_to_check:\n+            with self.subTest(file=file_name):\n+                file_path = os.path.join(base_path, file_name)\n+                self.check_command_has_long_description(file_path)\n+                \n+    def test_view_command_test_methods(self):\n+        # Path to the test file\n+        file_path = 'tests/test_commands.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Parse the test file\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        class_node = None\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ClassDef) and node.name == 'ViewCommandTest':\n+                class_node = node\n+                break\n+\n+        self.assertIsNotNone(class_node, \"Class 'ViewCommandTest' not found in test_commands.py\")\n+\n+        method_node = None\n+        for node in class_node.body:\n+            if isinstance(node, ast.FunctionDef) and node.name == 'test_methods':\n+                method_node = node\n+                break\n+\n+        self.assertIsNotNone(method_node, \"Function 'test_methods' not found in ViewCommandTest class\")\n+\n+        # Check if 'command.short_description' and 'command.long_description' are present\n+        short_desc_found = False\n+        long_desc_found = False\n+\n+        for node in ast.walk(method_node):\n+            if isinstance(node, ast.Attribute):\n+                if isinstance(node.value, ast.Name) and node.value.id == 'command':\n+                    if node.attr == 'short_description':\n+                        short_desc_found = True\n+                    if node.attr == 'long_description':\n+                        long_desc_found = True\n+\n+        self.assertTrue(short_desc_found, \"'command.short_description' not found in test_methods of ViewCommandTest\")\n+        self.assertTrue(long_desc_found, \"'command.long_description' not found in test_methods of ViewCommandTest\")\n+        \n+    def test_cmdline_short_long_description_usage(self):\n+        # Path to the file to check\n+        file_path = 'scrapy/cmdline.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Parse the file\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        short_desc_found = False\n+        long_desc_found = False\n+        invalid_short_desc_found = False\n+        invalid_long_desc_found = False\n+\n+        for node in ast.walk(tree):\n+            # Check for invalid short_desc() or long_desc()\n+            if isinstance(node, ast.Call):\n+                if isinstance(node.func, ast.Name):\n+                    if node.func.id == 'short_desc':\n+                        invalid_short_desc_found = True\n+                    elif node.func.id == 'long_desc':\n+                        invalid_long_desc_found = True\n+\n+            # Check for valid cmdclass.short_description() or cmd.long_description()\n+            if isinstance(node, ast.Attribute):\n+                if isinstance(node.value, ast.Name) and node.value.id in ['cmdclass', 'cmd']:\n+                    if node.attr == 'short_description':\n+                        short_desc_found = True\n+                    elif node.attr == 'long_description':\n+                        long_desc_found = True\n+\n+        # Assert that short_desc() or long_desc() are not found\n+        self.assertFalse(invalid_short_desc_found, \"Found 'short_desc()' in scrapy/cmdline.py which should not be used\")\n+        self.assertFalse(invalid_long_desc_found, \"Found 'long_desc()' in scrapy/cmdline.py which should not be used\")\n+\n+        # Assert that cmdclass.short_description() and cmd.long_description() are found\n+        self.assertTrue(short_desc_found, \"cmdclass.short_description() or cmd.short_description() not found in scrapy/cmdline.py\")\n+        self.assertTrue(long_desc_found, \"cmd.long_description() or cmdclass.long_description() not found in scrapy/cmdline.py\")\n+\n+\n+if __name__ == '__main__':\n+    unittest.main()",
    "problem_statement": "Rename the short_desc and the long_desc for all the scrapy/commands to short_description and long_description and update the repository for those references.",
    "hints_text": "",
    "created_at": "2025-11-03 22:46:32+00:00",
    "language": "Python",
    "Dockerfile": "N/A",
    "test_command": "python3 -m unittest rename-description-commands-test.py",
    "task_category": "Refactoring",
    "data_source": "microsoft/RefactorBench",
    "scenario": "brownfield"
  },
  {
    "repo": "scrapy/scrapy",
    "url": "https://github.com/scrapy/scrapy",
    "instance_id": "add-log-parameter-xmliter",
    "base_commit": "add-log-parameter-xmliter",
    "patch": "N/A",
    "test_patch": "diff --git a/add-log-parameter-xmliter-test.py b/add-log-parameter-xmliter-test.py\nnew file mode 100644\nindex 0000000..201b4ac\n--- /dev/null\n+++ b/add-log-parameter-xmliter-test.py\n@@ -0,0 +1,80 @@\n+import unittest\n+import os\n+import ast\n+\n+class TestScrapyMigration(unittest.TestCase):\n+\n+    def test_xmliter_has_log_parameter(self):\n+        # Path to the file where the xmliter function is defined\n+        file_path = 'scrapy/utils/iterators.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Check if the xmliter function has a log boolean parameter\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        function_found = False\n+        log_param_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.FunctionDef) and node.name == 'xmliter':\n+                function_found = True\n+                for arg in node.args.args:\n+                    if arg.arg == 'log':\n+                        if isinstance(arg.annotation, ast.Name) and arg.annotation.id == 'bool':\n+                            log_param_found = True\n+                            break\n+                break\n+\n+        self.assertTrue(function_found, \"Function 'xmliter' not found in iterators.py\")\n+        self.assertTrue(log_param_found, \"Parameter 'log: bool' not found in 'xmliter' function\")\n+        \n+    def test_tests_py_imports_updated(self):\n+        # Path to the test file\n+        tests_file_path = 'tests/test_utils_iterators.py' \n+\n+        # Check if the test file exists\n+        self.assertTrue(os.path.exists(tests_file_path), f\"Test file {tests_file_path} does not exist\")\n+\n+        # Check if the import statement for xmliter is correct\n+        with open(tests_file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        import_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom):\n+                if node.module == 'scrapy.utils.iterators' and \\\n+                   any(alias.name == 'xmliter' for alias in node.names):\n+                    import_found = True\n+                    break\n+\n+        self.assertTrue(import_found, \"Import 'from scrapy.utils.iterators import xmliter' not found in test_utils_iterators.py\")\n+    \n+    def test_xmliter_calls_have_log_parameter(self):\n+        # Path to the test file where xmliter should be called with log parameter\n+        test_file_path = 'tests/test_utils_iterators.py'\n+\n+        # Check if the test file exists\n+        self.assertTrue(os.path.exists(test_file_path), f\"{test_file_path} does not exist\")\n+\n+        # Check if all xmliter calls have log=False parameter\n+        with open(test_file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        xmliter_calls = [\n+            node for node in ast.walk(tree)\n+            if isinstance(node, ast.Call) and isinstance(node.func, ast.Name) and node.func.id == 'xmliter'\n+        ]\n+\n+        for call in xmliter_calls:\n+            log_param_found = False\n+            for kw in call.keywords:\n+                if kw.arg == 'log' and isinstance(kw.value, ast.Constant) and kw.value.value is False:\n+                    log_param_found = True\n+                    break\n+            self.assertTrue(log_param_found, f\"xmliter call at line {call.lineno} does not have 'log=False'\")\n+\n+\n+if __name__ == '__main__':\n+    unittest.main()",
    "problem_statement": "Add a log boolean parameter to the xmliter function in scrapy/utils/iterators.py and make the base case true. For all testing calls make log=False but otherwise leave it as true.",
    "hints_text": "",
    "created_at": "2025-11-03 22:46:32+00:00",
    "language": "Python",
    "Dockerfile": "N/A",
    "test_command": "python3 -m unittest add-log-parameter-xmliter-test.py",
    "task_category": "Refactoring",
    "data_source": "microsoft/RefactorBench",
    "scenario": "brownfield"
  },
  {
    "repo": "ansible/ansible",
    "url": "https://github.com/ansible/ansible",
    "instance_id": "new-utils-class-connection",
    "base_commit": "new-utils-class-connection",
    "patch": "N/A",
    "test_patch": "diff --git a/new-utils-class-connection-test.py b/new-utils-class-connection-test.py\nnew file mode 100644\nindex 0000000..cd8809d\n--- /dev/null\n+++ b/new-utils-class-connection-test.py\n@@ -0,0 +1,203 @@\n+import unittest\n+import os\n+import ast\n+\n+class TestAnsibleConnectionUtils(unittest.TestCase):\n+\n+    def test_connection_utils_exists(self):\n+        # Path to the connection.py file\n+        file_path = 'lib/ansible/module_utils/connection.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Check if ConnectionUtils class is defined in the file\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        connection_utils_class = None\n+        expected_functions = {'write_to_stream', 'send_data', 'recv_data', 'exec_command', 'request_builder'}\n+        found_functions = set()\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ClassDef) and node.name == 'ConnectionUtils':\n+                connection_utils_class = node\n+                for func in node.body:\n+                    if isinstance(func, ast.FunctionDef) and func.name in expected_functions:\n+                        found_functions.add(func.name)\n+\n+        self.assertIsNotNone(connection_utils_class, \"Class 'ConnectionUtils' not found in connection.py\")\n+        self.assertEqual(expected_functions, found_functions, \"Not all expected functions were found in 'ConnectionUtils'\")\n+\n+    def test_imports_connection_utils_in_task_executor(self):\n+        # Path to the task_executor.py file\n+        file_path = 'lib/ansible/executor/task_executor.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Check if ConnectionUtils is imported in the file\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        connection_utils_imported = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom) and node.module == 'ansible.module_utils.connection':\n+                for alias in node.names:\n+                    if alias.name == 'ConnectionUtils':\n+                        connection_utils_imported = True\n+                        break\n+\n+        self.assertTrue(connection_utils_imported, \"ConnectionUtils not imported in task_executor.py\")\n+\n+    def test_imports_connection_utils_in_ansible_connection_cli_stub(self):\n+        # Path to the ansible_connection_cli_stub.py file\n+        file_path = 'lib/ansible/cli/scripts/ansible_connection_cli_stub.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Check if ConnectionUtils is imported in the file\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        connection_utils_imported = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom) and node.module == 'ansible.module_utils.connection':\n+                for alias in node.names:\n+                    if alias.name == 'ConnectionUtils':\n+                        connection_utils_imported = True\n+                        break\n+\n+        self.assertTrue(connection_utils_imported, \"ConnectionUtils not imported in ansible_connection_cli_stub.py\")\n+        \n+    def test_connection_uses_connection_utils(self):\n+        # Path to the connection.py file\n+        file_path = 'lib/ansible/module_utils/connection.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Check if Connection class uses ConnectionUtils methods\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        connection_class = None\n+        request_builder_used = False\n+        recv_data_used = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ClassDef) and node.name == 'Connection':\n+                connection_class = node\n+                for method in node.body:\n+                    if isinstance(method, ast.FunctionDef):\n+                        if method.name == '_exec_jsonrpc':\n+                            for inner_node in ast.walk(method):\n+                                if isinstance(inner_node, ast.Call) and isinstance(inner_node.func, ast.Attribute):\n+                                    if (inner_node.func.attr == 'request_builder' and\n+                                            isinstance(inner_node.func.value, ast.Name) and\n+                                            inner_node.func.value.id == 'ConnectionUtils'):\n+                                        request_builder_used = True\n+                        elif method.name == 'send':\n+                            for inner_node in ast.walk(method):\n+                                if isinstance(inner_node, ast.Call) and isinstance(inner_node.func, ast.Attribute):\n+                                    if (inner_node.func.attr == 'recv_data' and\n+                                            isinstance(inner_node.func.value, ast.Name) and\n+                                            inner_node.func.value.id == 'ConnectionUtils'):\n+                                        recv_data_used = True\n+\n+        self.assertIsNotNone(connection_class, \"Class 'Connection' not found in connection.py\")\n+        self.assertTrue(request_builder_used, \"'request_builder' from ConnectionUtils is not used in '_exec_jsonrpc' method\")\n+        self.assertTrue(recv_data_used, \"'recv_data' from ConnectionUtils is not used in 'send' method\")\n+\n+    def test_start_connection_uses_write_to_stream(self):\n+        # Path to the task_executor.py file\n+        file_path = 'lib/ansible/executor/task_executor.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Check if ConnectionUtils.write_to_stream is used in start_connection\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        start_connection_function = None\n+        write_to_stream_used = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.FunctionDef) and node.name == 'start_connection':\n+                start_connection_function = node\n+                for inner_node in ast.walk(start_connection_function):\n+                    if isinstance(inner_node, ast.Call) and isinstance(inner_node.func, ast.Attribute):\n+                        if (inner_node.func.attr == 'write_to_stream' and\n+                                isinstance(inner_node.func.value, ast.Name) and\n+                                inner_node.func.value.id == 'ConnectionUtils'):\n+                            write_to_stream_used = True\n+                            break\n+\n+        self.assertIsNotNone(start_connection_function, \"Function 'start_connection' not found in task_executor.py\")\n+        self.assertTrue(write_to_stream_used, \"'write_to_stream' from ConnectionUtils is not used in 'start_connection' function\")\n+\n+    def test_ansible_connection_cli_stub_imports(self):\n+        # Path to the ansible_connection_cli_stub.py file\n+        file_path = 'lib/ansible/cli/scripts/ansible_connection_cli_stub.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Check if Connection, ConnectionError, and ConnectionUtils are imported from ansible.module_utils.connection\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        expected_imports = {'Connection', 'ConnectionError', 'ConnectionUtils'}\n+        found_imports = set()\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom) and node.module == 'ansible.module_utils.connection':\n+                for alias in node.names:\n+                    if alias.name in expected_imports:\n+                        found_imports.add(alias.name)\n+\n+        self.assertEqual(expected_imports, found_imports, \"Not all expected imports found in ansible_connection_cli_stub.py\")\n+        \n+    def test_run_function_uses_recv_send_data(self):\n+        # Path to the ansible_connection_cli_stub.py file\n+        file_path = 'lib/ansible/cli/scripts/ansible_connection_cli_stub.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Check if ConnectionUtils.recv_data and ConnectionUtils.send_data are used in the run function of ConnectionProcess class\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        connection_process_class = None\n+        recv_data_used = False\n+        send_data_used = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ClassDef) and node.name == 'ConnectionProcess':\n+                connection_process_class = node\n+                for method in node.body:\n+                    if isinstance(method, ast.FunctionDef) and method.name == 'run':\n+                        for inner_node in ast.walk(method):\n+                            if isinstance(inner_node, ast.Call) and isinstance(inner_node.func, ast.Attribute):\n+                                if (inner_node.func.attr == 'recv_data' and\n+                                        isinstance(inner_node.func.value, ast.Name) and\n+                                        inner_node.func.value.id == 'ConnectionUtils'):\n+                                    recv_data_used = True\n+                                if (inner_node.func.attr == 'send_data' and\n+                                        isinstance(inner_node.func.value, ast.Name) and\n+                                        inner_node.func.value.id == 'ConnectionUtils'):\n+                                    send_data_used = True\n+\n+        self.assertIsNotNone(connection_process_class, \"Class 'ConnectionProcess' not found in ansible_connection_cli_stub.py\")\n+        self.assertTrue(recv_data_used, \"'recv_data' from ConnectionUtils is not used in 'run' function of ConnectionProcess class\")\n+        self.assertTrue(send_data_used, \"'send_data' from ConnectionUtils is not used in 'run' function of ConnectionProcess class\")\n+\n+\n+\n+if __name__ == '__main__':\n+    unittest.main()",
    "problem_statement": "Change all the standalone functions in connection.py with a new class called ConnectionUtils and alter all the usages of those functions accordingly.",
    "hints_text": "",
    "created_at": "2025-11-03 22:46:32+00:00",
    "language": "Python",
    "Dockerfile": "N/A",
    "test_command": "python3 -m unittest new-utils-class-connection-test.py",
    "task_category": "Refactoring",
    "data_source": "microsoft/RefactorBench",
    "scenario": "brownfield"
  },
  {
    "repo": "ansible/ansible",
    "url": "https://github.com/ansible/ansible",
    "instance_id": "add-log-parameter-is-systemd-managed",
    "base_commit": "add-log-parameter-is-systemd-managed",
    "patch": "N/A",
    "test_patch": "diff --git a/add-log-parameter-is-systemd-managed-test.py b/add-log-parameter-is-systemd-managed-test.py\nnew file mode 100644\nindex 0000000..8453fe9\n--- /dev/null\n+++ b/add-log-parameter-is-systemd-managed-test.py\n@@ -0,0 +1,129 @@\n+import unittest\n+import os\n+import ast\n+\n+class TestAnsibleImports(unittest.TestCase):\n+\n+    def test_is_systemd_managed_has_log_parameter(self):\n+        # Path to the file where the is_systemd_managed function should be defined\n+        file_path = 'lib/ansible/module_utils/service.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Check if is_systemd_managed function has a 'log' parameter\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        is_systemd_managed_function = None\n+        log_parameter_found = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.FunctionDef) and node.name == 'is_systemd_managed':\n+                is_systemd_managed_function = node\n+                for arg in is_systemd_managed_function.args.args:\n+                    if arg.arg == 'log':\n+                        log_parameter_found = True\n+\n+        self.assertIsNotNone(is_systemd_managed_function, \"Function 'is_systemd_managed' not found in service.py\")\n+        self.assertTrue(log_parameter_found, \"Parameter 'log' not found in 'is_systemd_managed' function\")\n+        \n+    def test_is_systemd_managed_called_with_log_true_in_service(self):\n+        # Path to the file where the service.py module should be checked\n+        file_path = 'lib/ansible/modules/service.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Check if is_systemd_managed is called with log=True\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        log_true_passed_in_is_systemd_managed = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.Call) and isinstance(node.func, ast.Name) and node.func.id == 'is_systemd_managed':\n+                for keyword in node.keywords:\n+                    if keyword.arg == 'log' and isinstance(keyword.value, ast.Constant) and keyword.value.value is True:\n+                        log_true_passed_in_is_systemd_managed = True\n+\n+        self.assertTrue(log_true_passed_in_is_systemd_managed, \"Parameter 'log=True' not passed to 'is_systemd_managed' in service.py\")\n+\n+    def test_is_systemd_managed_called_with_log_true_in_service_facts(self):\n+        # Path to the file where the service_facts.py module should be checked\n+        file_path = 'lib/ansible/modules/service_facts.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Check if is_systemd_managed is called with log=True\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        log_true_passed_in_is_systemd_managed = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.Call) and isinstance(node.func, ast.Name) and node.func.id == 'is_systemd_managed':\n+                for keyword in node.keywords:\n+                    if keyword.arg == 'log' and isinstance(keyword.value, ast.Constant) and keyword.value.value is True:\n+                        log_true_passed_in_is_systemd_managed = True\n+\n+        self.assertTrue(log_true_passed_in_is_systemd_managed, \"Parameter 'log=True' not passed to 'is_systemd_managed' in service_facts.py\")\n+        \n+    def test_is_systemd_managed_unchanged_in_systemd_facts(self):\n+        # Path to the file where ServiceMgrFactCollector.is_systemd_managed(module) should be checked\n+        file_path = 'lib/ansible/module_utils/facts/system/systemd.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Read and parse the file\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        # Check if ServiceMgrFactCollector.is_systemd_managed(module) is present and unchanged\n+        is_systemd_managed_call_found = False\n+        log_parameter_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.Call) and isinstance(node.func, ast.Attribute):\n+                if (node.func.attr == 'is_systemd_managed' and\n+                        isinstance(node.func.value, ast.Name) and node.func.value.id == 'ServiceMgrFactCollector'):\n+                    is_systemd_managed_call_found = True\n+                    for keyword in node.keywords:\n+                        if keyword.arg == 'log':\n+                            log_parameter_found = True\n+                    break\n+\n+        self.assertTrue(is_systemd_managed_call_found, \"Call to ServiceMgrFactCollector.is_systemd_managed(module) not found or changed in systemd.py\")\n+        self.assertFalse(log_parameter_found, \"Parameter 'log' should not be passed to 'ServiceMgrFactCollector.is_systemd_managed(module)' in systemd.py\")\n+\n+    def test_is_systemd_managed_unchanged_in_hostname(self):\n+        # Path to the file where ServiceMgrFactCollector.is_systemd_managed(module) should be checked\n+        file_path = 'lib/ansible/modules/hostname.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Read and parse the file\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        # Check if ServiceMgrFactCollector.is_systemd_managed(module) is present and unchanged\n+        is_systemd_managed_call_found = False\n+        log_parameter_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.Call) and isinstance(node.func, ast.Attribute):\n+                if (node.func.attr == 'is_systemd_managed' and\n+                        isinstance(node.func.value, ast.Name) and node.func.value.id == 'ServiceMgrFactCollector'):\n+                    is_systemd_managed_call_found = True\n+                    for keyword in node.keywords:\n+                        if keyword.arg == 'log':\n+                            log_parameter_found = True\n+                    break\n+\n+        self.assertTrue(is_systemd_managed_call_found, \"Call to ServiceMgrFactCollector.is_systemd_managed(module) not found or changed in hostname.py\")\n+        self.assertFalse(log_parameter_found, \"Parameter 'log' should not be passed to 'ServiceMgrFactCollector.is_systemd_managed(module)' in hostname.py\")\n+\n+\n+if __name__ == '__main__':\n+    unittest.main()",
    "problem_statement": "Add a log boolean paramter to is_systemd_managed in service.py in module_utils and keep the base case as false. Make all instances of it as true except for tests.",
    "hints_text": "",
    "created_at": "2025-11-03 22:46:32+00:00",
    "language": "Python",
    "Dockerfile": "N/A",
    "test_command": "python3 -m unittest add-log-parameter-is-systemd-managed-test.py",
    "task_category": "Refactoring",
    "data_source": "microsoft/RefactorBench",
    "scenario": "brownfield"
  },
  {
    "repo": "ansible/ansible",
    "url": "https://github.com/ansible/ansible",
    "instance_id": "combine-namespace-compat",
    "base_commit": "combine-namespace-compat",
    "patch": "N/A",
    "test_patch": "diff --git a/combine-namespace-compat-test.py b/combine-namespace-compat-test.py\nnew file mode 100644\nindex 0000000..2cd2d02\n--- /dev/null\n+++ b/combine-namespace-compat-test.py\n@@ -0,0 +1,144 @@\n+import unittest\n+import os\n+import ast\n+\n+class TestAnsibleImports(unittest.TestCase):\n+\n+    def test_import_in_ansible_collector(self):\n+        # Path to the file where ansible_collector.py should be checked\n+        file_path = 'lib/ansible/module_utils/facts/ansible_collector.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Check if the specific text string exists in the file\n+        search_string = \"ansible.module_utils.facts.compat.PrefixFactNamespace(prefix='ansible_')\"\n+        with open(file_path, 'r') as file:\n+            file_content = file.read()\n+\n+        # Check if the search string is present in the file content\n+        self.assertIn(search_string, file_content, f\"'{search_string}' not found in ansible_collector.py\")\n+\n+\n+    def test_import_in_compat(self):\n+        # Path to the file where compat.py should be checked\n+        file_path = 'lib/ansible/module_utils/facts/compat.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Check if PrefixFactNamespace is imported from ansible.module_utils.facts.compat\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        import_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom):\n+                if (node.module == 'ansible.module_utils.facts.namespace' and\n+                        any(alias.name == 'PrefixFactNamespace' for alias in node.names)):\n+                    import_found = True\n+                    break\n+\n+        self.assertFalse(import_found, \"PrefixFactNamespace imported from 'ansible.module_utils.facts.namespace' in compat.py\")\n+\n+    def test_import_in_facter(self):\n+        # Path to the file where facter.py should be checked\n+        file_path = 'lib/ansible/module_utils/facts/other/facter.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Check if PrefixFactNamespace is imported from ansible.module_utils.facts.compat\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        import_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom):\n+                if (node.module == 'ansible.module_utils.facts.compat' and\n+                        any(alias.name == 'PrefixFactNamespace' for alias in node.names)):\n+                    import_found = True\n+                    break\n+\n+        self.assertTrue(import_found, \"PrefixFactNamespace not imported from 'ansible.module_utils.facts.compat' in facter.py\")\n+\n+    def test_import_in_ohai(self):\n+        # Path to the file where ohai.py should be checked\n+        file_path = 'lib/ansible/module_utils/facts/other/ohai.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Check if PrefixFactNamespace is imported from ansible.module_utils.facts.compat\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        import_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom):\n+                if (node.module == 'ansible.module_utils.facts.compat' and\n+                        any(alias.name == 'PrefixFactNamespace' for alias in node.names)):\n+                    import_found = True\n+                    break\n+\n+        self.assertTrue(import_found, \"PrefixFactNamespace not imported from 'ansible.module_utils.facts.compat' in ohai.py\")\n+\n+    def test_import_in_setup(self):\n+        # Path to the file where setup.py should be checked\n+        file_path = 'lib/ansible/modules/setup.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Check if PrefixFactNamespace is imported from ansible.module_utils.facts.compat\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        import_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom):\n+                if (node.module == 'ansible.module_utils.facts.compat' and\n+                        any(alias.name == 'PrefixFactNamespace' for alias in node.names)):\n+                    import_found = True\n+                    break\n+\n+        self.assertTrue(import_found, \"PrefixFactNamespace not imported from 'ansible.module_utils.facts.compat' in setup.py\")\n+        \n+    def test_import_in_test_ansible_collector(self):\n+        # Path to the file where test_ansible_collector.py should be checked\n+        file_path = 'test/units/module_utils/facts/test_ansible_collector.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Parse the file and check if 'from ansible.module_utils.facts import compat' exists\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        import_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom):\n+                if node.module == 'ansible.module_utils.facts' and any(alias.name == 'compat' for alias in node.names):\n+                    import_found = True\n+                    break\n+\n+        self.assertTrue(import_found, \"'from ansible.module_utils.facts import compat' not found in test_ansible_collector.py\")\n+\n+    def test_ns_in_test_ansible_collector(self):\n+        # Path to the file where test_ansible_collector.py should be checked\n+        file_path = 'test/units/module_utils/facts/test_ansible_collector.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Check if 'from ansible.module_utils.facts import compat' exists in the file\n+        search_string = \"ns = compat.PrefixFactNamespace('ansible_facts', 'ansible_')\"\n+        with open(file_path, 'r') as file:\n+            file_content = file.read()\n+\n+        # Check if the search string is present in the file content\n+        self.assertIn(search_string, file_content, f\"'{search_string}' not found in test_ansible_collector.py\")\n+\n+\n+if __name__ == '__main__':\n+    unittest.main()",
    "problem_statement": "Combine all the classes and information from namespace.py in module_utils/facts into compat.py and update all the references throughout the repository.",
    "hints_text": "",
    "created_at": "2025-11-03 22:46:32+00:00",
    "language": "Python",
    "Dockerfile": "N/A",
    "test_command": "python3 -m unittest combine-namespace-compat-test.py",
    "task_category": "Refactoring",
    "data_source": "microsoft/RefactorBench",
    "scenario": "brownfield"
  },
  {
    "repo": "ansible/ansible",
    "url": "https://github.com/ansible/ansible",
    "instance_id": "parse_key_value",
    "base_commit": "parse_key_value",
    "patch": "N/A",
    "test_patch": "diff --git a/parse_key_value-test.py b/parse_key_value-test.py\nnew file mode 100644\nindex 0000000..256e450\n--- /dev/null\n+++ b/parse_key_value-test.py\n@@ -0,0 +1,378 @@\n+import unittest\n+import os\n+import ast\n+\n+class TestAnsibleImports(unittest.TestCase):\n+\n+    def test_parse_key_value_defined_in_splitter_py(self):\n+        file_path = 'lib/ansible/parsing/splitter.py'\n+        function_name = 'parse_key_value'\n+        \n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+        \n+        # Read and parse the file\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+        \n+        # Check if the function parse_key_value is defined\n+        function_defined = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.FunctionDef) and node.name == function_name:\n+                function_defined = True\n+                break\n+\n+        self.assertTrue(function_defined, f\"Function '{function_name}' is not defined in {file_path}\")\n+\n+    def test_import_in_hacking_test_module_py(self):\n+        file_path = 'hacking/test-module.py'\n+        module_name = 'ansible.parsing.splitter'\n+        import_name = 'parse_key_value'\n+        \n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+        \n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+        \n+        import_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom) and node.module == module_name:\n+                for name in node.names:\n+                    if name.name == import_name:\n+                        import_found = True\n+                        break\n+\n+        self.assertTrue(import_found, f\"Import '{import_name}' from '{module_name}' not found in {file_path}\")\n+\n+    def test_no_parse_kv_in_hacking_test_module_py(self):\n+        file_path = 'hacking/test-module.py'\n+        \n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+        \n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        parse_kv_used = any(\n+            isinstance(node, ast.Call) and isinstance(node.func, ast.Name) and node.func.id == 'parse_kv'\n+            for node in ast.walk(tree)\n+        )\n+\n+        self.assertFalse(parse_kv_used, f\"'parse_kv' should not be used in {file_path}\")\n+\n+    def test_import_in_lib_ansible_cli_adhoc_py(self):\n+        file_path = 'lib/ansible/cli/adhoc.py'\n+        module_name = 'ansible.parsing.splitter'\n+        import_name = 'parse_key_value'\n+        \n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+        \n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+        \n+        import_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom) and node.module == module_name:\n+                for name in node.names:\n+                    if name.name == import_name:\n+                        import_found = True\n+                        break\n+\n+        self.assertTrue(import_found, f\"Import '{import_name}' from '{module_name}' not found in {file_path}\")\n+\n+    def test_no_parse_kv_in_lib_ansible_cli_adhoc_py(self):\n+        file_path = 'lib/ansible/cli/adhoc.py'\n+        \n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+        \n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        parse_kv_used = any(\n+            isinstance(node, ast.Call) and isinstance(node.func, ast.Name) and node.func.id == 'parse_kv'\n+            for node in ast.walk(tree)\n+        )\n+\n+        self.assertFalse(parse_kv_used, f\"'parse_kv' should not be used in {file_path}\")\n+\n+    def test_import_in_lib_ansible_cli_console_py(self):\n+        file_path = 'lib/ansible/cli/console.py'\n+        module_name = 'ansible.parsing.splitter'\n+        import_name = 'parse_key_value'\n+        \n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+        \n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+        \n+        import_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom) and node.module == module_name:\n+                for name in node.names:\n+                    if name.name == import_name:\n+                        import_found = True\n+                        break\n+\n+        self.assertTrue(import_found, f\"Import '{import_name}' from '{module_name}' not found in {file_path}\")\n+\n+    def test_no_parse_kv_in_lib_ansible_cli_console_py(self):\n+        file_path = 'lib/ansible/cli/console.py'\n+        \n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+        \n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        parse_kv_used = any(\n+            isinstance(node, ast.Call) and isinstance(node.func, ast.Name) and node.func.id == 'parse_kv'\n+            for node in ast.walk(tree)\n+        )\n+\n+        self.assertFalse(parse_kv_used, f\"'parse_kv' should not be used in {file_path}\")\n+\n+    def test_import_in_lib_ansible_parsing_mod_args_py(self):\n+        file_path = 'lib/ansible/parsing/mod_args.py'\n+        module_name = 'ansible.parsing.splitter'\n+        import_name = 'parse_key_value'\n+        \n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+        \n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+        \n+        import_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom) and node.module == module_name:\n+                for name in node.names:\n+                    if name.name == import_name:\n+                        import_found = True\n+                        break\n+\n+        self.assertTrue(import_found, f\"Import '{import_name}' from '{module_name}' not found in {file_path}\")\n+\n+    def test_no_parse_kv_in_lib_ansible_parsing_mod_args_py(self):\n+        file_path = 'lib/ansible/parsing/mod_args.py'\n+        \n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+        \n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        parse_kv_used = any(\n+            isinstance(node, ast.Call) and isinstance(node.func, ast.Name) and node.func.id == 'parse_kv'\n+            for node in ast.walk(tree)\n+        )\n+\n+        self.assertFalse(parse_kv_used, f\"'parse_kv' should not be used in {file_path}\")\n+\n+    def test_import_in_lib_ansible_parsing_splitter_py(self):\n+        file_path = 'lib/ansible/parsing/splitter.py'\n+        module_name = 'ansible.parsing.quoting'\n+        import_name = 'unquote'\n+        \n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+        \n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+        \n+        import_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom) and node.module == module_name:\n+                for name in node.names:\n+                    if name.name == import_name:\n+                        import_found = True\n+                        break\n+\n+        self.assertTrue(import_found, f\"Import '{import_name}' from '{module_name}' not found in {file_path}\")\n+\n+    def test_no_parse_kv_in_lib_ansible_parsing_splitter_py(self):\n+        file_path = 'lib/ansible/parsing/splitter.py'\n+        \n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+        \n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        parse_kv_used = any(\n+            isinstance(node, ast.Call) and isinstance(node.func, ast.Name) and node.func.id == 'parse_kv'\n+            for node in ast.walk(tree)\n+        )\n+\n+        self.assertFalse(parse_kv_used, f\"'parse_kv' should not be defined in {file_path}\")\n+\n+    def test_import_in_lib_ansible_plugins_lookup_csvfile_py(self):\n+        file_path = 'lib/ansible/plugins/lookup/csvfile.py'\n+        module_name = 'ansible.parsing.splitter'\n+        import_name = 'parse_key_value'\n+        \n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+        \n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+        \n+        import_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom) and node.module == module_name:\n+                for name in node.names:\n+                    if name.name == import_name:\n+                        import_found = True\n+                        break\n+\n+        self.assertTrue(import_found, f\"Import '{import_name}' from '{module_name}' not found in {file_path}\")\n+\n+    def test_no_parse_kv_in_lib_ansible_plugins_lookup_csvfile_py(self):\n+        file_path = 'lib/ansible/plugins/lookup/csvfile.py'\n+        \n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+        \n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        parse_kv_used = any(\n+            isinstance(node, ast.Call) and isinstance(node.func, ast.Name) and node.func.id == 'parse_kv'\n+            for node in ast.walk(tree)\n+        )\n+\n+        self.assertFalse(parse_kv_used, f\"'parse_kv' should not be used in {file_path}\")\n+\n+    def test_import_in_lib_ansible_plugins_lookup_password_py(self):\n+        file_path = 'lib/ansible/plugins/lookup/password.py'\n+        module_name = 'ansible.parsing.splitter'\n+        import_name = 'parse_key_value'\n+        \n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+        \n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+        \n+        import_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom) and node.module == module_name:\n+                for name in node.names:\n+                    if name.name == import_name:\n+                        import_found = True\n+                        break\n+\n+        self.assertTrue(import_found, f\"Import '{import_name}' from '{module_name}' not found in {file_path}\")\n+\n+    def test_no_parse_kv_in_lib_ansible_plugins_lookup_password_py(self):\n+        file_path = 'lib/ansible/plugins/lookup/password.py'\n+        \n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+        \n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        parse_kv_used = any(\n+            isinstance(node, ast.Call) and isinstance(node.func, ast.Name) and node.func.id == 'parse_kv'\n+            for node in ast.walk(tree)\n+        )\n+\n+        self.assertFalse(parse_kv_used, f\"'parse_kv' should not be used in {file_path}\")\n+\n+    def test_import_in_lib_ansible_plugins_lookup_sequence_py(self):\n+        file_path = 'lib/ansible/plugins/lookup/sequence.py'\n+        module_name = 'ansible.parsing.splitter'\n+        import_name = 'parse_key_value'\n+        \n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+        \n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+        \n+        import_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom) and node.module == module_name:\n+                for name in node.names:\n+                    if name.name == import_name:\n+                        import_found = True\n+                        break\n+\n+        self.assertTrue(import_found, f\"Import '{import_name}' from '{module_name}' not found in {file_path}\")\n+\n+    def test_no_parse_kv_in_lib_ansible_plugins_lookup_sequence_py(self):\n+        file_path = 'lib/ansible/plugins/lookup/sequence.py'\n+        \n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+        \n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        parse_kv_used = any(\n+            isinstance(node, ast.Call) and isinstance(node.func, ast.Name) and node.func.id == 'parse_kv'\n+            for node in ast.walk(tree)\n+        )\n+\n+        self.assertFalse(parse_kv_used, f\"'parse_kv' should not be used in {file_path}\")\n+\n+    def test_import_in_lib_ansible_utils_vars_py(self):\n+        file_path = 'lib/ansible/utils/vars.py'\n+        module_name = 'ansible.parsing.splitter'\n+        import_name = 'parse_key_value'\n+        \n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+        \n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+        \n+        import_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom) and node.module == module_name:\n+                for name in node.names:\n+                    if name.name == import_name:\n+                        import_found = True\n+                        break\n+\n+        self.assertTrue(import_found, f\"Import '{import_name}' from '{module_name}' not found in {file_path}\")\n+\n+    def test_no_parse_kv_in_lib_ansible_utils_vars_py(self):\n+        file_path = 'lib/ansible/utils/vars.py'\n+        \n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+        \n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        parse_kv_used = any(\n+            isinstance(node, ast.Call) and isinstance(node.func, ast.Name) and node.func.id == 'parse_kv'\n+            for node in ast.walk(tree)\n+        )\n+\n+        self.assertFalse(parse_kv_used, f\"'parse_kv' should not be used in {file_path}\")\n+\n+    def test_import_in_test_units_parsing_test_splitter_py(self):\n+        file_path = 'test/units/parsing/test_splitter.py'\n+        module_name = 'ansible.parsing.splitter'\n+        import_name = 'parse_key_value'\n+        \n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+        \n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+        \n+        import_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom) and node.module == module_name:\n+                for name in node.names:\n+                    if name.name == import_name:\n+                        import_found = True\n+                        break\n+\n+        self.assertTrue(import_found, f\"Import '{import_name}' from '{module_name}' not found in {file_path}\")\n+\n+    def test_no_parse_kv_in_test_units_parsing_test_splitter_py(self):\n+        file_path = 'test/units/parsing/test_splitter.py'\n+        \n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+        \n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        parse_kv_used = any(\n+            isinstance(node, ast.Call) and isinstance(node.func, ast.Name) and node.func.id == 'parse_kv'\n+            for node in ast.walk(tree)\n+        )\n+\n+        self.assertFalse(parse_kv_used, f\"'parse_kv' should not be used in {file_path}\")\n+\n+if __name__ == '__main__':\n+    unittest.main()",
    "problem_statement": "Rename parse_kv in splitters to parse_key_value for clarity and then update those references of the function throughout the repo.",
    "hints_text": "",
    "created_at": "2025-11-03 22:46:32+00:00",
    "language": "Python",
    "Dockerfile": "N/A",
    "test_command": "python3 -m unittest parse_key_value-test.py",
    "task_category": "Refactoring",
    "data_source": "microsoft/RefactorBench",
    "scenario": "brownfield"
  },
  {
    "repo": "ansible/ansible",
    "url": "https://github.com/ansible/ansible",
    "instance_id": "move-quoting-splitter",
    "base_commit": "move-quoting-splitter",
    "patch": "N/A",
    "test_patch": "diff --git a/move-quoting-splitter-test.py b/move-quoting-splitter-test.py\nnew file mode 100644\nindex 0000000..4c2e86d\n--- /dev/null\n+++ b/move-quoting-splitter-test.py\n@@ -0,0 +1,124 @@\n+import unittest\n+import os\n+import ast\n+\n+class TestAnsibleImports(unittest.TestCase):\n+\n+    def test_config_imports_unquote(self):\n+        # Path to the config.py file\n+        file_path = 'lib/ansible/cli/config.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Check if unquote is imported\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        unquote_imported = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom) and node.module == 'ansible.parsing.splitter':\n+                for name in node.names:\n+                    if name.name == 'is_quoted':\n+                        unquote_imported = True\n+\n+        self.assertTrue(unquote_imported, \"'is_quoted' not imported from 'ansible.parsing.splitter' in config.py\")\n+\n+    def test_dataloader_imports_unquote(self):\n+        # Path to the dataloader.py file\n+        file_path = 'lib/ansible/parsing/dataloader.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Check if unquote is imported\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        unquote_imported = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom) and node.module == 'ansible.parsing.splitter':\n+                for name in node.names:\n+                    if name.name == 'unquote':\n+                        unquote_imported = True\n+\n+        self.assertTrue(unquote_imported, \"'unquote' not imported from 'ansible.parsing.splitter' in dataloader.py\")\n+\n+    def test_splitter_contains_unquote_and_is_quoted(self):\n+        # Path to the splitter.py file\n+        file_path = 'lib/ansible/parsing/splitter.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Check if unquote and is_quoted are defined\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        unquote_found = False\n+        is_quoted_found = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.FunctionDef):\n+                if node.name == 'unquote':\n+                    unquote_found = True\n+                if node.name == 'is_quoted':\n+                    is_quoted_found = True\n+\n+        self.assertTrue(unquote_found, \"'unquote' function not found in splitter.py\")\n+        self.assertTrue(is_quoted_found, \"'is_quoted' function not found in splitter.py\")\n+\n+    def test_schema_imports_unquote(self):\n+        # Path to the schema.py file\n+        file_path = 'test/lib/ansible_test/_util/controller/sanity/validate-modules/validate_modules/schema.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Check if unquote is imported\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        unquote_imported = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom) and node.module == 'ansible.parsing.splitter':\n+                for name in node.names:\n+                    if name.name == 'unquote':\n+                        unquote_imported = True\n+\n+        self.assertTrue(unquote_imported, \"'unquote' not imported from 'ansible.parsing.splitter' in schema.py\")\n+\n+    def test_test_unquote_imports_unquote(self):\n+        # Path to the test_unquote.py file\n+        file_path = 'test/units/parsing/test_unquote.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Check if unquote is imported\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        unquote_imported = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom) and node.module == 'ansible.parsing.splitter':\n+                for name in node.names:\n+                    if name.name == 'unquote':\n+                        unquote_imported = True\n+\n+        self.assertTrue(unquote_imported, \"'unquote' not imported from 'ansible.parsing.splitter' in test_unquote.py\")\n+\n+    def test_quoting_file_deleted(self):\n+        # Path to the quoting.py file\n+        file_path = 'lib/ansible/parsing/quoting.py'\n+\n+        # Check if the file has been deleted\n+        self.assertFalse(os.path.exists(file_path), f\"{file_path} should be deleted but still exists\")\n+\n+\n+if __name__ == '__main__':\n+    unittest.main()",
    "problem_statement": "Move all the content from quoting to splitter in lib/ansible/parsing and update all the references in the repository.",
    "hints_text": "",
    "created_at": "2025-11-03 22:46:32+00:00",
    "language": "Python",
    "Dockerfile": "N/A",
    "test_command": "python3 -m unittest move-quoting-splitter-test.py",
    "task_category": "Refactoring",
    "data_source": "microsoft/RefactorBench",
    "scenario": "brownfield"
  },
  {
    "repo": "ansible/ansible",
    "url": "https://github.com/ansible/ansible",
    "instance_id": "new-utils-from-basic",
    "base_commit": "new-utils-from-basic",
    "patch": "N/A",
    "test_patch": "diff --git a/new-utils-from-basic-test.py b/new-utils-from-basic-test.py\nnew file mode 100644\nindex 0000000..b8c4c99\n--- /dev/null\n+++ b/new-utils-from-basic-test.py\n@@ -0,0 +1,215 @@\n+import unittest\n+import os\n+import ast\n+\n+class TestAnsibleImports(unittest.TestCase):\n+\n+    def test_missing_required_lib_import_in_basic(self):\n+        file_path = 'lib/ansible/module_utils/basic.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+        \n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        import_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom) and node.module == 'ansible.module_utils.utils':\n+                for name in node.names:\n+                    if name.name == 'heuristic_log_sanitize':\n+                        import_found = True\n+                        break\n+        \n+        self.assertTrue(import_found, \"Import 'heuristic_log_sanitize' not found in basic.py\")\n+\n+    def test_missing_required_lib_import_in_facts_packages(self):\n+        file_path = 'lib/ansible/module_utils/facts/packages.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+        \n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        import_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom) and node.module == 'ansible.module_utils.utils':\n+                for name in node.names:\n+                    if name.name == 'missing_required_lib':\n+                        import_found = True\n+                        break\n+        \n+        self.assertTrue(import_found, \"Import 'missing_required_lib' not found in packages.py\")\n+\n+    def test_missing_required_lib_import_in_urls(self):\n+        file_path = 'lib/ansible/module_utils/urls.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+        \n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        import_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom) and node.module == 'ansible.module_utils.utils':\n+                for name in node.names:\n+                    if name.name == 'missing_required_lib':\n+                        import_found = True\n+                        break\n+        \n+        self.assertTrue(import_found, \"Import 'missing_required_lib' not found in urls.py\")\n+\n+    def test_missing_required_lib_import_in_deb822_repository(self):\n+        file_path = 'lib/ansible/modules/deb822_repository.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+        \n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        import_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom) and node.module == 'ansible.module_utils.utils':\n+                for name in node.names:\n+                    if name.name == 'missing_required_lib':\n+                        import_found = True\n+                        break\n+        \n+        self.assertTrue(import_found, \"Import 'missing_required_lib' not found in deb822_repository.py\")\n+\n+    def test_missing_required_lib_import_in_expect(self):\n+        file_path = 'lib/ansible/modules/expect.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+        \n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        import_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom) and node.module == 'ansible.module_utils.utils':\n+                for name in node.names:\n+                    if name.name == 'missing_required_lib':\n+                        import_found = True\n+                        break\n+        \n+        self.assertTrue(import_found, \"Import 'missing_required_lib' not found in expect.py\")\n+\n+    def test_missing_required_lib_import_in_pip(self):\n+        file_path = 'lib/ansible/modules/pip.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+        \n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        import_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom) and node.module == 'ansible.module_utils.utils':\n+                for name in node.names:\n+                    if name.name == 'missing_required_lib':\n+                        import_found = True\n+                        break\n+        \n+        self.assertTrue(import_found, \"Import 'missing_required_lib' not found in pip.py\")\n+\n+    def test_missing_required_lib_import_in_wait_for(self):\n+        file_path = 'lib/ansible/modules/wait_for.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+        \n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        import_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom) and node.module == 'ansible.module_utils.utils':\n+                for name in node.names:\n+                    if name.name == 'missing_required_lib':\n+                        import_found = True\n+                        break\n+        \n+        self.assertTrue(import_found, \"Import 'missing_required_lib' not found in wait_for.py\")\n+\n+    def test_missing_required_lib_import_in_netconf_init(self):\n+        file_path = 'lib/ansible/plugins/netconf/__init__.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+        \n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        import_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom) and node.module == 'ansible.module_utils.utils':\n+                for name in node.names:\n+                    if name.name == 'missing_required_lib':\n+                        import_found = True\n+                        break\n+        \n+        self.assertTrue(import_found, \"Import 'missing_required_lib' not found in __init__.py\")\n+\n+    def test_missing_required_lib_import_in_missing_required_lib_test(self):\n+        file_path = 'test/integration/targets/missing_required_lib/library/missing_required_lib.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+        \n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        import_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom) and node.module == 'ansible.module_utils.utils':\n+                for name in node.names:\n+                    if name.name == 'missing_required_lib':\n+                        import_found = True\n+                        break\n+        \n+        self.assertTrue(import_found, \"Import 'missing_required_lib' not found in missing_required_lib.py\")\n+\n+    def test_missing_required_lib_import_in_test_heuristic_log_sanitize(self):\n+        file_path = 'test/integration/targets/module_utils/library/test_heuristic_log_sanitize.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+        \n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        import_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom) and node.module == 'ansible.module_utils':\n+                for name in node.names:\n+                    if name.name == 'utils':\n+                        import_found = True\n+                        break\n+        \n+        self.assertTrue(import_found, \"Import 'utils' not found in test_heuristic_log_sanitize.py\")\n+        \n+    def test_heuristic_log_sanitize_assignment_in_test_heuristic_log_sanitize(self):\n+        file_path = 'test/integration/targets/module_utils/library/test_heuristic_log_sanitize.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+        \n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        assignment_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.Assign):\n+                for target in node.targets:\n+                    if isinstance(target, ast.Name) and target.id == 'heuristic_log_sanitize':\n+                        if isinstance(node.value, ast.Attribute):\n+                            if node.value.attr == 'heuristic_log_sanitize' and node.value.value.id == 'utils':\n+                                assignment_found = True\n+                                break\n+        \n+        self.assertTrue(assignment_found, \"Assignment 'heuristic_log_sanitize = utils.heuristic_log_sanitize' not found in test_heuristic_log_sanitize.py\")\n+\n+\n+    def test_missing_required_lib_import_in_network_cli(self):\n+        file_path = 'test/support/network-integration/collections/ansible_collections/ansible/netcommon/plugins/connection/network_cli.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+        \n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        import_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom) and node.module == 'ansible.module_utils.utils':\n+                for name in node.names:\n+                    if name.name == 'missing_required_lib':\n+                        import_found = True\n+                        break\n+        \n+        self.assertTrue(import_found, \"Import 'missing_required_lib' not found in network_cli.py\")\n+\n+if __name__ == '__main__':\n+    unittest.main()",
    "problem_statement": "Move heuristic_log_sanitize and missing_required_lib into a new utils.py file in module_utils, remove the old functions, and update all the references of those throughout the repository.",
    "hints_text": "",
    "created_at": "2025-11-03 22:46:32+00:00",
    "language": "Python",
    "Dockerfile": "N/A",
    "test_command": "python3 -m unittest new-utils-from-basic-test.py",
    "task_category": "Refactoring",
    "data_source": "microsoft/RefactorBench",
    "scenario": "brownfield"
  },
  {
    "repo": "ansible/ansible",
    "url": "https://github.com/ansible/ansible",
    "instance_id": "sort-groups-to-group-sort",
    "base_commit": "sort-groups-to-group-sort",
    "patch": "N/A",
    "test_patch": "diff --git a/sort-groups-to-group-sort-test.py b/sort-groups-to-group-sort-test.py\nnew file mode 100644\nindex 0000000..7a61213\n--- /dev/null\n+++ b/sort-groups-to-group-sort-test.py\n@@ -0,0 +1,120 @@\n+import unittest\n+import os\n+import ast\n+\n+class TestAnsibleImports(unittest.TestCase):\n+\n+    def test_group_sort_imported_in_manager(self):\n+        # Path to the file where the imports should be defined\n+        file_path = 'lib/ansible/vars/manager.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Check if group_sort and get_group_vars are imported from ansible.inventory.helpers\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        group_sort_found = False\n+        get_group_vars_found = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom):\n+                if node.module == 'ansible.inventory.helpers':\n+                    for alias in node.names:\n+                        if alias.name == 'group_sort':\n+                            group_sort_found = True\n+                        if alias.name == 'get_group_vars':\n+                            get_group_vars_found = True\n+\n+        self.assertTrue(group_sort_found, \"Import 'group_sort' not found in manager.py\")\n+        self.assertTrue(get_group_vars_found, \"Import 'get_group_vars' not found in manager.py\")\n+        \n+    def test_group_sort_function_exists(self):\n+        # Path to the file where the group_sort function should be defined\n+        file_path = 'lib/ansible/inventory/helpers.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Check if group_sort function is defined in helpers.py\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        group_sort_function_found = False\n+        correct_lambda_found = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.FunctionDef) and node.name == 'group_sort':\n+                group_sort_function_found = True\n+                # Check if the function has the correct lambda expression\n+                for inner_node in ast.walk(node):\n+                    if isinstance(inner_node, ast.Call) and isinstance(inner_node.func, ast.Name) and inner_node.func.id == 'sorted':\n+                        for keyword in inner_node.keywords:\n+                            if keyword.arg == 'key' and isinstance(keyword.value, ast.Lambda):\n+                                lambda_node = keyword.value\n+                                if isinstance(lambda_node.body, ast.Tuple) and len(lambda_node.body.elts) == 3:\n+                                    elements = [elt.attr for elt in lambda_node.body.elts if isinstance(elt, ast.Attribute)]\n+                                    if elements == ['depth', 'priority', 'name']:\n+                                        correct_lambda_found = True\n+\n+        self.assertTrue(group_sort_function_found, \"Function 'group_sort' not found in helpers.py\")\n+        self.assertTrue(correct_lambda_found, \"Lambda expression in 'group_sort' function does not match the expected structure\")\n+\n+    def test_get_group_vars_calls_group_sort(self):\n+        # Path to the file where the get_group_vars function should be defined\n+        file_path = 'lib/ansible/inventory/helpers.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Check if get_group_vars function calls group_sort(groups)\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        get_group_vars_function = None\n+        group_sort_call_found = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.FunctionDef) and node.name == 'get_group_vars':\n+                get_group_vars_function = node\n+                for inner_node in ast.walk(get_group_vars_function):\n+                    if isinstance(inner_node, ast.Call) and isinstance(inner_node.func, ast.Name) and inner_node.func.id == 'group_sort':\n+                        group_sort_call_found = True\n+                        break\n+\n+        self.assertIsNotNone(get_group_vars_function, \"Function 'get_group_vars' not found in helpers.py\")\n+        self.assertTrue(group_sort_call_found, \"Call to 'group_sort(groups)' not found in 'get_group_vars' function\")\n+\n+    def test_group_sort_called_in_variable_manager_get_vars(self):\n+        # Path to the file where VariableManager and get_vars should be defined\n+        file_path = 'lib/ansible/vars/manager.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Check if group_sort is called in get_vars method of VariableManager class\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        variable_manager_class = None\n+        get_vars_function = None\n+        group_sort_call_found = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ClassDef) and node.name == 'VariableManager':\n+                variable_manager_class = node\n+                for inner_node in ast.walk(variable_manager_class):\n+                    if isinstance(inner_node, ast.FunctionDef) and inner_node.name == 'get_vars':\n+                        get_vars_function = inner_node\n+                        for call_node in ast.walk(get_vars_function):\n+                            if isinstance(call_node, ast.Call) and isinstance(call_node.func, ast.Name) and call_node.func.id == 'group_sort':\n+                                group_sort_call_found = True\n+                                break\n+\n+        self.assertIsNotNone(variable_manager_class, \"Class 'VariableManager' not found in manager.py\")\n+        self.assertIsNotNone(get_vars_function, \"Function 'get_vars' not found in VariableManager class in manager.py\")\n+        self.assertTrue(group_sort_call_found, \"Call to 'group_sort(groups)' not found in 'get_vars' method of VariableManager class in manager.py\")\n+\n+if __name__ == '__main__':\n+    unittest.main()",
    "problem_statement": "Rename sort_groups to group_sort and update all references in the repo.",
    "hints_text": "",
    "created_at": "2025-11-03 22:46:32+00:00",
    "language": "Python",
    "Dockerfile": "N/A",
    "test_command": "python3 -m unittest sort-groups-to-group-sort-test.py",
    "task_category": "Refactoring",
    "data_source": "microsoft/RefactorBench",
    "scenario": "brownfield"
  },
  {
    "repo": "ansible/ansible",
    "url": "https://github.com/ansible/ansible",
    "instance_id": "new-inventory-patterns",
    "base_commit": "new-inventory-patterns",
    "patch": "N/A",
    "test_patch": "diff --git a/new-inventory-patterns-test.py b/new-inventory-patterns-test.py\nnew file mode 100644\nindex 0000000..8f43152\n--- /dev/null\n+++ b/new-inventory-patterns-test.py\n@@ -0,0 +1,210 @@\n+import unittest\n+import os\n+import ast\n+\n+class TestAnsibleImports(unittest.TestCase):\n+\n+    def test_import_exists_in_manager(self):\n+        # Path to the file where the import should be checked\n+        file_path = 'lib/ansible/inventory/manager.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Check if the import from ansible.inventory.patterns exists\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        import_found = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom):\n+                if node.module == 'ansible.inventory.patterns':\n+                    imported_names = {alias.name for alias in node.names}\n+                    if 'order_patterns' in imported_names and 'split_host_pattern' in imported_names:\n+                        import_found = True\n+\n+        self.assertTrue(import_found, \"Import 'from ansible.inventory.patterns import order_patterns, split_host_pattern' not found in manager.py\")\n+\n+    def test_functions_exist_in_patterns(self):\n+        # Path to the file where the functions should be defined\n+        file_path = 'lib/ansible/inventory/patterns.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Check if order_patterns and split_host_pattern functions are defined\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        order_patterns_found = False\n+        split_host_pattern_found = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.FunctionDef):\n+                if node.name == 'order_patterns':\n+                    order_patterns_found = True\n+                if node.name == 'split_host_pattern':\n+                    split_host_pattern_found = True\n+\n+        self.assertTrue(order_patterns_found, \"Function 'order_patterns' not found in patterns.py\")\n+        self.assertTrue(split_host_pattern_found, \"Function 'split_host_pattern' not found in patterns.py\")\n+        \n+    def test_import_re_exists(self):\n+        # Path to the file where the import should be checked\n+        file_path = 'lib/ansible/inventory/patterns.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Check if the import 'import re' exists\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        import_found = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.Import):\n+                for alias in node.names:\n+                    if alias.name == 're':\n+                        import_found = True\n+\n+        self.assertTrue(import_found, \"Import 'import re' not found in patterns.py\")\n+\n+    def test_import_itertools_exists(self):\n+        # Path to the file where the import should be checked\n+        file_path = 'lib/ansible/inventory/patterns.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Check if the import 'import itertools' exists\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        import_found = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.Import):\n+                for alias in node.names:\n+                    if alias.name == 'itertools':\n+                        import_found = True\n+\n+        self.assertTrue(import_found, \"Import 'import itertools' not found in patterns.py\")\n+\n+    def test_import_string_types_exists(self):\n+        # Path to the file where the import should be checked\n+        file_path = 'lib/ansible/inventory/patterns.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Check if the import 'from ansible.module_utils.six import string_types' exists\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        import_found = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom):\n+                if node.module == 'ansible.module_utils.six':\n+                    imported_names = {alias.name for alias in node.names}\n+                    if 'string_types' in imported_names:\n+                        import_found = True\n+\n+        self.assertTrue(import_found, \"Import 'from ansible.module_utils.six import string_types' not found in patterns.py\")\n+\n+    def test_import_parse_address_exists(self):\n+        # Path to the file where the import should be checked\n+        file_path = 'lib/ansible/inventory/patterns.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Check if the import 'from ansible.parsing.utils.addresses import parse_address' exists\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        import_found = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom):\n+                if node.module == 'ansible.parsing.utils.addresses':\n+                    imported_names = {alias.name for alias in node.names}\n+                    if 'parse_address' in imported_names:\n+                        import_found = True\n+\n+        self.assertTrue(import_found, \"Import 'from ansible.parsing.utils.addresses import parse_address' not found in patterns.py\")\n+\n+    def test_import_to_text_exists(self):\n+        # Path to the file where the import should be checked\n+        file_path = 'lib/ansible/inventory/patterns.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Check if the import 'from ansible.module_utils.common.text.converters import to_text' exists\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        import_found = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom):\n+                if node.module == 'ansible.module_utils.common.text.converters':\n+                    imported_names = {alias.name for alias in node.names}\n+                    if 'to_text' in imported_names:\n+                        import_found = True\n+\n+        self.assertTrue(import_found, \"Import 'from ansible.module_utils.common.text.converters import to_text' not found in patterns.py\")\n+    \n+    def test_import_inventory_manager_exists(self):\n+        # Path to the file where the import should be checked\n+        file_path = 'test/units/plugins/inventory/test_inventory.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Check if the import 'from ansible.inventory.manager import InventoryManager' exists\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        import_found = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom):\n+                if node.module == 'ansible.inventory.manager':\n+                    imported_names = {alias.name for alias in node.names}\n+                    if 'InventoryManager' in imported_names:\n+                        import_found = True\n+\n+        self.assertTrue(import_found, \"Import 'from ansible.inventory.manager import InventoryManager' not found in test_inventory.py\")\n+\n+    def test_import_split_host_pattern_exists(self):\n+        # Path to the file where the import should be checked\n+        file_path = 'test/units/plugins/inventory/test_inventory.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Check if the import 'from ansible.inventory.patterns import split_host_pattern' exists\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        import_found = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom):\n+                if node.module == 'ansible.inventory.patterns':\n+                    imported_names = {alias.name for alias in node.names}\n+                    if 'split_host_pattern' in imported_names:\n+                        import_found = True\n+\n+        self.assertTrue(import_found, \"Import 'from ansible.inventory.patterns import split_host_pattern' not found in test_inventory.py\")\n+\n+\n+\n+\n+\n+if __name__ == '__main__':\n+    unittest.main()",
    "problem_statement": "Can you move the order_patterns and split_host_pattern functions from manager.py in inventory to a new file called patterns.py in inventory. Update all the imports in the repository, but don't create a new testing file for patterns.py.",
    "hints_text": "",
    "created_at": "2025-11-03 22:46:32+00:00",
    "language": "Python",
    "Dockerfile": "N/A",
    "test_command": "python3 -m unittest new-inventory-patterns-test.py",
    "task_category": "Refactoring",
    "data_source": "microsoft/RefactorBench",
    "scenario": "brownfield"
  },
  {
    "repo": "ansible/ansible",
    "url": "https://github.com/ansible/ansible",
    "instance_id": "rename-lenient-lowercase",
    "base_commit": "rename-lenient-lowercase",
    "patch": "N/A",
    "test_patch": "diff --git a/rename-lenient-lowercase-test.py b/rename-lenient-lowercase-test.py\nnew file mode 100644\nindex 0000000..dd2a357\n--- /dev/null\n+++ b/rename-lenient-lowercase-test.py\n@@ -0,0 +1,89 @@\n+import unittest\n+import os\n+import ast\n+\n+class TestAnsibleFunctionRename(unittest.TestCase):\n+\n+    def test_lenient_lowercase_renamed_to_lowercase_of_list(self):\n+        # Path to the file where lenient_lowercase should be renamed to lowercase_of_list\n+        file_path = 'lib/ansible/module_utils/common/text/formatters.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Check if lenient_lowercase is renamed to lowercase_of_list\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        lenient_lowercase_function = None\n+        lowercase_of_list_function = None\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.FunctionDef):\n+                if node.name == 'lenient_lowercase':\n+                    lenient_lowercase_function = node\n+                elif node.name == 'lowercase_of_list':\n+                    lowercase_of_list_function = node\n+\n+        self.assertIsNone(lenient_lowercase_function, \"Function 'lenient_lowercase' should have been renamed\")\n+        self.assertIsNotNone(lowercase_of_list_function, \"Function 'lowercase_of_list' not found in formatters.py\")\n+\n+    def test_lowercase_of_list_imported_in_basic(self):\n+        # Path to the file where lowercase_of_list should be imported\n+        file_path = 'lib/ansible/module_utils/basic.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Check if lowercase_of_list is imported\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        lowercase_of_list_imported = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom):\n+                if node.module == 'ansible.module_utils.common.text.formatters':\n+                    for name in node.names:\n+                        if name.name == 'lowercase_of_list':\n+                            lowercase_of_list_imported = True\n+\n+        self.assertTrue(lowercase_of_list_imported, \"Function 'lowercase_of_list' not imported in basic.py\")\n+        \n+    def test_test_file_renamed(self):\n+        # Paths to the old and new test files\n+        old_test_file = 'test/units/module_utils/common/text/formatters/test_lenient_lowercase.py'\n+        new_test_file = 'test/units/module_utils/common/text/formatters/test_lowercase_of_list.py'\n+\n+        # Check that the old test file does not exist\n+        self.assertFalse(os.path.exists(old_test_file), f\"{old_test_file} should not exist\")\n+\n+        # Check that the new test file exists\n+        self.assertTrue(os.path.exists(new_test_file), f\"{new_test_file} does not exist\")\n+        \n+    def test_test_file_content_updated(self):\n+        # Path to the new test file\n+        test_file = 'test/units/module_utils/common/text/formatters/test_lowercase_of_list.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(test_file), f\"{test_file} does not exist\")\n+\n+        # Open and read the file\n+        with open(test_file, 'r', encoding='utf-8') as file:\n+            source_code = file.read()\n+\n+        # Check that 'lenient_lowercase' is not in the file\n+        self.assertNotIn('lenient_lowercase', source_code, \"Found reference to 'lenient_lowercase' in the test file\")\n+\n+        # Check that 'lowercase_of_list' is in the file\n+        self.assertIn('lowercase_of_list', source_code, \"'lowercase_of_list' not found in the test file\")\n+\n+        # Check that comments have been updated\n+        self.assertNotIn('Test that lenient_lowercase()', source_code, \"Old comment referring to 'lenient_lowercase' found\")\n+        self.assertIn('Test that lowercase_of_list()', source_code, \"Comment referring to 'lowercase_of_list' not found\")\n+\n+\n+\n+\n+if __name__ == '__main__':\n+    unittest.main()",
    "problem_statement": "Can you rename lenient_lowercase in lib/ansible/module_utils/common/text/formatters.py to lowercase_of_list. Can you update the filenames for the testing and all the references of lenient_lowercase to lowercase_of_list in the repository.",
    "hints_text": "",
    "created_at": "2025-11-03 22:46:32+00:00",
    "language": "Python",
    "Dockerfile": "N/A",
    "test_command": "python3 -m unittest rename-lenient-lowercase-test.py",
    "task_category": "Refactoring",
    "data_source": "microsoft/RefactorBench",
    "scenario": "brownfield"
  },
  {
    "repo": "ansible/ansible",
    "url": "https://github.com/ansible/ansible",
    "instance_id": "data-to-inventory-data",
    "base_commit": "data-to-inventory-data",
    "patch": "N/A",
    "test_patch": "diff --git a/data-to-inventory-data-test.py b/data-to-inventory-data-test.py\nnew file mode 100644\nindex 0000000..b4177c9\n--- /dev/null\n+++ b/data-to-inventory-data-test.py\n@@ -0,0 +1,80 @@\n+import unittest\n+import os\n+import ast\n+class TestAnsibleInventory(unittest.TestCase):\n+\n+    def test_inventory_data_exists(self):\n+        # Path to the directory where inventory_data.py should be located\n+        directory_path = 'lib/ansible/inventory/'\n+\n+        # Path to the specific files to be checked\n+        inventory_data_file = os.path.join(directory_path, 'inventory_data.py')\n+        data_file = os.path.join(directory_path, 'data.py')\n+\n+        # Check if inventory_data.py exists\n+        self.assertTrue(os.path.exists(inventory_data_file), f\"{inventory_data_file} does not exist\")\n+\n+    def test_data_py_does_not_exist(self):\n+        # Path to the directory where data.py should be checked\n+        directory_path = 'lib/ansible/inventory/'\n+\n+        # Path to the specific file to be checked\n+        data_file = os.path.join(directory_path, 'data.py')\n+\n+        # Check if data.py does not exist\n+        self.assertFalse(os.path.exists(data_file), f\"{data_file} should not exist\")\n+\n+    def test_manager_py_imports_inventory_data(self):\n+        # Path to the manager.py file\n+        manager_file_path = 'lib/ansible/inventory/manager.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(manager_file_path), f\"{manager_file_path} does not exist\")\n+\n+        # The line we expect to find in manager.py\n+        expected_import_line = 'from ansible.inventory.inventory_data import InventoryData'\n+\n+        # Check if the expected import line is in the file\n+        with open(manager_file_path, 'r') as file:\n+            file_content = file.read()\n+\n+        self.assertIn(expected_import_line, file_content, f\"'{expected_import_line}' not found in {manager_file_path}\")\n+\n+    def test_inventory_data_has_inventorydata_class(self):\n+        # Path to the inventory_data.py file\n+        inventory_data_file_path = 'lib/ansible/inventory/inventory_data.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(inventory_data_file_path), f\"{inventory_data_file_path} does not exist\")\n+\n+        # Parse the inventory_data.py file and check if it contains a class named InventoryData\n+        with open(inventory_data_file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        class_found = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ClassDef) and node.name == 'InventoryData':\n+                class_found = True\n+                break\n+\n+        self.assertTrue(class_found, f\"Class 'InventoryData' not found in {inventory_data_file_path}\")\n+\n+    def test_constructed_py_imports_inventory_data(self):\n+        # Path to the test_constructed.py file\n+        constructed_file_path = 'test/units/plugins/inventory/test_constructed.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(constructed_file_path), f\"{constructed_file_path} does not exist\")\n+\n+        # The line we expect to find in test_constructed.py\n+        expected_import_line = 'from ansible.inventory.inventory_data import InventoryData'\n+\n+        # Check if the expected import line is in the file\n+        with open(constructed_file_path, 'r') as file:\n+            file_content = file.read()\n+\n+        self.assertIn(expected_import_line, file_content, f\"'{expected_import_line}' not found in {constructed_file_path}\")\n+\n+if __name__ == '__main__':\n+    unittest.main()\n\\ No newline at end of file",
    "problem_statement": "Rename data.py in ansible/inventory to inventory_data.py and update all the references/imports throughout the repository based on that.",
    "hints_text": "",
    "created_at": "2025-11-03 22:46:32+00:00",
    "language": "Python",
    "Dockerfile": "N/A",
    "test_command": "python3 -m unittest data-to-inventory-data-test.py",
    "task_category": "Refactoring",
    "data_source": "microsoft/RefactorBench",
    "scenario": "brownfield"
  },
  {
    "repo": "ansible/ansible",
    "url": "https://github.com/ansible/ansible",
    "instance_id": "add-log-parameter-get-group-vars",
    "base_commit": "add-log-parameter-get-group-vars",
    "patch": "N/A",
    "test_patch": "diff --git a/add-log-parameter-get-group-vars-test.py b/add-log-parameter-get-group-vars-test.py\nnew file mode 100644\nindex 0000000..3ff9c43\n--- /dev/null\n+++ b/add-log-parameter-get-group-vars-test.py\n@@ -0,0 +1,145 @@\n+import unittest\n+import os\n+import ast\n+\n+class TestAnsibleImports(unittest.TestCase):\n+\n+    def test_get_group_vars_has_log_parameter(self):\n+        # Path to the file where the get_group_vars function should be defined\n+        file_path = 'lib/ansible/inventory/helpers.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Check if get_group_vars function has a 'log' parameter\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        get_group_vars_function = None\n+        log_parameter_found = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.FunctionDef) and node.name == 'get_group_vars':\n+                get_group_vars_function = node\n+                for arg in get_group_vars_function.args.args:\n+                    if arg.arg == 'log':\n+                        log_parameter_found = True\n+\n+        self.assertIsNotNone(get_group_vars_function, \"Function 'get_group_vars' not found in helpers.py\")\n+        self.assertTrue(log_parameter_found, \"Parameter 'log' not found in 'get_group_vars' function\")\n+        \n+    def test_log_false_in_variable_manager_get_vars(self):\n+        # Path to the file where VariableManager and get_vars should be defined\n+        file_path = 'lib/ansible/vars/manager.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Check if log=False is passed to get_group_vars in get_vars method of VariableManager class\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        variable_manager_class = None\n+        get_vars_function = None\n+        log_false_passed_in_get_vars = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ClassDef) and node.name == 'VariableManager':\n+                variable_manager_class = node\n+                for inner_node in ast.walk(variable_manager_class):\n+                    if isinstance(inner_node, ast.FunctionDef) and inner_node.name == 'get_vars':\n+                        get_vars_function = inner_node\n+                        for def_node in ast.walk(get_vars_function):\n+                            if isinstance(def_node, ast.FunctionDef) and def_node.name == 'groups_inventory':\n+                                for call_node in ast.walk(def_node):\n+                                    if isinstance(call_node, ast.Call) and isinstance(call_node.func, ast.Name) and call_node.func.id == 'get_group_vars':\n+                                        for keyword in call_node.keywords:\n+                                            if keyword.arg == 'log' and isinstance(keyword.value, ast.Constant) and keyword.value.value is False:\n+                                                log_false_passed_in_get_vars = True\n+\n+        self.assertIsNotNone(variable_manager_class, \"Class 'VariableManager' not found in manager.py\")\n+        self.assertIsNotNone(get_vars_function, \"Function 'get_vars' not found in VariableManager class in manager.py\")\n+        self.assertTrue(log_false_passed_in_get_vars, \"Parameter 'log=False' not passed to 'get_group_vars' in 'groups_inventory' function of 'get_vars' method\")\n+\n+    def test_vars_plugin_structure(self):\n+        # Path to the file to be checked\n+        file_path = 'test/integration/targets/old_style_vars_plugins/deprecation_warning/v2_vars_plugin.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Read and parse the file\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        # Check for future import\n+        future_import_found = False\n+        for node in tree.body:\n+            if isinstance(node, ast.ImportFrom) and node.module == '__future__' and any(alias.name == 'annotations' for alias in node.names):\n+                future_import_found = True\n+\n+        self.assertTrue(future_import_found, \"Missing 'from __future__ import annotations' in v2_vars_plugin.py\")\n+\n+        # Check for VarsModule class definition\n+        vars_module_class = None\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ClassDef) and node.name == 'VarsModule':\n+                vars_module_class = node\n+                break\n+\n+        self.assertIsNotNone(vars_module_class, \"Class 'VarsModule' not found in v2_vars_plugin.py\")\n+\n+        # Check methods get_host_vars and get_group_vars in VarsModule class\n+        required_methods = {'get_host_vars', 'get_group_vars'}\n+        found_methods = {node.name for node in vars_module_class.body if isinstance(node, ast.FunctionDef)}\n+\n+        self.assertTrue(required_methods.issubset(found_methods), f\"Methods {required_methods - found_methods} not found in VarsModule class\")\n+\n+        # Check that both methods return empty dicts\n+        for method_name in required_methods:\n+            method_node = next((node for node in vars_module_class.body if isinstance(node, ast.FunctionDef) and node.name == method_name), None)\n+            self.assertIsNotNone(method_node, f\"Method {method_name} not found in VarsModule class\")\n+            returns_empty_dict = any(isinstance(stmt, ast.Return) and isinstance(stmt.value, ast.Dict) and not stmt.value.keys for stmt in method_node.body)\n+            self.assertTrue(returns_empty_dict, f\"Method {method_name} does not return an empty dictionary\")\n+            \n+    def test_plugin_get_group_vars_no_log_in_plugins(self):\n+        # Path to the file to be checked\n+        file_path = 'lib/ansible/vars/plugins.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Read and parse the file\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        # Check that no calls to plugin.get_group_vars have the 'log' parameter\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.Call) and isinstance(node.func, ast.Attribute):\n+                if node.func.attr == 'get_group_vars' and isinstance(node.func.value, ast.Name) and node.func.value.id == 'plugin':\n+                    for keyword in node.keywords:\n+                        self.assertNotEqual(keyword.arg, 'log', f\"'log' parameter should not be passed in {file_path}\")\n+\n+    def test_plugin_get_group_vars_no_log_in_manager(self):\n+        # Path to the file to be checked\n+        file_path = 'lib/ansible/vars/manager.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Read and parse the file\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        # Check that no calls to plugin.get_group_vars have the 'log' parameter\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.Call) and isinstance(node.func, ast.Attribute):\n+                if node.func.attr == 'get_group_vars' and isinstance(node.func.value, ast.Name) and node.func.value.id == 'plugin':\n+                    for keyword in node.keywords:\n+                        self.assertNotEqual(keyword.arg, 'log', f\"'log' parameter should not be passed in {file_path}\")\n+\n+\n+\n+\n+if __name__ == '__main__':\n+    unittest.main()",
    "problem_statement": "Add a log parameter to get_group_vars and keep the base case as true and update the rest of the repository calls to have log=False.",
    "hints_text": "",
    "created_at": "2025-11-03 22:46:32+00:00",
    "language": "Python",
    "Dockerfile": "N/A",
    "test_command": "python3 -m unittest add-log-parameter-get-group-vars-test.py",
    "task_category": "Refactoring",
    "data_source": "microsoft/RefactorBench",
    "scenario": "brownfield"
  },
  {
    "repo": "django/django",
    "url": "https://github.com/django/django",
    "instance_id": "new-reference-context-field-class",
    "base_commit": "new-reference-context-field-class",
    "patch": "N/A",
    "test_patch": "diff --git a/new-reference-context-field-class-test.py b/new-reference-context-field-class-test.py\nnew file mode 100644\nindex 0000000..afc08c7\n--- /dev/null\n+++ b/new-reference-context-field-class-test.py\n@@ -0,0 +1,106 @@\n+import unittest\n+import ast\n+\n+class TestReferenceContextIntegration(unittest.TestCase):\n+\n+    def test_reference_context_class_exists(self):\n+        # File containing the ReferenceContext class\n+        file_path = 'django/db/migrations/utils.py'\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        class_found = any(\n+            isinstance(node, ast.ClassDef) and node.name == 'ReferenceContext'\n+            for node in ast.walk(tree)\n+        )\n+\n+        self.assertTrue(class_found, \"ReferenceContext class not found in the specified file\")\n+\n+    def test_field_references_argument_in_FieldOperation(self):\n+        # Path to the file where FieldOperation class is defined\n+        file_path = 'django/db/migrations/operations/fields.py'\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        # Walk the AST to find instances where field_references is called\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ClassDef) and node.name == 'FieldOperation':\n+                for class_node in ast.walk(node):\n+                    if isinstance(class_node, ast.FunctionDef):\n+                        for inner_node in ast.walk(class_node):\n+                            if isinstance(inner_node, ast.Call):\n+                                # Check if it's calling field_references\n+                                if (\n+                                    (isinstance(inner_node.func, ast.Name) and inner_node.func.id == 'field_references') or\n+                                    (isinstance(inner_node.func, ast.Attribute) and inner_node.func.attr == 'field_references')\n+                                ):\n+                                    # Check the first argument\n+                                    first_arg = inner_node.args[0]\n+                                    if not self._is_reference_context_instance(tree, first_arg):\n+                                        self.fail(f\"field_references does not take ReferenceContext instance as an argument in {file_path}\")\n+\n+    def test_field_references_argument_in_CreateModel(self):\n+        # Path to the file where CreateModel class is defined\n+        file_path = 'django/db/migrations/operations/models.py'\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        # Walk the AST to find instances where field_references is called\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ClassDef) and node.name == 'CreateModel':\n+                for class_node in ast.walk(node):\n+                    if isinstance(class_node, ast.FunctionDef):\n+                        for inner_node in ast.walk(class_node):\n+                            if isinstance(inner_node, ast.Call):\n+                                # Check if it's calling field_references\n+                                if (\n+                                    (isinstance(inner_node.func, ast.Name) and inner_node.func.id == 'field_references') or\n+                                    (isinstance(inner_node.func, ast.Attribute) and inner_node.func.attr == 'field_references')\n+                                ):\n+                                    # Check the first argument\n+                                    first_arg = inner_node.args[0]\n+                                    if not self._is_reference_context_instance(tree, first_arg):\n+                                        self.fail(f\"field_references does not take ReferenceContext instance as an argument in {file_path}\")\n+\n+    def _is_reference_context_instance(self, tree, node):\n+        \"\"\" Check if a node is or resolves to a ReferenceContext instance \"\"\"\n+        if isinstance(node, ast.Call) and isinstance(node.func, ast.Name) and node.func.id == 'ReferenceContext':\n+            return True\n+        elif isinstance(node, ast.Name):\n+            # Look for the assignment or initialization of this variable\n+            for assign_node in ast.walk(tree):\n+                if isinstance(assign_node, ast.Assign):\n+                    for target in assign_node.targets:\n+                        if isinstance(target, ast.Name) and target.id == node.id:\n+                            return self._is_reference_context_instance(tree, assign_node.value)\n+        return False\n+\n+    def test_reference_context_import_in_files(self):\n+        files_to_check = [\n+            'django/db/migrations/operations/fields.py',\n+            'django/db/migrations/operations/models.py',\n+        ]\n+\n+        for file_path in files_to_check:\n+            with open(file_path, 'r') as file:\n+                tree = ast.parse(file.read())\n+\n+            import_found = self._is_reference_context_imported(tree)\n+\n+            self.assertTrue(import_found, f\"ReferenceContext not imported in {file_path}\")\n+\n+    def _is_reference_context_imported(self, tree):\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom):\n+                if any(alias.name == 'ReferenceContext' for alias in node.names):\n+                    return True\n+            elif isinstance(node, ast.Import):\n+                if any(alias.name == 'ReferenceContext' for alias in node.names):\n+                    return True\n+        return False\n+\n+if __name__ == '__main__':\n+    unittest.main()",
    "problem_statement": "Create a ReferenceContext class inside /django/db/migrations/utils for all the parameters in field_references. Use this class in all calls to field_references",
    "hints_text": "",
    "created_at": "2025-11-03 22:46:32+00:00",
    "language": "Python",
    "Dockerfile": "N/A",
    "test_command": "python3 -m unittest new-reference-context-field-class-test.py",
    "task_category": "Refactoring",
    "data_source": "microsoft/RefactorBench",
    "scenario": "brownfield"
  },
  {
    "repo": "django/django",
    "url": "https://github.com/django/django",
    "instance_id": "rename-file-move-safe",
    "base_commit": "rename-file-move-safe",
    "patch": "N/A",
    "test_patch": "diff --git a/rename-file-move-safe-test.py b/rename-file-move-safe-test.py\nnew file mode 100644\nindex 0000000..cc8ca8a\n--- /dev/null\n+++ b/rename-file-move-safe-test.py\n@@ -0,0 +1,125 @@\n+import unittest\n+import ast\n+import os\n+\n+class TestFileMoveSafeRenamed(unittest.TestCase):\n+\n+    def test_function_renamed(self):\n+        # Path to the file containing the function definition\n+        file_path = 'django/core/files/move.py'\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        # Check if the old function name exists\n+        old_function_name_exists = any(\n+            isinstance(node, ast.FunctionDef) and node.name == 'file_move_safe'\n+            for node in ast.walk(tree)\n+        )\n+        self.assertFalse(old_function_name_exists, \"'file_move_safe' function still exists. It should be renamed.\")\n+\n+        # Check if the new function name exists\n+        new_function_name_exists = any(\n+            isinstance(node, ast.FunctionDef) and node.name == 'safe_file_move'\n+            for node in ast.walk(tree)\n+        )\n+        self.assertTrue(new_function_name_exists, \"'safe_file_move' function not found.\")\n+\n+    def test_imports_updated(self):\n+        # List of files to check for updated imports\n+        files_to_check_imports = [\n+            'django/core/cache/backends/filebased.py',\n+            'django/core/files/storage/filesystem.py',\n+            'tests/files/tests.py'\n+        ]\n+\n+        for file_path in files_to_check_imports:\n+            with open(file_path, 'r') as f:\n+                tree = ast.parse(f.read())\n+\n+            # Check if the old import exists\n+            old_import_exists = any(\n+                isinstance(node, ast.ImportFrom) and \n+                any(alias.name == 'file_move_safe' for alias in node.names)\n+                for node in ast.walk(tree)\n+            )\n+            self.assertFalse(old_import_exists, f\"Old import 'file_move_safe' found in {file_path}\")\n+\n+            # Check if the new import exists\n+            new_import_exists = any(\n+                isinstance(node, ast.ImportFrom) and \n+                any(alias.name == 'safe_file_move' for alias in node.names)\n+                for node in ast.walk(tree)\n+            )\n+            self.assertTrue(new_import_exists, f\"New import 'safe_file_move' not found in {file_path}\")\n+\n+    def test_function_calls_updated(self):\n+        # List of files to check for updated function calls\n+        files_to_check_calls = [\n+            'django/core/cache/backends/filebased.py',\n+            'django/core/files/storage/filesystem.py',\n+            'tests/files/tests.py'\n+        ]\n+\n+        for file_path in files_to_check_calls:\n+            with open(file_path, 'r') as f:\n+                tree = ast.parse(f.read())\n+\n+            # Check if the old function name is called\n+            old_call_exists = any(\n+                isinstance(node, ast.Call) and \n+                isinstance(node.func, ast.Name) and \n+                node.func.id == 'file_move_safe'\n+                for node in ast.walk(tree)\n+            )\n+            self.assertFalse(old_call_exists, f\"Old function call 'file_move_safe' found in {file_path}\")\n+\n+            # Check if the new function name is called\n+            new_call_exists = any(\n+                isinstance(node, ast.Call) and \n+                isinstance(node.func, ast.Name) and \n+                node.func.id == 'safe_file_move'\n+                for node in ast.walk(tree)\n+            )\n+            self.assertTrue(new_call_exists, f\"New function call 'safe_file_move' not found in {file_path}\")\n+\n+    def test_documentation_updated(self):\n+        # Path to the documentation or release notes file\n+        docs_file_path = 'docs/releases/1.11.2.txt'\n+\n+        with open(docs_file_path, 'r') as file:\n+            content = file.read()\n+\n+        # Check if the term \"safe_file_move\" is mentioned in the file\n+        self.assertIn(\"safe_file_move\", content, f\"'safe_file_move' not mentioned in {docs_file_path}\")\n+\n+    def test_comments_updated(self):\n+        # Path to the file that should contain comments referencing 'safe_file_move'\n+        file_path = 'django/core/files/move.py'\n+\n+        with open(file_path, 'r') as file:\n+            content = file.read()\n+\n+        # Check if the comments contain the reference to 'safe_file_move'\n+        self.assertIn(\"safe_file_move\", content, f\"Comments do not reference 'safe_file_move' in {file_path}\")\n+\n+    def test_all_updated(self):\n+        # Path to the file that should contain '__all__' list with 'safe_file_move'\n+        file_path = 'django/core/files/move.py'\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        # Check if '__all__' contains 'safe_file_move'\n+        all_node = next(\n+            (node for node in ast.walk(tree) if isinstance(node, ast.Assign) and any(target.id == '__all__' for target in node.targets)),\n+            None\n+        )\n+        if all_node:\n+            all_values = [elt.s for elt in all_node.value.elts if isinstance(elt, ast.Constant)]\n+            self.assertIn('safe_file_move', all_values, \"'safe_file_move' not found in __all__\")\n+        else:\n+            self.fail(\"__all__ not found in the file\")\n+\n+if __name__ == '__main__':\n+    unittest.main()",
    "problem_statement": "rename file_move_safe to safe_file_move and update repo accordingly. update the old doc releases to say \"now changed to safe_file_move\" whenever they reference the old function",
    "hints_text": "",
    "created_at": "2025-11-03 22:46:32+00:00",
    "language": "Python",
    "Dockerfile": "N/A",
    "test_command": "python3 -m unittest rename-file-move-safe-test.py",
    "task_category": "Refactoring",
    "data_source": "microsoft/RefactorBench",
    "scenario": "brownfield"
  },
  {
    "repo": "django/django",
    "url": "https://github.com/django/django",
    "instance_id": "new-timezone-class",
    "base_commit": "new-timezone-class",
    "patch": "N/A",
    "test_patch": "diff --git a/new-timezone-class-test.py b/new-timezone-class-test.py\nnew file mode 100644\nindex 0000000..16ab535\n--- /dev/null\n+++ b/new-timezone-class-test.py\n@@ -0,0 +1,152 @@\n+import unittest\n+import ast\n+\n+class TestTimeZoneFunctionsInClass(unittest.TestCase):\n+\n+    def test_functions_in_any_class(self):\n+        # Path to the file containing the classes with the timezone functions\n+        file_path = 'django/forms/utils.py'\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        functions_found_in_class = {\n+            'from_current_timezone': False,\n+            'to_current_timezone': False\n+        }\n+\n+        # Walk through the AST tree to find any class and check its methods\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ClassDef):  # Look for class definitions\n+                for class_node in node.body:\n+                    if isinstance(class_node, ast.FunctionDef):\n+                        if class_node.name in functions_found_in_class:\n+                            functions_found_in_class[class_node.name] = True\n+\n+        self.assertTrue(functions_found_in_class['from_current_timezone'], \n+                        \"'from_current_timezone' method not found within any class\")\n+        self.assertTrue(functions_found_in_class['to_current_timezone'], \n+                        \"'to_current_timezone' method not found within any class\")\n+\n+    def test_class_imported_in_other_files(self):\n+        # Path to the file containing the classes with the timezone functions\n+        class_file = 'django/forms/utils.py'\n+        class_names = []\n+\n+        with open(class_file, 'r') as file:\n+            tree = ast.parse(file.read())\n+        \n+        # Collect all class names\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ClassDef):\n+                class_names.append(node.name)\n+        \n+        self.assertTrue(class_names, \"No classes found in the utils.py file.\")\n+\n+        # List of files to check for the import\n+        files_to_check = [\n+            'django/forms/fields.py',\n+            'django/forms/widgets.py',\n+            # Add more file paths as needed\n+        ]\n+\n+        for file_path in files_to_check:\n+            with open(file_path, 'r') as file:\n+                tree = ast.parse(file.read())\n+\n+            class_imported = any(\n+                self._is_class_imported_in_file(tree, class_name)\n+                for class_name in class_names\n+            )\n+\n+            self.assertTrue(class_imported, f\"None of the classes '{', '.join(class_names)}' imported in {file_path}\")\n+\n+    def test_from_current_timezone_called_using_class(self):\n+        # Path to the file containing the classes with the timezone functions\n+        class_file = 'django/forms/utils.py'\n+        class_names = []\n+\n+        with open(class_file, 'r') as file:\n+            tree = ast.parse(file.read())\n+        \n+        # Collect all class names\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ClassDef):\n+                class_names.append(node.name)\n+\n+        self.assertTrue(class_names, \"No classes found in the utils.py file.\")\n+\n+        # List of files to check for the function calls\n+        files_to_check = [\n+            'django/forms/fields.py',\n+            # Add more file paths as needed\n+        ]\n+\n+        for file_path in files_to_check:\n+            with open(file_path, 'r') as file:\n+                tree = ast.parse(file.read())\n+\n+            function_called = False\n+\n+            # Check for function calls using the class name\n+            for node in ast.walk(tree):\n+                if isinstance(node, ast.Call) and isinstance(node.func, ast.Attribute):\n+                    if node.func.attr == 'from_current_timezone':\n+                        if isinstance(node.func.value, ast.Name) and node.func.value.id in class_names:\n+                            function_called = True\n+                            break\n+\n+            self.assertTrue(function_called, f\"Function 'from_current_timezone' not called using any of the classes '{', '.join(class_names)}' in {file_path}\")\n+\n+    def test_to_current_timezone_called_using_class(self):\n+        # Path to the file containing the classes with the timezone functions\n+        class_file = 'django/forms/utils.py'\n+        class_names = []\n+\n+        with open(class_file, 'r') as file:\n+            tree = ast.parse(file.read())\n+        \n+        # Collect all class names\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ClassDef):\n+                class_names.append(node.name)\n+\n+        self.assertTrue(class_names, \"No classes found in the utils.py file.\")\n+\n+        # List of files to check for the function calls\n+        files_to_check = [\n+            'django/forms/widgets.py',\n+            'django/forms/fields.py',\n+            # Add more file paths as needed\n+        ]\n+\n+        for file_path in files_to_check:\n+            with open(file_path, 'r') as file:\n+                tree = ast.parse(file.read())\n+\n+            function_called = False\n+\n+            # Check for function calls using the class name\n+            for node in ast.walk(tree):\n+                if isinstance(node, ast.Call) and isinstance(node.func, ast.Attribute):\n+                    if node.func.attr == 'to_current_timezone':\n+                        if isinstance(node.func.value, ast.Name) and node.func.value.id in class_names:\n+                            function_called = True\n+                            break\n+\n+            self.assertTrue(function_called, f\"Function 'to_current_timezone' not called using any of the classes '{', '.join(class_names)}' in {file_path}\")\n+\n+    def _is_class_imported_in_file(self, tree, class_name):\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom):\n+                for alias in node.names:\n+                    if alias.name == class_name:\n+                        return True\n+            elif isinstance(node, ast.Import):\n+                for alias in node.names:\n+                    if alias.name.split('.')[-1] == class_name:\n+                        return True\n+        return False\n+\n+if __name__ == '__main__':\n+    unittest.main()",
    "problem_statement": "Create a timezone class for the functions in django/forms/utils and update all the references in the repo.",
    "hints_text": "",
    "created_at": "2025-11-03 22:46:32+00:00",
    "language": "Python",
    "Dockerfile": "N/A",
    "test_command": "python3 -m unittest new-timezone-class-test.py",
    "task_category": "Refactoring",
    "data_source": "microsoft/RefactorBench",
    "scenario": "brownfield"
  },
  {
    "repo": "django/django",
    "url": "https://github.com/django/django",
    "instance_id": "new-utils-path-from-module",
    "base_commit": "new-utils-path-from-module",
    "patch": "N/A",
    "test_patch": "diff --git a/new-utils-path-from-module-test.py b/new-utils-path-from-module-test.py\nnew file mode 100644\nindex 0000000..1f9edb2\n--- /dev/null\n+++ b/new-utils-path-from-module-test.py\n@@ -0,0 +1,43 @@\n+import unittest\n+import ast\n+import os\n+\n+class TestAppsUtils(unittest.TestCase):\n+\n+    def test_path_from_module_function_definition(self):\n+        # Path to the apps_utils.py file containing _path_from_module\n+        file_path = 'django/apps/apps_utils.py'\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.FunctionDef) and node.name == '_path_from_module':\n+                # Check if the function has the correct arguments\n+                args = [arg.arg for arg in node.args.args]\n+                self.assertIn('module', args, \"Missing 'module' parameter\")\n+                \n+                return  # We found and checked the function, so we can stop here\n+\n+        self.fail(\"_path_from_module function not found in the file\")\n+\n+    def test_path_from_module_import_in_app_config(self):\n+        # Path to the file containing AppConfig class\n+        file_path = 'django/apps/config.py'  \n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        # Check if _path_from_module is imported\n+        import_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom) and node.module == 'apps_utils':\n+                for alias in node.names:\n+                    if alias.name == '_path_from_module':\n+                        import_found = True\n+                        break\n+\n+        self.assertTrue(import_found, \"_path_from_module not imported from apps_utils in base.py\")\n+\n+if __name__ == '__main__':\n+    unittest.main()",
    "problem_statement": "Move _path_from_module in apps/config.py to a new utils file called apps_utils.py",
    "hints_text": "",
    "created_at": "2025-11-03 22:46:32+00:00",
    "language": "Python",
    "Dockerfile": "N/A",
    "test_command": "python3 -m unittest new-utils-path-from-module-test.py",
    "task_category": "Refactoring",
    "data_source": "microsoft/RefactorBench",
    "scenario": "brownfield"
  },
  {
    "repo": "django/django",
    "url": "https://github.com/django/django",
    "instance_id": "combine-utils-dates-dateformat",
    "base_commit": "combine-utils-dates-dateformat",
    "patch": "N/A",
    "test_patch": "diff --git a/combine-utils-dates-dateformat-test.py b/combine-utils-dates-dateformat-test.py\nnew file mode 100644\nindex 0000000..07d0b4e\n--- /dev/null\n+++ b/combine-utils-dates-dateformat-test.py\n@@ -0,0 +1,85 @@\n+import unittest\n+import ast\n+import os\n+\n+class TestDatesMigration(unittest.TestCase):\n+\n+    def setUp(self):\n+        # Paths to the old and new files\n+        self.dates_file_path = 'django/utils/dates.py' \n+        self.dateformat_file_path = 'django/utils/dateformat.py'  \n+        self.widgets_file_path = 'django/forms/widgets.py' \n+        self.widget_tests_file_path = 'tests/forms_tests/widget_tests/test_selectdatewidget.py' \n+\n+    def test_dates_file_deleted(self):\n+        # Check if dates.py file has been deleted\n+        self.assertFalse(os.path.exists(self.dates_file_path), \"dates.py should be deleted\")\n+\n+    def test_dates_content_in_dateformat(self):\n+        with open(self.dateformat_file_path, 'r') as file:\n+            dateformat_tree = ast.parse(file.read())\n+\n+        # Check that all necessary constants from dates.py are in dateformat.py\n+        necessary_constants = [\n+            'WEEKDAYS', 'WEEKDAYS_ABBR', 'MONTHS', 'MONTHS_3', 'MONTHS_AP', 'MONTHS_ALT'\n+        ]\n+\n+        dateformat_names = {\n+            node.targets[0].id\n+            for node in ast.walk(dateformat_tree)\n+            if isinstance(node, ast.Assign) and isinstance(node.targets[0], ast.Name)\n+        }\n+\n+        for const in necessary_constants:\n+            self.assertIn(const, dateformat_names, f\"{const} not found in dateformat.py\")\n+\n+    def test_import_in_widgets(self):\n+        with open(self.widgets_file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        imported_names = {\n+            alias.name for node in ast.walk(tree)\n+            if isinstance(node, ast.ImportFrom) and node.module == 'django.utils.dateformat'\n+            for alias in node.names\n+        }\n+\n+        necessary_imports = [\n+            'MONTHS'\n+        ]\n+\n+        for name in necessary_imports:\n+            self.assertIn(name, imported_names, f\"{name} not imported from dateformat in widgets.py\")\n+\n+        # Ensure 'dates' is not imported\n+        dates_import_found = any(\n+            isinstance(node, ast.ImportFrom) and node.module == 'django.utils.dates'\n+            for node in ast.walk(tree)\n+        )\n+        self.assertFalse(dates_import_found, \"dates should not be imported in widgets.py\")\n+\n+    def test_import_in_widget_tests(self):\n+        with open(self.widget_tests_file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        imported_names = {\n+            alias.name for node in ast.walk(tree)\n+            if isinstance(node, ast.ImportFrom) and node.module == 'django.utils.dateformat'\n+            for alias in node.names\n+        }\n+\n+        necessary_imports = [\n+            'MONTHS_AP'\n+        ]\n+\n+        for name in necessary_imports:\n+            self.assertIn(name, imported_names, f\"{name} not imported from dateformat in test_selectdatewidget.py\")\n+\n+        # Ensure 'dates' is not imported\n+        dates_import_found = any(\n+            isinstance(node, ast.ImportFrom) and node.module == 'django.utils.dates'\n+            for node in ast.walk(tree)\n+        )\n+        self.assertFalse(dates_import_found, \"dates should not be imported in test_selectdatewidget.py\")\n+\n+if __name__ == '__main__':\n+    unittest.main()",
    "problem_statement": "Get rid of dates.py and put it all in dateformat.py, update the repository accordingly.",
    "hints_text": "",
    "created_at": "2025-11-03 22:46:32+00:00",
    "language": "Python",
    "Dockerfile": "N/A",
    "test_command": "python3 -m unittest combine-utils-dates-dateformat-test.py",
    "task_category": "Refactoring",
    "data_source": "microsoft/RefactorBench",
    "scenario": "brownfield"
  },
  {
    "repo": "django/django",
    "url": "https://github.com/django/django",
    "instance_id": "split-parse-apps-and-model-labels",
    "base_commit": "split-parse-apps-and-model-labels",
    "patch": "N/A",
    "test_patch": "diff --git a/split-parse-apps-and-model-labels-test.py b/split-parse-apps-and-model-labels-test.py\nnew file mode 100644\nindex 0000000..6195237\n--- /dev/null\n+++ b/split-parse-apps-and-model-labels-test.py\n@@ -0,0 +1,118 @@\n+import unittest\n+import ast\n+\n+class TestFunctionSplitting(unittest.TestCase):\n+\n+    def test_models_function(self):\n+        # Path to the file containing the split functions\n+        file_path = 'django/core/management/utils.py'\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        models_function_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.FunctionDef):\n+                if any(arg.arg == 'labels' for arg in node.args.args):\n+                    # Check if the function contains logic for models\n+                    models_logic = any(\n+                        isinstance(stmt, ast.If) and \".\" in stmt.test.left.s\n+                        for stmt in ast.walk(node)\n+                    )\n+                    if models_logic:\n+                        models_function_found = True\n+                        self.assertTrue(models_logic, \"Function for extracting models is missing or incorrect\")\n+                        break\n+\n+        self.assertTrue(models_function_found, \"Function for extracting models not found in the file\")\n+\n+    def test_apps_function(self):\n+        # Path to the file containing the split functions\n+        file_path = 'django/core/management/utils.py'\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        apps_function_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.FunctionDef):\n+                if any(arg.arg == 'labels' for arg in node.args.args):\n+                    # Check if the function contains logic for apps\n+                    apps_logic = any(\n+                        isinstance(stmt, ast.If) and isinstance(stmt.test, ast.Compare) and \n+                        isinstance(stmt.test.ops[0], ast.NotIn)\n+                        for stmt in ast.walk(node)\n+                    )\n+                    if apps_logic:\n+                        apps_function_found = True\n+                        self.assertTrue(apps_logic, \"Function for extracting apps is missing or incorrect\")\n+                        break\n+\n+        self.assertTrue(apps_function_found, \"Function for extracting apps not found in the file\")\n+\n+    def test_original_function_absent(self):\n+        # Path to the file containing the original function\n+        file_path = 'django/core/management/utils.py'\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        original_function_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.FunctionDef) and node.name == 'parse_apps_and_model_labels':\n+                original_function_found = True\n+                break\n+\n+        self.assertFalse(original_function_found, \"Original function 'parse_apps_and_model_labels' should not be present after refactoring\")\n+\n+    def test_import_of_new_functions(self):\n+        # Paths to the files that should import the new functions\n+        files_to_check = [\n+            'django/core/management/commands/loaddata.py',\n+            'django/core/management/commands/dumpdata.py',\n+        ]\n+\n+        for file_path in files_to_check:\n+            with open(file_path, 'r') as file:\n+                tree = ast.parse(file.read())\n+\n+            imports_models = False\n+            imports_apps = False\n+\n+            for node in ast.walk(tree):\n+                if isinstance(node, ast.ImportFrom):\n+                    for alias in node.names:\n+                        if alias.name == 'get_models_from_labels':\n+                            imports_models = True\n+                        if alias.name == 'get_apps_from_labels':\n+                            imports_apps = True\n+\n+            self.assertTrue(imports_models, f\"'get_models_from_labels' not imported in {file_path}\")\n+            self.assertTrue(imports_apps, f\"'get_apps_from_labels' not imported in {file_path}\")\n+\n+    def test_usage_of_new_functions(self):\n+        # Paths to the files that should use the new functions\n+        files_to_check = [\n+            'django/core/management/commands/loaddata.py',\n+            'django/core/management/commands/dumpdata.py',\n+        ]\n+\n+        for file_path in files_to_check:\n+            with open(file_path, 'r') as file:\n+                tree = ast.parse(file.read())\n+\n+            uses_models_function = False\n+            uses_apps_function = False\n+\n+            for node in ast.walk(tree):\n+                if isinstance(node, ast.Call) and isinstance(node.func, ast.Name):\n+                    if node.func.id == 'get_models_from_labels':\n+                        uses_models_function = True\n+                    if node.func.id == 'get_apps_from_labels':\n+                        uses_apps_function = True\n+\n+            self.assertTrue(uses_models_function, f\"'get_models_from_labels' not used in {file_path}\")\n+            self.assertTrue(uses_apps_function, f\"'get_apps_from_labels' not used in {file_path}\")\n+\n+if __name__ == '__main__':\n+    unittest.main()",
    "problem_statement": "split parse_apps_and_model_labels into a function that returns apps and a function that returns models",
    "hints_text": "",
    "created_at": "2025-11-03 22:46:32+00:00",
    "language": "Python",
    "Dockerfile": "N/A",
    "test_command": "python3 -m unittest split-parse-apps-and-model-labels-test.py",
    "task_category": "Refactoring",
    "data_source": "microsoft/RefactorBench",
    "scenario": "brownfield"
  },
  {
    "repo": "django/django",
    "url": "https://github.com/django/django",
    "instance_id": "combine-utils-hashable-itercompat",
    "base_commit": "combine-utils-hashable-itercompat",
    "patch": "N/A",
    "test_patch": "diff --git a/combine-utils-hashable-itercompat-test.py b/combine-utils-hashable-itercompat-test.py\nnew file mode 100644\nindex 0000000..132af2c\n--- /dev/null\n+++ b/combine-utils-hashable-itercompat-test.py\n@@ -0,0 +1,94 @@\n+import unittest\n+import ast\n+import os\n+\n+class TestUtilsMigration(unittest.TestCase):\n+\n+    def setUp(self):\n+        # Paths to the old and new files\n+        self.hashable_file_path = 'django/utils/hashable.py'\n+        self.itercompat_file_path = 'django/utils/itercompat.py'\n+        self.able_file_path = 'django/utils/able.py'\n+\n+        self.files_to_check = [\n+            'django/contrib/admin/utils.py',\n+            'django/core/exceptions.py',\n+            'django/db/models/base.py',\n+            'django/db/models/expressions.py',\n+            'django/db/models/fields/reverse_related.py',\n+            'django/db/models/lookups.py',\n+            'django/db/models/query_utils.py',\n+            'django/db/models/sql/compiler.py',\n+            'django/forms/models.py',\n+            'django/utils/tree.py',\n+        ]\n+\n+        self.combined_test_file_path = 'tests/utils_tests/test_able.py'\n+\n+    def test_old_files_deleted(self):\n+        # Check if hashable.py, itercompat.py, test_hashable.py, and test_itercompat.py files have been deleted\n+        self.assertFalse(os.path.exists(self.hashable_file_path), \"hashable.py should be deleted\")\n+        self.assertFalse(os.path.exists(self.itercompat_file_path), \"itercompat.py should be deleted\")\n+        self.assertFalse(os.path.exists('tests/utils_tests/test_hashable.py'), \"test_hashable.py should be deleted\")\n+        self.assertFalse(os.path.exists('tests/utils_tests/test_itercompat.py'), \"test_itercompat.py should be deleted\")\n+\n+    def test_functions_moved_to_able(self):\n+        with open(self.able_file_path, 'r') as file:\n+            able_tree = ast.parse(file.read())\n+\n+        functions_in_able = {\n+            node.name\n+            for node in ast.walk(able_tree)\n+            if isinstance(node, ast.FunctionDef)\n+        }\n+\n+        necessary_functions = [\n+            'make_hashable',\n+            'is_iterable'\n+        ]\n+\n+        for func in necessary_functions:\n+            self.assertIn(func, functions_in_able, f\"{func} not found in able.py\")\n+\n+    def test_make_hashable_imports_updated(self):\n+        for file_path in self.files_to_check:\n+            with self.subTest(file=file_path):\n+                with open(file_path, 'r') as file:\n+                    tree = ast.parse(file.read())\n+\n+                imported_names = {\n+                    alias.name for node in ast.walk(tree)\n+                    if isinstance(node, ast.ImportFrom) and node.module == 'django.utils.able'\n+                    for alias in node.names\n+                }\n+\n+                self.assertIn('make_hashable', imported_names, f\"make_hashable not imported from able in {file_path}\")\n+\n+                # Ensure 'hashable' is not imported\n+                old_import_found = any(\n+                    isinstance(node, ast.ImportFrom) and node.module == 'django.utils.hashable'\n+                    for node in ast.walk(tree)\n+                )\n+                self.assertFalse(old_import_found, f\"hashable should not be imported in {file_path}\")\n+\n+    def test_is_iterable_imports_updated(self):\n+        with open(self.combined_test_file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        imported_names = {\n+            alias.name for node in ast.walk(tree)\n+            if isinstance(node, ast.ImportFrom) and node.module == 'django.utils.able'\n+            for alias in node.names\n+        }\n+\n+        self.assertIn('is_iterable', imported_names, f\"is_iterable not imported from able in {self.combined_test_file_path}\")\n+\n+        # Ensure 'itercompat' is not imported\n+        old_import_found = any(\n+            isinstance(node, ast.ImportFrom) and node.module == 'django.utils.itercompat'\n+            for node in ast.walk(tree)\n+        )\n+        self.assertFalse(old_import_found, f\"itercompat should not be imported in {self.combined_test_file_path}\")\n+\n+if __name__ == '__main__':\n+    unittest.main()",
    "problem_statement": "Combine the utils files hashable and itercompat as a new file called able.py and remove the two of them, combine the tests too.",
    "hints_text": "",
    "created_at": "2025-11-03 22:46:32+00:00",
    "language": "Python",
    "Dockerfile": "N/A",
    "test_command": "python3 -m unittest combine-utils-hashable-itercompat-test.py",
    "task_category": "Refactoring",
    "data_source": "microsoft/RefactorBench",
    "scenario": "brownfield"
  },
  {
    "repo": "django/django",
    "url": "https://github.com/django/django",
    "instance_id": "add-log-parameter-get-resolver",
    "base_commit": "add-log-parameter-get-resolver",
    "patch": "N/A",
    "test_patch": "diff --git a/add-log-parameter-get-resolver-test.py b/add-log-parameter-get-resolver-test.py\nnew file mode 100644\nindex 0000000..47fde79\n--- /dev/null\n+++ b/add-log-parameter-get-resolver-test.py\n@@ -0,0 +1,80 @@\n+import unittest\n+import ast\n+import os\n+\n+class TestGetResolverLogging(unittest.TestCase):\n+\n+    def test_function_definition(self):\n+        # Path to the file containing get_resolver\n+        file_path = 'django/urls/resolvers.py'  \n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.FunctionDef) and node.name == 'get_resolver':\n+                # Check if the function has the correct arguments\n+                args = [arg.arg for arg in node.args.args]\n+                self.assertIn('urlconf', args, \"Missing 'urlconf' parameter\")\n+                \n+                # Check for the log parameter\n+                boolean_param = next(\n+                    (kw for kw in node.args.defaults if isinstance(kw, ast.NameConstant) and kw.value is False), \n+                    None\n+                )\n+                self.assertIsNotNone(boolean_param, \"Boolean parameter with default False is missing\")\n+                \n+                # Check the function body for a conditional based on this boolean parameter\n+                boolean_check = any(\n+                    isinstance(stmt, ast.If) and \n+                    isinstance(stmt.test, ast.Name) and \n+                    isinstance(stmt.test.ctx, ast.Load) and \n+                    any(arg for arg in node.args.args if arg.arg == stmt.test.id)\n+                    for stmt in node.body\n+                )\n+                self.assertTrue(boolean_check, \"Missing boolean check in function body\")\n+                \n+                return  # We found and checked the function, so we can stop here\n+\n+        self.fail(\"get_resolver function not found in the file\")\n+\n+    def test_usages_have_boolean_true(self):\n+        # List of files to check\n+        files_to_check = [\n+            'django/urls/base.py',\n+            'django/conf/urls/i18n.py',\n+            'django/core/checks/urls.py',\n+            'django/core/handlers/exception.py',\n+            'django/utils/autoreload.py',\n+            'django/contrib/admindocs/views.py',\n+            'django/core/handlers/base.py',\n+        ]\n+\n+        for file_path in files_to_check:\n+            with open(file_path, 'r') as f:\n+                tree = ast.parse(f.read())\n+\n+            for node in ast.walk(tree):\n+                if isinstance(node, ast.Call) and isinstance(node.func, ast.Name) and node.func.id == 'get_resolver':\n+                    boolean_arg = next((kw for kw in node.keywords if isinstance(kw.value, ast.NameConstant) and kw.value.value is True), None)\n+                    self.assertIsNotNone(boolean_arg, f\"Boolean parameter missing or not True in {file_path}\")\n+\n+    def test_usages_in_tests_have_boolean_false(self):\n+        # List of test files to check\n+        test_files_to_check = [\n+            'tests/urlpatterns/test_resolvers.py',\n+            'tests/urlpatterns_reverse/tests.py',\n+            'tests/view_tests/views.py',\n+        ]\n+\n+        for file_path in test_files_to_check:\n+            with open(file_path, 'r') as f:\n+                tree = ast.parse(f.read())\n+\n+            for node in ast.walk(tree):\n+                if isinstance(node, ast.Call) and isinstance(node.func, ast.Name) and node.func.id == 'get_resolver':\n+                    boolean_arg = next((kw for kw in node.keywords if isinstance(kw.value, ast.NameConstant) and kw.value.value is False), None)\n+                    self.assertIsNotNone(boolean_arg, f\"Boolean parameter missing or not False in {file_path}\")\n+\n+if __name__ == '__main__':\n+    unittest.main()",
    "problem_statement": "Change get_resolver to have a logging parameter that turns on log statements. Change all references to have the logging set as false.",
    "hints_text": "",
    "created_at": "2025-11-03 22:46:32+00:00",
    "language": "Python",
    "Dockerfile": "N/A",
    "test_command": "python3 -m unittest add-log-parameter-get-resolver-test.py",
    "task_category": "Refactoring",
    "data_source": "microsoft/RefactorBench",
    "scenario": "brownfield"
  },
  {
    "repo": "django/django",
    "url": "https://github.com/django/django",
    "instance_id": "add-none-handling-duration-string",
    "base_commit": "add-none-handling-duration-string",
    "patch": "N/A",
    "test_patch": "diff --git a/add-none-handling-duration-string-test.py b/add-none-handling-duration-string-test.py\nnew file mode 100644\nindex 0000000..65e042a\n--- /dev/null\n+++ b/add-none-handling-duration-string-test.py\n@@ -0,0 +1,130 @@\n+import unittest\n+import ast\n+import os\n+\n+class TestDurationStringHandling(unittest.TestCase):\n+\n+    def test_duration_string_none_handling(self):\n+        # Path to the file containing duration_string\n+        file_path = 'django/utils/duration.py'\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.FunctionDef) and node.name == 'duration_string':\n+                # Check the function body for None handling\n+                none_check = any(\n+                    isinstance(stmt, ast.If) and \n+                    isinstance(stmt.test, ast.Compare) and \n+                    isinstance(stmt.test.left, ast.Name) and \n+                    stmt.test.left.id == 'duration' and \n+                    isinstance(stmt.test.ops[0], ast.Is) and \n+                    isinstance(stmt.test.comparators[0], ast.Constant) and \n+                    stmt.test.comparators[0].value is None\n+                    for stmt in node.body\n+                )\n+                self.assertTrue(none_check, \"Missing None handling in duration_string function\")\n+                \n+                return  # We found and checked the function, so we can stop here\n+\n+        self.fail(\"duration_string function not found in the file\")\n+\n+    def test_value_to_string_none_check_removed(self):\n+        # Path to the file containing the DurationField class\n+        file_path = 'django/db/models/fields/__init__.py'\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        # Look for the DurationField class\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ClassDef) and node.name == 'DurationField':\n+                # Look for the value_to_string method within the DurationField class\n+                for class_node in node.body:\n+                    if isinstance(class_node, ast.FunctionDef) and class_node.name == 'value_to_string':\n+                        # Check if the None check is removed and if it directly returns duration_string(val)\n+                        none_check_removed = not any(\n+                            isinstance(stmt, ast.If) and \n+                            isinstance(stmt.test, ast.Compare) and \n+                            isinstance(stmt.test.left, ast.Name) and \n+                            stmt.test.left.id == 'val' and \n+                            isinstance(stmt.test.ops[0], ast.Is) and \n+                            isinstance(stmt.test.comparators[0], ast.Constant) and \n+                            stmt.test.comparators[0].value is None\n+                            for stmt in class_node.body\n+                        )\n+                        \n+                        direct_return = any(\n+                            isinstance(stmt, ast.Return) and \n+                            isinstance(stmt.value, ast.Call) and \n+                            isinstance(stmt.value.func, ast.Name) and \n+                            stmt.value.func.id == 'duration_string' and\n+                            isinstance(stmt.value.args[0], ast.Name) and\n+                            stmt.value.args[0].id == 'val'\n+                            for stmt in class_node.body\n+                        )\n+                        \n+                        # Assert that the None check was removed and it directly returns duration_string(val)\n+                        self.assertTrue(none_check_removed and direct_return, \n+                                        \"The function value_to_string in DurationField no longer handles None and directly returns duration_string(val).\")\n+                        \n+                        return  # We found and checked the function, so we can stop here\n+\n+        self.fail(\"DurationField class or value_to_string function not found in the file\")\n+\n+\n+    def test_named_none_test_in_TestDurationString(self):\n+        # Path to the test file containing TestDurationString\n+        test_file_path = 'tests/utils_tests/test_duration.py'\n+\n+        with open(test_file_path, 'r') as f:\n+            tree = ast.parse(f.read())\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ClassDef) and node.name == 'TestDurationString':\n+                # Check if there's a method named 'test_none'\n+                none_test = any(\n+                    isinstance(method, ast.FunctionDef) and \n+                    method.name == 'test_none'\n+                    for method in node.body\n+                )\n+                self.assertTrue(none_test, \"Missing 'test_none' method in TestDurationString class\")\n+\n+                return  # We found and checked the class, so we can stop here\n+\n+        self.fail(\"TestDurationString class not found in the test file\")\n+    \"\"\"\n+    def test_any_none_test_in_TestDurationString(self):\n+        # Path to the test file containing TestDurationString\n+        test_file_path = 'tests/utils_tests/test_duration.py'\n+\n+        with open(test_file_path, 'r') as f:\n+            tree = ast.parse(f.read())\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ClassDef) and node.name == 'TestDurationString':\n+                # Check if any test method contains an assert statement with an empty string\n+                empty_string_assert = any(\n+                    isinstance(method, ast.FunctionDef) and \n+                    any(\n+                        isinstance(stmt, (ast.Expr, ast.Assert)) and \n+                        isinstance(stmt.value, ast.Call) and\n+                        isinstance(stmt.value.func, ast.Name) and stmt.value.func.id.startswith('assert') and\n+                        any(\n+                            isinstance(arg, ast.Constant) and arg.value == \"\"\n+                            for arg in stmt.value.args\n+                        )\n+                        for stmt in method.body\n+                    )\n+                    for method in node.body\n+                )\n+                self.assertTrue(empty_string_assert, \"No test method asserts an empty string ('') in TestDurationString class\")\n+\n+                return  # We found and checked the class, so we can stop here\n+\n+        self.fail(\"TestDurationString class not found in the test file\")\n+    \"\"\"\n+\n+if __name__ == '__main__':\n+    unittest.main()",
    "problem_statement": "Add the none handling based on django/db/models/fields/__init__ to the duration string function in utils/duration so we can just call the function there. add a test_none in the appropriate place for the none handling too.",
    "hints_text": "",
    "created_at": "2025-11-03 22:46:32+00:00",
    "language": "Python",
    "Dockerfile": "N/A",
    "test_command": "python3 -m unittest add-none-handling-duration-string-test.py",
    "task_category": "Refactoring",
    "data_source": "microsoft/RefactorBench",
    "scenario": "brownfield"
  },
  {
    "repo": "django/django",
    "url": "https://github.com/django/django",
    "instance_id": "add-log-parameter-constant-time-compare",
    "base_commit": "add-log-parameter-constant-time-compare",
    "patch": "N/A",
    "test_patch": "diff --git a/add-log-parameter-constant-time-compare-test.py b/add-log-parameter-constant-time-compare-test.py\nnew file mode 100644\nindex 0000000..b285237\n--- /dev/null\n+++ b/add-log-parameter-constant-time-compare-test.py\n@@ -0,0 +1,75 @@\n+import unittest\n+import ast\n+import os\n+\n+class TestConstantTimeCompareLogging(unittest.TestCase):\n+\n+    def test_function_definition(self):\n+        # Path to the file containing constant_time_compare\n+        file_path = 'django/utils/crypto.py'\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.FunctionDef) and node.name == 'constant_time_compare':\n+                # Check if the function has the correct arguments\n+                args = [arg.arg for arg in node.args.args]\n+                self.assertIn('log', args, \"Missing 'log' parameter\")\n+                \n+                # Check for the log parameter default value\n+                boolean_param = next(\n+                    (kw for kw in node.args.defaults if isinstance(kw, ast.Constant) and kw.value is False), \n+                    None\n+                )\n+                self.assertIsNotNone(boolean_param, \"Boolean parameter 'log' with default False is missing\")\n+                \n+                # Check the function body for a conditional based on this boolean parameter\n+                boolean_check = any(\n+                    isinstance(stmt, ast.If) and \n+                    isinstance(stmt.test, ast.Name) and \n+                    stmt.test.id == 'log'\n+                    for stmt in node.body\n+                )\n+                self.assertTrue(boolean_check, \"Missing boolean check for 'log' in function body\")\n+                \n+                return  # We found and checked the function, so we can stop here\n+\n+        self.fail(\"constant_time_compare function not found in the file\")\n+\n+    def test_usages_have_boolean_true(self):\n+        # List of files to check\n+        files_to_check = [\n+            'django/contrib/auth/__init__.py',\n+            'django/contrib/auth/hashers.py',\n+            'django/contrib/auth/tokens.py',\n+            'django/core/signing.py',\n+            'django/middleware/csrf.py',\n+        ]\n+\n+        for file_path in files_to_check:\n+            with open(file_path, 'r') as f:\n+                tree = ast.parse(f.read())\n+\n+            for node in ast.walk(tree):\n+                if isinstance(node, ast.Call) and isinstance(node.func, ast.Name) and node.func.id == 'constant_time_compare':\n+                    boolean_arg = next((kw for kw in node.keywords if isinstance(kw.value, ast.Constant) and kw.value.value is True), None)\n+                    self.assertIsNotNone(boolean_arg, f\"Boolean parameter 'log' missing or not True in {file_path}\")\n+\n+    def test_usages_in_tests_have_boolean_false(self):\n+        # List of test files to check\n+        test_files_to_check = [\n+            'tests/utils_tests/test_crypto.py',\n+        ]\n+\n+        for file_path in test_files_to_check:\n+            with open(file_path, 'r') as f:\n+                tree = ast.parse(f.read())\n+\n+            for node in ast.walk(tree):\n+                if isinstance(node, ast.Call) and isinstance(node.func, ast.Name) and node.func.id == 'constant_time_compare':\n+                    boolean_arg = next((kw for kw in node.keywords if isinstance(kw.value, ast.Constant) and kw.value.value is False), None)\n+                    self.assertIsNotNone(boolean_arg, f\"Boolean parameter 'log' missing or not False in {file_path}\")\n+\n+if __name__ == '__main__':\n+    unittest.main()",
    "problem_statement": "Add logging to the constant_time_compare function with a boolean parameter and update the codebase accordingly. Keep log as false base in the function, but make it true throughout instances in the code except for the test suite.",
    "hints_text": "",
    "created_at": "2025-11-03 22:46:32+00:00",
    "language": "Python",
    "Dockerfile": "N/A",
    "test_command": "python3 -m unittest add-log-parameter-constant-time-compare-test.py",
    "task_category": "Refactoring",
    "data_source": "microsoft/RefactorBench",
    "scenario": "brownfield"
  },
  {
    "repo": "django/django",
    "url": "https://github.com/django/django",
    "instance_id": "add-log-parameter-resolve-error-handler",
    "base_commit": "add-log-parameter-resolve-error-handler",
    "patch": "N/A",
    "test_patch": "diff --git a/add-log-parameter-resolve-error-handler-test.py b/add-log-parameter-resolve-error-handler-test.py\nnew file mode 100644\nindex 0000000..2759b27\n--- /dev/null\n+++ b/add-log-parameter-resolve-error-handler-test.py\n@@ -0,0 +1,84 @@\n+import unittest\n+import ast\n+\n+\n+class TestResolveErrorHandler(unittest.TestCase):\n+    \n+    '''\n+    def test_function_definition(self):\n+        self.assertTrue(hasattr(URLResolver, 'resolve_error_handler'), \"URLResolver class does not have resolve_error_handler method\")\n+        \n+        method = getattr(URLResolver, 'resolve_error_handler')\n+        \n+        # Print diagnostic information\n+        print(f\"Django version: {django.__version__}\")\n+        print(f\"URLResolver module: {URLResolver.__module__}\")\n+        print(f\"Method: {method}\")\n+        print(f\"Method source:\\n{inspect.getsource(method)}\")\n+        \n+        signature = inspect.signature(method)\n+        print(f\"Signature: {signature}\")\n+        \n+        # Check if 'log' parameter exists\n+        if 'log' in signature.parameters:\n+            self.assertEqual(signature.parameters['log'].default, False, \"log parameter default value should be False\")\n+        else:\n+            # If 'log' is not in the signature, fail the test and show the actual parameters\n+            self.fail(f\"log parameter is missing in the function definition. Actual parameters: {list(signature.parameters.keys())}\")\n+    '''\n+\n+    def test_function_def(self):\n+        file_path = 'django/urls/resolvers.py'  \n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.FunctionDef) and node.name == 'resolve_error_handler':\n+                # Check if the function has the correct arguments\n+                args = [arg.arg for arg in node.args.args]\n+                self.assertIn('self', args, \"Missing 'self' parameter\")\n+                self.assertIn('view_type', args, \"Missing 'view_type' parameter\")\n+                \n+                # Check for the log parameter\n+                log_param = next((kw for kw in node.args.defaults if isinstance(kw, ast.NameConstant) and kw.value is False), None)\n+                self.assertIsNotNone(log_param, \"log parameter with default False is missing\")\n+                \n+                # Check the function body for log-related code\n+                log_check = any(\n+                    isinstance(stmt, ast.If) and \n+                    isinstance(stmt.test, ast.Name) and \n+                    stmt.test.id == 'log'\n+                    for stmt in node.body\n+                )\n+                self.assertTrue(log_check, \"Missing log check in function body\")\n+                \n+                return  \n+\n+        self.fail(\"resolve_error_handler function not found in the file\")\n+\n+    def test_usages_have_log_true(self):\n+        files_to_check = [\n+            'django/core/handlers/exception.py',\n+            'django/core/checks/urls.py',\n+            'tests/urlpatterns_reverse/tests.py',\n+        ]\n+\n+        for file_path in files_to_check:\n+            with open(file_path, 'r') as f:\n+                tree = ast.parse(f.read())\n+\n+            for node in ast.walk(tree):\n+                if isinstance(node, ast.Call) and isinstance(node.func, ast.Attribute):\n+                    if node.func.attr == 'resolve_error_handler':\n+                        if isinstance(node.func.value, ast.Name) and node.func.value.id in ['resolver', 'self', 'url_resolver']:\n+                            log_arg = next((kw for kw in node.keywords if kw.arg == 'log'), None)\n+                            self.assertIsNotNone(log_arg, f\"log parameter missing in {file_path}\")\n+                            self.assertTrue(\n+                                isinstance(log_arg.value, ast.NameConstant) and log_arg.value.value is True,\n+                                f\"log is not True in {file_path}\"\n+                            )\n+                            self.assertTrue(len(node.args) > 0, f\"Missing status_code argument in {file_path}\")\n+\n+if __name__ == '__main__':\n+    unittest.main()\n\\ No newline at end of file",
    "problem_statement": "Change resolve_error_handler to have a logging parameter that turns on log statements. Change all references to have the logging set as false.",
    "hints_text": "",
    "created_at": "2025-11-03 22:46:32+00:00",
    "language": "Python",
    "Dockerfile": "N/A",
    "test_command": "python3 -m unittest add-log-parameter-resolve-error-handler-test.py",
    "task_category": "Refactoring",
    "data_source": "microsoft/RefactorBench",
    "scenario": "brownfield"
  },
  {
    "repo": "django/django",
    "url": "https://github.com/django/django",
    "instance_id": "new-path-traversal-exception",
    "base_commit": "new-path-traversal-exception",
    "patch": "N/A",
    "test_patch": "diff --git a/new-path-traversal-exception-test.py b/new-path-traversal-exception-test.py\nnew file mode 100644\nindex 0000000..3a09c3a\n--- /dev/null\n+++ b/new-path-traversal-exception-test.py\n@@ -0,0 +1,217 @@\n+import unittest\n+import ast\n+\n+class TestPathTraversalException(unittest.TestCase):\n+\n+    def test_pathtraversal_exception_exists(self):\n+        # Path to the file where PathTraversal is defined\n+        file_path = 'django/core/exceptions.py'\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        # Check if the PathTraversal class is defined\n+        class_exists = any(\n+            isinstance(node, ast.ClassDef) and node.name == 'PathTraversal'\n+            for node in ast.walk(tree)\n+        )\n+        self.assertTrue(class_exists, \"PathTraversal exception class is not defined\")\n+\n+    def test_pathtraversal_extends_suspiciousoperation(self):\n+        # Path to the file where PathTraversal is defined\n+        file_path = 'django/core/exceptions.py'\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ClassDef) and node.name == 'PathTraversal':\n+                # Check if PathTraversal extends SuspiciousOperation\n+                bases = [base.id for base in node.bases if isinstance(base, ast.Name)]\n+                self.assertIn('SuspiciousOperation', bases, \"PathTraversal does not extend SuspiciousOperation\")\n+                return  # We found and checked the class, so we can stop here\n+\n+        self.fail(\"PathTraversal class not found in the file\")\n+\n+    def test_get_available_name_raises_pathtraversal(self):\n+        # Path to the file containing the Storage class\n+        file_path = 'django/core/files/storage/base.py'\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ClassDef) and node.name == 'Storage':\n+                for subnode in node.body:\n+                    if isinstance(subnode, ast.FunctionDef) and subnode.name == 'get_available_name':\n+                        # Check within all If statements for a raise statement with PathTraversal\n+                        raise_check = any(\n+                            isinstance(stmt, ast.If) and\n+                            any(\n+                                isinstance(substmt, ast.Raise) and\n+                                isinstance(substmt.exc, ast.Call) and\n+                                isinstance(substmt.exc.func, ast.Name) and\n+                                substmt.exc.func.id == 'PathTraversal'\n+                                for substmt in stmt.body\n+                            )\n+                            for stmt in subnode.body\n+                        )\n+                        self.assertTrue(raise_check, \"PathTraversal exception is not raised in get_available_name\")\n+                        return  # We found and checked the function, so we can stop here\n+\n+        self.fail(\"get_available_name function not found in the Storage class\")\n+\n+    def test_generate_filename_raises_pathtraversal(self):\n+        # Path to the file containing the Storage class\n+        file_path = 'django/core/files/storage/base.py'\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ClassDef) and node.name == 'Storage':\n+                for subnode in node.body:\n+                    if isinstance(subnode, ast.FunctionDef) and subnode.name == 'generate_filename':\n+                        # Check within all If statements for a raise statement with PathTraversal\n+                        raise_check = any(\n+                            isinstance(stmt, ast.If) and\n+                            any(\n+                                isinstance(substmt, ast.Raise) and\n+                                isinstance(substmt.exc, ast.Call) and\n+                                isinstance(substmt.exc.func, ast.Name) and\n+                                substmt.exc.func.id == 'PathTraversal'\n+                                for substmt in stmt.body\n+                            )\n+                            for stmt in subnode.body\n+                        )\n+                        self.assertTrue(raise_check, \"PathTraversal exception is not raised in generate_filename\")\n+                        return  # We found and checked the function, so we can stop here\n+\n+        self.fail(\"generate_filename function not found in the Storage class\")\n+\n+\n+    def test_usages_of_get_available_name_raise_exceptions(self):\n+        # List of files to check for usages of get_available_name\n+        files_to_check = [\n+            'tests/file_storage/test_generate_filename.py',\n+            # Add more file paths as needed\n+        ]\n+\n+        for file_path in files_to_check:\n+            with open(file_path, 'r') as f:\n+                tree = ast.parse(f.read())\n+\n+            for node in ast.walk(tree):\n+                if isinstance(node, ast.Call) and isinstance(node.func, ast.Name) and node.func.id == 'get_available_name':\n+                    # Ensure that the usage is within a try-except block that catches either PathTraversal or SuspiciousFileOperation\n+                    try_except_check_pathtraversal = any(\n+                        isinstance(parent, ast.Try) and \n+                        any(isinstance(handler.type, ast.Name) and handler.type.id == 'PathTraversal' for handler in parent.handlers)\n+                        for parent in ast.iter_parent_nodes(tree, node)\n+                    )\n+\n+                    try_except_check_suspiciousfile = any(\n+                        isinstance(parent, ast.Try) and \n+                        any(isinstance(handler.type, ast.Name) and handler.type.id == 'SuspiciousFileOperation' for handler in parent.handlers)\n+                        for parent in ast.iter_parent_nodes(tree, node)\n+                    )\n+\n+                    self.assertTrue(\n+                        try_except_check_pathtraversal or try_except_check_suspiciousfile, \n+                        f\"Neither PathTraversal nor SuspiciousFileOperation is caught in usage of get_available_name in {file_path}\"\n+                    )\n+\n+    def test_usages_of_generate_filename_raise_pathtraversal(self):\n+        # List of files to check for usages of generate_filename\n+        files_to_check = [\n+            'tests/file_storage/test_generate_filename.py',\n+            # Add more file paths as needed\n+        ]\n+\n+        for file_path in files_to_check:\n+            with open(file_path, 'r') as f:\n+                tree = ast.parse(f.read())\n+\n+            for node in ast.walk(tree):\n+                if isinstance(node, ast.Call) and isinstance(node.func, ast.Name) and node.func.id == 'generate_filename':\n+                    # Ensure that the usage is within a try-except block that catches PathTraversal\n+                    try_except_check = any(\n+                        isinstance(parent, ast.Try) and \n+                        any(isinstance(handler.type, ast.Name) and handler.type.id == 'PathTraversal' for handler in parent.handlers)\n+                        for parent in ast.iter_parent_nodes(tree, node)\n+                    )\n+                    self.assertTrue(try_except_check, f\"PathTraversal is not caught in usage of generate_filename in {file_path}\")\n+\n+    def test_safe_join_calls_pathtraversal(self):\n+        # Path to the file containing safe_join\n+        file_path = 'django/utils/_os.py'\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.FunctionDef) and node.name == 'safe_join':\n+                # Check within all If statements for a raise statement with PathTraversal\n+                raise_check = any(\n+                    isinstance(stmt, ast.If) and\n+                    any(\n+                        isinstance(substmt, ast.Raise) and\n+                        isinstance(substmt.exc, ast.Call) and\n+                        isinstance(substmt.exc.func, ast.Name) and\n+                        substmt.exc.func.id == 'PathTraversal'\n+                        for substmt in stmt.body\n+                    )\n+                    for stmt in node.body\n+                )\n+                self.assertTrue(raise_check, \"PathTraversal exception is not raised in safe_join\")\n+                return  # We found and checked the function, so we can stop here\n+\n+        self.fail(\"safe_join function not found in the file\")\n+\n+\n+    def test_pathtraversal_in_exceptions_docs(self):\n+        # Path to the docs file where exceptions are listed\n+        file_path = 'docs/ref/exceptions.txt'\n+\n+        with open(file_path, 'r') as file:\n+            content = file.read()\n+\n+        # Check if 'PathTraversal' is mentioned in the file\n+        self.assertIn('PathTraversal', content, \"PathTraversal is not mentioned in docs/ref/exceptions.txt\")\n+\n+    def test_os_utils_tests_imports_and_uses_pathtraversal(self):\n+        # Path to the tests/utils_tests/test_os_utils.py file\n+        file_path = 'tests/utils_tests/test_os_utils.py'\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        # Check if PathTraversal is imported\n+        import_exists = any(\n+            isinstance(node, ast.ImportFrom) and \n+            any(alias.name == 'PathTraversal' for alias in node.names)\n+            for node in ast.walk(tree)\n+        )\n+        self.assertTrue(import_exists, \"PathTraversal is not imported in /tests/utils_tests/test_os_utils.py\")\n+\n+        pathtraversal_assert_raises = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ClassDef) and node.name == 'SafeJoinTests':\n+                for subnode in node.body:\n+                    if isinstance(subnode, ast.FunctionDef):\n+                        # Look for self.assertRaises(PathTraversal)\n+                        for stmt in ast.walk(subnode):\n+                            if isinstance(stmt, ast.Call) and \\\n+                               isinstance(stmt.func, ast.Attribute) and \\\n+                               stmt.func.attr == 'assertRaises' and \\\n+                               isinstance(stmt.args[0], ast.Name) and \\\n+                               stmt.args[0].id == 'PathTraversal':\n+                                pathtraversal_assert_raises = True\n+                                break\n+\n+        self.assertTrue(pathtraversal_assert_raises, \"self.assertRaises(PathTraversal) is not found in SafeJoinTests in /tests/utils_tests/test_os_utils.py\")\n+\n+\n+if __name__ == '__main__':\n+    unittest.main()",
    "problem_statement": "add a new PathTraversal exception that extends the suspicious operation exception and replaces some of the SuspiciousFileOperation calls. Update the repository accordingly",
    "hints_text": "",
    "created_at": "2025-11-03 22:46:32+00:00",
    "language": "Python",
    "Dockerfile": "N/A",
    "test_command": "python3 -m unittest new-path-traversal-exception-test.py",
    "task_category": "Refactoring",
    "data_source": "microsoft/RefactorBench",
    "scenario": "brownfield"
  },
  {
    "repo": "django/django",
    "url": "https://github.com/django/django",
    "instance_id": "new-converter-to-python-class",
    "base_commit": "new-converter-to-python-class",
    "patch": "N/A",
    "test_patch": "diff --git a/new-converter-to-python-class-test.py b/new-converter-to-python-class-test.py\nnew file mode 100644\nindex 0000000..5b9e2de\n--- /dev/null\n+++ b/new-converter-to-python-class-test.py\n@@ -0,0 +1,74 @@\n+import unittest\n+import os\n+import ast\n+\n+class TestBackendsUtils(unittest.TestCase):\n+\n+    def test_converter_to_python_class_exists(self):\n+        # Path to the file containing ConverterToPython\n+        file_path = 'django/db/backends/utils.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Check if the ConverterToPython class is defined\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        class_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ClassDef) and node.name == 'ConverterToPython':\n+                class_found = True\n+                break\n+\n+        self.assertTrue(class_found, \"Class 'ConverterToPython' not found in backends/utils.py\")\n+\n+    def test_converter_to_python_functions(self):\n+        # Path to the file containing ConverterToPython\n+        file_path = 'django/db/backends/utils.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Check if the required functions are defined in ConverterToPython class\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        functions = ['typecast_date', 'typecast_time', 'typecast_timestamp']\n+        functions_found = {func: False for func in functions}\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ClassDef) and node.name == 'ConverterToPython':\n+                for class_node in ast.walk(node):\n+                    if isinstance(class_node, ast.FunctionDef) and class_node.name in functions_found:\n+                        functions_found[class_node.name] = True\n+\n+        for func, found in functions_found.items():\n+            self.assertTrue(found, f\"Function '{func}' not found in ConverterToPython class\")\n+\n+    def test_converter_to_python_imports(self):\n+        files_to_test = [\n+            \"../django/db/backends/sqlite3/_functions.py\",\n+            \"../django/db/backends/mysql/base.py\",\n+        ]\n+\n+        for file_path in files_to_test:\n+            if not os.path.exists(file_path):\n+                print(f\"File {file_path} not found.\")\n+                continue\n+\n+            with open(file_path, 'r') as file:\n+                tree = ast.parse(file.read())\n+\n+            import_found = False\n+            for node in ast.walk(tree):\n+                if isinstance(node, ast.ImportFrom):\n+                    if node.module == 'django.db.backends.utils' and \\\n+                       any(alias.name == 'ConverterToPython' for alias in node.names):\n+                        import_found = True\n+                        break\n+\n+            self.assertTrue(import_found, f\"Import 'ConverterToPython' not found in {file_path}\")\n+\n+if __name__ == '__main__':\n+    unittest.main()",
    "problem_statement": "Add a ConverterToPython class to the utils.py in django/db/backends for the functions that go from string to python. Update the repo accordingly",
    "hints_text": "",
    "created_at": "2025-11-03 22:46:32+00:00",
    "language": "Python",
    "Dockerfile": "N/A",
    "test_command": "python3 -m unittest new-converter-to-python-class-test.py",
    "task_category": "Refactoring",
    "data_source": "microsoft/RefactorBench",
    "scenario": "brownfield"
  },
  {
    "repo": "django/django",
    "url": "https://github.com/django/django",
    "instance_id": "remove-db-models-constants",
    "base_commit": "remove-db-models-constants",
    "patch": "N/A",
    "test_patch": "diff --git a/remove-db-models-constants-test.py b/remove-db-models-constants-test.py\nnew file mode 100644\nindex 0000000..42993ed\n--- /dev/null\n+++ b/remove-db-models-constants-test.py\n@@ -0,0 +1,294 @@\n+import unittest\n+import os\n+import ast\n+\n+class TestORMConstantsMigration(unittest.TestCase):\n+\n+    def test_admin_checks_import(self):\n+        file_path = 'django/contrib/admin/checks.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        imports_updated = any(\n+            isinstance(node, ast.ImportFrom) and \n+            node.module == 'django.db.models.base' and \n+            any(alias.name == 'LOOKUP_SEP' or alias.name == 'OnConflict' for alias in node.names)\n+            for node in ast.walk(tree)\n+        )\n+        self.assertTrue(imports_updated, f\"Imports of 'LOOKUP_SEP' or 'OnConflict' not updated to 'base' in {file_path}\")\n+\n+    def test_admin_options_import(self):\n+        file_path = 'django/contrib/admin/options.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        imports_updated = any(\n+            isinstance(node, ast.ImportFrom) and \n+            node.module == 'django.db.models.base' and \n+            any(alias.name == 'LOOKUP_SEP' or alias.name == 'OnConflict' for alias in node.names)\n+            for node in ast.walk(tree)\n+        )\n+        self.assertTrue(imports_updated, f\"Imports of 'LOOKUP_SEP' or 'OnConflict' not updated to 'base' in {file_path}\")\n+\n+    def test_admin_templatetags_import(self):\n+        file_path = 'django/contrib/admin/templatetags/admin_list.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        imports_updated = any(\n+            isinstance(node, ast.ImportFrom) and \n+            node.module == 'django.db.models.base' and \n+            any(alias.name == 'LOOKUP_SEP' or alias.name == 'OnConflict' for alias in node.names)\n+            for node in ast.walk(tree)\n+        )\n+        self.assertTrue(imports_updated, f\"Imports of 'LOOKUP_SEP' or 'OnConflict' not updated to 'base' in {file_path}\")\n+\n+    def test_admin_utils_import(self):\n+        file_path = 'django/contrib/admin/utils.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        imports_updated = any(\n+            isinstance(node, ast.ImportFrom) and \n+            node.module == 'django.db.models.base' and \n+            any(alias.name == 'LOOKUP_SEP' or alias.name == 'OnConflict' for alias in node.names)\n+            for node in ast.walk(tree)\n+        )\n+        self.assertTrue(imports_updated, f\"Imports of 'LOOKUP_SEP' or 'OnConflict' not updated to 'base' in {file_path}\")\n+\n+    def test_admin_views_main_import(self):\n+        file_path = 'django/contrib/admin/views/main.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        imports_updated = any(\n+            isinstance(node, ast.ImportFrom) and \n+            node.module == 'django.db.models.base' and \n+            any(alias.name == 'LOOKUP_SEP' or alias.name == 'OnConflict' for alias in node.names)\n+            for node in ast.walk(tree)\n+        )\n+        self.assertTrue(imports_updated, f\"Imports of 'LOOKUP_SEP' or 'OnConflict' not updated to 'base' in {file_path}\")\n+\n+    def test_core_management_commands_inspectdb_import(self):\n+        file_path = 'django/core/management/commands/inspectdb.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        imports_updated = any(\n+            isinstance(node, ast.ImportFrom) and \n+            node.module == 'django.db.models.base' and \n+            any(alias.name == 'LOOKUP_SEP' or alias.name == 'OnConflict' for alias in node.names)\n+            for node in ast.walk(tree)\n+        )\n+        self.assertTrue(imports_updated, f\"Imports of 'LOOKUP_SEP' or 'OnConflict' not updated to 'base' in {file_path}\")\n+\n+    def test_mysql_operations_import(self):\n+        file_path = 'django/db/backends/mysql/operations.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        imports_updated = any(\n+            isinstance(node, ast.ImportFrom) and \n+            node.module == 'django.db.models.base' and \n+            any(alias.name == 'LOOKUP_SEP' or alias.name == 'OnConflict' for alias in node.names)\n+            for node in ast.walk(tree)\n+        )\n+        self.assertTrue(imports_updated, f\"Imports of 'LOOKUP_SEP' or 'OnConflict' not updated to 'base' in {file_path}\")\n+\n+    def test_mysql_schema_import(self):\n+        file_path = 'django/db/backends/mysql/schema.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        imports_updated = any(\n+            isinstance(node, ast.ImportFrom) and \n+            node.module == 'django.db.models.base' and \n+            any(alias.name == 'LOOKUP_SEP' or alias.name == 'OnConflict' for alias in node.names)\n+            for node in ast.walk(tree)\n+        )\n+        self.assertTrue(imports_updated, f\"Imports of 'LOOKUP_SEP' or 'OnConflict' not updated to 'base' in {file_path}\")\n+\n+    def test_postgresql_operations_import(self):\n+        file_path = 'django/db/backends/postgresql/operations.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        imports_updated = any(\n+            isinstance(node, ast.ImportFrom) and \n+            node.module == 'django.db.models.base' and \n+            any(alias.name == 'LOOKUP_SEP' or alias.name == 'OnConflict' for alias in node.names)\n+            for node in ast.walk(tree)\n+        )\n+        self.assertTrue(imports_updated, f\"Imports of 'LOOKUP_SEP' or 'OnConflict' not updated to 'base' in {file_path}\")\n+\n+    def test_sqlite3_operations_import(self):\n+        file_path = 'django/db/backends/sqlite3/operations.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        imports_updated = any(\n+            isinstance(node, ast.ImportFrom) and \n+            node.module == 'django.db.models.base' and \n+            any(alias.name == 'LOOKUP_SEP' or alias.name == 'OnConflict' for alias in node.names)\n+            for node in ast.walk(tree)\n+        )\n+        self.assertTrue(imports_updated, f\"Imports of 'LOOKUP_SEP' or 'OnConflict' not updated to 'base' in {file_path}\")\n+\n+    def test_constraints_import(self):\n+        file_path = 'django/db/models/constraints.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        imports_updated = any(\n+            isinstance(node, ast.ImportFrom) and \n+            node.module == 'django.db.models.base' and \n+            any(alias.name == 'LOOKUP_SEP' or alias.name == 'OnConflict' for alias in node.names)\n+            for node in ast.walk(tree)\n+        )\n+        self.assertTrue(imports_updated, f\"Imports of 'LOOKUP_SEP' or 'OnConflict' not updated to 'base' in {file_path}\")\n+\n+    def test_expressions_import(self):\n+        file_path = 'django/db/models/expressions.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        imports_updated = any(\n+            isinstance(node, ast.ImportFrom) and \n+            node.module == 'django.db.models.base' and \n+            any(alias.name == 'LOOKUP_SEP' or alias.name == 'OnConflict' for alias in node.names)\n+            for node in ast.walk(tree)\n+        )\n+        self.assertTrue(imports_updated, f\"Imports of 'LOOKUP_SEP' or 'OnConflict' not updated to 'base' in {file_path}\")\n+\n+    def test_fields_init_import(self):\n+        file_path = 'django/db/models/fields/__init__.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        imports_updated = any(\n+            isinstance(node, ast.ImportFrom) and \n+            node.module == 'django.db.models.base' and \n+            any(alias.name == 'LOOKUP_SEP' or alias.name == 'OnConflict' for alias in node.names)\n+            for node in ast.walk(tree)\n+        )\n+        self.assertTrue(imports_updated, f\"Imports of 'LOOKUP_SEP' or 'OnConflict' not updated to 'base' in {file_path}\")\n+\n+    def test_fields_json_import(self):\n+        file_path = 'django/db/models/fields/json.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        imports_updated = any(\n+            isinstance(node, ast.ImportFrom) and \n+            node.module == 'django.db.models.base' and \n+            any(alias.name == 'LOOKUP_SEP' or alias.name == 'OnConflict' for alias in node.names)\n+            for node in ast.walk(tree)\n+        )\n+        self.assertTrue(imports_updated, f\"Imports of 'LOOKUP_SEP' or 'OnConflict' not updated to 'base' in {file_path}\")\n+\n+    def test_fields_related_import(self):\n+        file_path = 'django/db/models/fields/related.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        imports_updated = any(\n+            isinstance(node, ast.ImportFrom) and \n+            node.module == 'django.db.models.base' and \n+            any(alias.name == 'LOOKUP_SEP' or alias.name == 'OnConflict' for alias in node.names)\n+            for node in ast.walk(tree)\n+        )\n+        self.assertTrue(imports_updated, f\"Imports of 'LOOKUP_SEP' or 'OnConflict' not updated to 'base' in {file_path}\")\n+\n+    def test_query_import(self):\n+        file_path = 'django/db/models/query.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        imports_updated = any(\n+            isinstance(node, ast.ImportFrom) and \n+            node.module == 'django.db.models.base' and \n+            any(alias.name == 'LOOKUP_SEP' or alias.name == 'OnConflict' for alias in node.names)\n+            for node in ast.walk(tree)\n+        )\n+        self.assertTrue(imports_updated, f\"Imports of 'LOOKUP_SEP' or 'OnConflict' not updated to 'base' in {file_path}\")\n+\n+    def test_query_utils_import(self):\n+        file_path = 'django/db/models/query_utils.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        imports_updated = any(\n+            isinstance(node, ast.ImportFrom) and \n+            node.module == 'django.db.models.base' and \n+            any(alias.name == 'LOOKUP_SEP' or alias.name == 'OnConflict' for alias in node.names)\n+            for node in ast.walk(tree)\n+        )\n+        self.assertTrue(imports_updated, f\"Imports of 'LOOKUP_SEP' or 'OnConflict' not updated to 'base' in {file_path}\")\n+\n+    def test_sql_compiler_import(self):\n+        file_path = 'django/db/models/sql/compiler.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        imports_updated = any(\n+            isinstance(node, ast.ImportFrom) and \n+            node.module == 'django.db.models.base' and \n+            any(alias.name == 'LOOKUP_SEP' or alias.name == 'OnConflict' for alias in node.names)\n+            for node in ast.walk(tree)\n+        )\n+        self.assertTrue(imports_updated, f\"Imports of 'LOOKUP_SEP' or 'OnConflict' not updated to 'base' in {file_path}\")\n+\n+    def test_sql_query_import(self):\n+        file_path = 'django/db/models/sql/query.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        imports_updated = any(\n+            isinstance(node, ast.ImportFrom) and \n+            node.module == 'django.db.models.base' and \n+            any(alias.name == 'LOOKUP_SEP' or alias.name == 'OnConflict' for alias in node.names)\n+            for node in ast.walk(tree)\n+        )\n+        self.assertTrue(imports_updated, f\"Imports of 'LOOKUP_SEP' or 'OnConflict' not updated to 'base' in {file_path}\")\n+\n+if __name__ == '__main__':\n+    unittest.main()\n+",
    "problem_statement": "remove all the content in django/db/models/constants and put it in base and update the repo accordingly",
    "hints_text": "",
    "created_at": "2025-11-03 22:46:32+00:00",
    "language": "Python",
    "Dockerfile": "N/A",
    "test_command": "python3 -m unittest remove-db-models-constants-test.py",
    "task_category": "Refactoring",
    "data_source": "microsoft/RefactorBench",
    "scenario": "brownfield"
  },
  {
    "repo": "django/django",
    "url": "https://github.com/django/django",
    "instance_id": "new-reference-context-graph-class",
    "base_commit": "new-reference-context-graph-class",
    "patch": "N/A",
    "test_patch": "diff --git a/new-reference-context-graph-class-test.py b/new-reference-context-graph-class-test.py\nnew file mode 100644\nindex 0000000..461c963\n--- /dev/null\n+++ b/new-reference-context-graph-class-test.py\n@@ -0,0 +1,119 @@\n+import unittest\n+import ast\n+\n+class TestReferenceContextInAddDependency(unittest.TestCase):\n+\n+    def test_reference_context_import_in_loader(self):\n+        file_path = 'django/db/migrations/loader.py'\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        import_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom) or isinstance(node, ast.Import):\n+                if any(alias.name == 'ReferenceContext' for alias in node.names):\n+                    import_found = True\n+                    break\n+\n+        self.assertTrue(import_found, f\"ReferenceContext not imported in {file_path}\")\n+\n+    def test_reference_context_import_in_executor(self):\n+        file_path = 'tests/migrations/test_executor.py'\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        import_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom) or isinstance(node, ast.Import):\n+                if any(alias.name == 'ReferenceContext' for alias in node.names):\n+                    import_found = True\n+                    break\n+\n+        self.assertTrue(import_found, f\"ReferenceContext not imported in {file_path}\")\n+    \n+    def test_reference_context_import_in_graph(self):\n+        file_path = 'tests/migrations/test_graph.py'\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        import_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom) or isinstance(node, ast.Import):\n+                if any(alias.name == 'ReferenceContext' for alias in node.names):\n+                    import_found = True\n+                    break\n+\n+        self.assertTrue(import_found, f\"ReferenceContext not imported in {file_path}\")\n+\n+    def test_reference_context_import_in_autodetector(self):\n+        file_path = 'tests/migrations/test_autodetector.py'\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        import_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom) or isinstance(node, ast.Import):\n+                if any(alias.name == 'ReferenceContext' for alias in node.names):\n+                    import_found = True\n+                    break\n+\n+        self.assertTrue(import_found, f\"ReferenceContext not imported in {file_path}\")\n+    \n+    def test_reference_context_import_not_in_deletion(self):\n+        file_path = 'django/db/models/deletion.py'\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        import_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom) or isinstance(node, ast.Import):\n+                if any(alias.name == 'ReferenceContext' for alias in node.names):\n+                    import_found = True\n+                    break\n+\n+        self.assertFalse(import_found, f\"ReferenceContext should not be imported in {file_path}\")\n+\n+    def test_add_dependency_uses_reference_context_in_loader(self):\n+        file_path = 'django/db/migrations/loader.py'\n+        self._check_reference_context_usage(file_path)\n+\n+    def test_add_dependency_uses_reference_context_in_executor(self):\n+        file_path = 'tests/migrations/test_executor.py'\n+        self._check_reference_context_usage(file_path)\n+\n+    def test_add_dependency_uses_reference_context_in_graph(self):\n+        file_path = 'tests/migrations/test_graph.py'\n+        self._check_reference_context_usage(file_path)\n+\n+    def test_add_dependency_uses_reference_context_in_autodetector(self):\n+        file_path = 'tests/migrations/test_autodetector.py'\n+        self._check_reference_context_usage(file_path)\n+\n+    def _check_reference_context_usage(self, file_path):\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        class_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ClassDef):\n+                class_found = True\n+                for method in node.body:\n+                    if isinstance(method, ast.FunctionDef) and method.name == 'add_dependency':\n+                        self._check_reference_context_in_function(method, file_path, node.name)\n+\n+        if not class_found:\n+            self.fail(f\"No classes found in {file_path}\")\n+\n+    def _check_reference_context_in_function(self, function_node, file_path, class_name):\n+        reference_context_found = False\n+        for inner_node in ast.walk(function_node):\n+            if isinstance(inner_node, ast.Call):\n+                if isinstance(inner_node.func, ast.Name) and inner_node.func.id == 'ReferenceContext':\n+                    reference_context_found = True\n+                elif isinstance(inner_node.func, ast.Attribute) and inner_node.func.attr == 'ReferenceContext':\n+                    reference_context_found = True\n+\n+        self.assertTrue(reference_context_found, f\"ReferenceContext not used in add_dependency method in class {class_name} in {file_path}\")\n+\n+if __name__ == '__main__':\n+    unittest.main()",
    "problem_statement": "Create a ReferenceContext class inside /django/db/migrations/graph for all the parameters in add_dependency. Use this class in all calls to add_dependency.",
    "hints_text": "",
    "created_at": "2025-11-03 22:46:32+00:00",
    "language": "Python",
    "Dockerfile": "N/A",
    "test_command": "python3 -m unittest new-reference-context-graph-class-test.py",
    "task_category": "Refactoring",
    "data_source": "microsoft/RefactorBench",
    "scenario": "brownfield"
  },
  {
    "repo": "django/django",
    "url": "https://github.com/django/django",
    "instance_id": "new-utils-adapt-method-mode",
    "base_commit": "new-utils-adapt-method-mode",
    "patch": "N/A",
    "test_patch": "diff --git a/new-utils-adapt-method-mode-test.py b/new-utils-adapt-method-mode-test.py\nnew file mode 100644\nindex 0000000..3f11f37\n--- /dev/null\n+++ b/new-utils-adapt-method-mode-test.py\n@@ -0,0 +1,67 @@\n+import unittest\n+import ast\n+import os\n+\n+class TestAdaptMethodMode(unittest.TestCase):\n+\n+    def test_function_definition(self):\n+        # Path to the utils.py file containing adapt_method_mode\n+        file_path = 'django/core/handlers/handler_utils.py'  # Adjust this path to the actual location of your utils.py\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.FunctionDef) and node.name == 'adapt_method_mode':\n+                # Check if the function has the correct arguments\n+                args = [arg.arg for arg in node.args.args]\n+                self.assertIn('is_async', args, \"Missing 'is_async' parameter\")\n+                self.assertIn('method', args, \"Missing 'method' parameter\")\n+                \n+                # Check for optional parameters\n+                optional_args = {'method_is_async', 'debug', 'name'}\n+                self.assertTrue(optional_args.issubset(args), \"Missing one or more optional parameters\")\n+                \n+                return  # We found and checked the function, so we can stop here\n+\n+        self.fail(\"adapt_method_mode function not found in the file\")\n+\n+    def test_import_in_base_handler(self):\n+        # Path to the base.py file\n+        file_path = 'django/core/handlers/base.py'  # Adjust this path to the actual location of your base.py\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        # Check if adapt_method_mode is imported\n+        import_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom) and node.module == 'handler_utils':\n+                for alias in node.names:\n+                    if alias.name == 'adapt_method_mode':\n+                        import_found = True\n+                        break\n+\n+        self.assertTrue(import_found, \"adapt_method_mode not imported from utils in base.py\")\n+\n+    def test_asgiref_imports_in_handler_utils(self):\n+        # Path to the handler_utils.py file\n+        file_path = 'django/core/handlers/handler_utils.py'  # Adjust this path to the actual location of your handler_utils.py\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        # Check if the required imports are present\n+        required_imports = {'async_to_sync', 'iscoroutinefunction', 'sync_to_async'}\n+        imports_found = set()\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom) and node.module == 'asgiref.sync':\n+                for alias in node.names:\n+                    if alias.name in required_imports:\n+                        imports_found.add(alias.name)\n+\n+        self.assertTrue(required_imports.issubset(imports_found), f\"Missing one or more required imports: {required_imports - imports_found}\")\n+\n+if __name__ == '__main__':\n+    unittest.main()",
    "problem_statement": "In base.py can you take out the adapt_method_mode function and put it in a file called handler_utils.py and update all references in the repo.",
    "hints_text": "",
    "created_at": "2025-11-03 22:46:32+00:00",
    "language": "Python",
    "Dockerfile": "N/A",
    "test_command": "python3 -m unittest new-utils-adapt-method-mode-test.py",
    "task_category": "Refactoring",
    "data_source": "microsoft/RefactorBench",
    "scenario": "brownfield"
  },
  {
    "repo": "django/django",
    "url": "https://github.com/django/django",
    "instance_id": "remove-core-cache-utils",
    "base_commit": "remove-core-cache-utils",
    "patch": "N/A",
    "test_patch": "diff --git a/remove-core-cache-utils-test.py b/remove-core-cache-utils-test.py\nnew file mode 100644\nindex 0000000..d0e28b6\n--- /dev/null\n+++ b/remove-core-cache-utils-test.py\n@@ -0,0 +1,94 @@\n+import unittest\n+import os\n+import ast\n+\n+class TestCacheMigration(unittest.TestCase):\n+\n+    def test_utils_py_removed(self):\n+        # Check if the utils.py file has been removed\n+        file_path = 'django/core/cache/utils.py'\n+        self.assertFalse(os.path.exists(file_path), f\"{file_path} should be removed but still exists\")\n+\n+    def test_make_template_fragment_key_moved(self):\n+        # Path to the file where the function should be moved\n+        file_path = 'django/templatetags/cache.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Check if the function is defined in cache.py\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        function_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.FunctionDef) and node.name == 'make_template_fragment_key':\n+                function_found = True\n+                break\n+\n+        self.assertTrue(function_found, \"Function 'make_template_fragment_key' not found in cache.py\")\n+\n+    def test_template_fragment_key_template_exists(self):\n+        # Path to the file where the constant should be present\n+        file_path = 'django/templatetags/cache.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Check if the TEMPLATE_FRAGMENT_KEY_TEMPLATE constant is defined in cache.py\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        constant_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.Assign):\n+                for target in node.targets:\n+                    if isinstance(target, ast.Name) and target.id == 'TEMPLATE_FRAGMENT_KEY_TEMPLATE':\n+                        if isinstance(node.value, ast.Constant) and node.value.value == \"template.cache.%s.%s\":\n+                            constant_found = True\n+                            break\n+            if constant_found:\n+                break\n+\n+        self.assertTrue(constant_found, \"Constant 'TEMPLATE_FRAGMENT_KEY_TEMPLATE' with value 'template.cache.%s.%s' not found in cache.py\")\n+\n+    def test_docs_reference_updated(self):\n+        # Path to the documentation file\n+        docs_file_path = 'docs/topics/cache.txt'  # or .rst, adjust as needed\n+\n+        # Check if the documentation file exists\n+        self.assertTrue(os.path.exists(docs_file_path), f\"Documentation file {docs_file_path} does not exist\")\n+\n+        # Check if the documentation references the new location of the function\n+        with open(docs_file_path, 'r') as file:\n+            docs_content = file.read()\n+\n+        old_reference = \"django.core.cache.utils.make_template_fragment_key\"\n+        new_reference = \"django.templatetags.cache.make_template_fragment_key\"\n+\n+        self.assertNotIn(old_reference, docs_content, \"Old reference to 'make_template_fragment_key' found in documentation\")\n+        self.assertIn(new_reference, docs_content, \"New reference to 'make_template_fragment_key' not found in documentation\")\n+\n+    def test_tests_py_imports_updated(self):\n+        # Path to the test file\n+        tests_file_path = 'tests/cache/tests.py'\n+\n+        # Check if the test file exists\n+        self.assertTrue(os.path.exists(tests_file_path), f\"Test file {tests_file_path} does not exist\")\n+\n+        # Check if the import statement is correct\n+        with open(tests_file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        import_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom):\n+                if node.module == 'django.templatetags.cache' and \\\n+                   any(alias.name == 'make_template_fragment_key' for alias in node.names):\n+                    import_found = True\n+                    break\n+\n+        self.assertTrue(import_found, \"Import 'from django.templatetags.cache import make_template_fragment_key' not found in tests.py\")\n+\n+if __name__ == '__main__':\n+    unittest.main()",
    "problem_statement": "remove the django/core/cache utils and put that function where it is called. Update the docs and tests with this new location for the function",
    "hints_text": "",
    "created_at": "2025-11-03 22:46:32+00:00",
    "language": "Python",
    "Dockerfile": "N/A",
    "test_command": "python3 -m unittest remove-core-cache-utils-test.py",
    "task_category": "Refactoring",
    "data_source": "microsoft/RefactorBench",
    "scenario": "brownfield"
  },
  {
    "repo": "django/django",
    "url": "https://github.com/django/django",
    "instance_id": "new-utils-check-response",
    "base_commit": "new-utils-check-response",
    "patch": "N/A",
    "test_patch": "diff --git a/new-utils-check-response-test.py b/new-utils-check-response-test.py\nnew file mode 100644\nindex 0000000..f0b5319\n--- /dev/null\n+++ b/new-utils-check-response-test.py\n@@ -0,0 +1,48 @@\n+import unittest\n+import ast\n+import os\n+\n+class TestHandlerUtils(unittest.TestCase):\n+\n+    def test_check_response_function_definition(self):\n+        # Path to the handler_utils.py file containing check_response\n+        file_path = 'django/core/handlers/handler_utils.py'\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.FunctionDef) and node.name == 'check_response':\n+                # Check if the function has the correct arguments\n+                args = [arg.arg for arg in node.args.args]\n+                self.assertIn('response', args, \"Missing 'response' parameter\")\n+                self.assertIn('callback', args, \"Missing 'callback' parameter\")\n+                \n+                # Check for optional parameters\n+                optional_args = {'name'}\n+                self.assertTrue(optional_args.issubset(args), \"Missing optional parameter 'name'\")\n+                \n+                return  # We found and checked the function, so we can stop here\n+\n+        self.fail(\"check_response function not found in the file\")\n+\n+    def test_check_response_import_in_base_handler(self):\n+        # Path to the base.py file\n+        file_path = 'django/core/handlers/base.py'  \n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        # Check if check_response is imported\n+        import_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom) and node.module == 'handler_utils':\n+                for alias in node.names:\n+                    if alias.name == 'check_response':\n+                        import_found = True\n+                        break\n+\n+        self.assertTrue(import_found, \"check_response not imported from handler_utils in base.py\")\n+\n+if __name__ == '__main__':\n+    unittest.main()",
    "problem_statement": "Move the check_response function out of the class it is in and put it in a file called handler_utils.py, update the usage of the function based on that.",
    "hints_text": "",
    "created_at": "2025-11-03 22:46:32+00:00",
    "language": "Python",
    "Dockerfile": "N/A",
    "test_command": "python3 -m unittest new-utils-check-response-test.py",
    "task_category": "Refactoring",
    "data_source": "microsoft/RefactorBench",
    "scenario": "brownfield"
  },
  {
    "repo": "saltstack/salt",
    "url": "https://github.com/saltstack/salt",
    "instance_id": "exactly-n-boto-mod",
    "base_commit": "exactly-n-boto-mod",
    "patch": "N/A",
    "test_patch": "diff --git a/exactly-n-boto-mod-test.py b/exactly-n-boto-mod-test.py\nnew file mode 100644\nindex 0000000..1810be4\n--- /dev/null\n+++ b/exactly-n-boto-mod-test.py\n@@ -0,0 +1,93 @@\n+import unittest\n+import os\n+import ast\n+\n+class TestBoto3ModImports(unittest.TestCase):\n+\n+    def test_import_exactly_n_exists(self):\n+        file_path = 'salt/utils/boto3mod.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        exactly_n_import_exists = any(\n+            isinstance(node, ast.ImportFrom) and\n+            node.module in ('salt.utils.botomod', 'botomod') and\n+            any(alias.name == 'exactly_n' for alias in node.names)\n+            for node in ast.walk(tree)\n+        )\n+\n+        self.assertTrue(exactly_n_import_exists, f\"Import for 'exactly_n' from 'salt.utils.botomod' or '.botomod' not found in {file_path}\")\n+\n+    def test_import_exactly_one_exists(self):\n+        file_path = 'salt/utils/boto3mod.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        exactly_one_import_exists = any(\n+            isinstance(node, ast.ImportFrom) and\n+            node.module in ('salt.utils.botomod', 'botomod') and\n+            any(alias.name == 'exactly_one' for alias in node.names)\n+            for node in ast.walk(tree)\n+        )\n+\n+        self.assertTrue(exactly_one_import_exists, f\"Import for 'exactly_one' from 'salt.utils.botomod' or '.botomod' not found in {file_path}\")\n+\n+    import unittest\n+import os\n+import ast\n+\n+class TestBoto3ModDefinitions(unittest.TestCase):\n+\n+    def test_exactly_n_definition_exists(self):\n+        file_path = 'salt/utils/boto3mod.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        exactly_n_function = next(\n+            (node for node in ast.walk(tree) if isinstance(node, ast.FunctionDef) and node.name == 'exactly_n'),\n+            None\n+        )\n+\n+        self.assertIsNotNone(exactly_n_function, f\"'exactly_n' function not found in {file_path}\")\n+\n+        # Check if the function returns imported_exactly_n with the correct arguments\n+        return_statement = exactly_n_function.body[1]\n+        self.assertIsInstance(return_statement, ast.Return, \"'exactly_n' function does not have a return statement\")\n+        self.assertIsInstance(return_statement.value, ast.Call, \"'exactly_n' function does not return a function call\")\n+        self.assertIsInstance(return_statement.value.func, ast.Name, \"'exactly_n' function does not call 'imported_exactly_n'\")\n+        self.assertEqual(return_statement.value.func.id, 'imported_exactly_n', \"'exactly_n' function does not call 'imported_exactly_n'\")\n+        self.assertEqual([arg.id for arg in return_statement.value.args], ['l', 'n'], \"'exactly_n' function does not pass the correct arguments to 'imported_exactly_n'\")\n+\n+    def test_exactly_one_definition_exists(self):\n+        file_path = 'salt/utils/boto3mod.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        exactly_one_function = next(\n+            (node for node in ast.walk(tree) if isinstance(node, ast.FunctionDef) and node.name == 'exactly_one'),\n+            None\n+        )\n+\n+        self.assertIsNotNone(exactly_one_function, f\"'exactly_one' function not found in {file_path}\")\n+\n+        # Check if the function returns imported_exactly_one with the correct arguments\n+        return_statement = exactly_one_function.body[0]\n+        self.assertIsInstance(return_statement, ast.Return, \"'exactly_one' function does not have a return statement\")\n+        self.assertIsInstance(return_statement.value, ast.Call, \"'exactly_one' function does not return a function call\")\n+        self.assertIsInstance(return_statement.value.func, ast.Name, \"'exactly_one' function does not call 'imported_exactly_one'\")\n+        self.assertEqual(return_statement.value.func.id, 'imported_exactly_one', \"'exactly_one' function does not call 'imported_exactly_one'\")\n+        self.assertEqual([arg.id for arg in return_statement.value.args], ['l'], \"'exactly_one' function does not pass the correct argument to 'imported_exactly_one'\")\n+\n+if __name__ == '__main__':\n+    unittest.main()\n+\n+if __name__ == '__main__':\n+    unittest.main()",
    "problem_statement": "Keep the exactly_n and exactly_1 functions in botomod and just define the functions in boto3mod as the import of imported_exactly_n and imported_exactly_1 so the code isn't as repetitive.",
    "hints_text": "",
    "created_at": "2025-11-03 22:46:32+00:00",
    "language": "Python",
    "Dockerfile": "N/A",
    "test_command": "python3 -m unittest exactly-n-boto-mod-test.py",
    "task_category": "Refactoring",
    "data_source": "microsoft/RefactorBench",
    "scenario": "brownfield"
  },
  {
    "repo": "saltstack/salt",
    "url": "https://github.com/saltstack/salt",
    "instance_id": "perm-denied",
    "base_commit": "perm-denied",
    "patch": "N/A",
    "test_patch": "diff --git a/perm-denied-test.py b/perm-denied-test.py\nnew file mode 100644\nindex 0000000..a92ee81\n--- /dev/null\n+++ b/perm-denied-test.py\n@@ -0,0 +1,111 @@\n+import unittest\n+import os\n+import ast\n+\n+class TestSaltUtilsSMB(unittest.TestCase):\n+\n+    def test_ex_perm_denied_in_exitcodes(self):\n+        file_path = 'salt/defaults/exitcodes.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        ex_perm_denied_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.Assign):\n+                for target in node.targets:\n+                    if isinstance(target, ast.Name) and target.id == 'EX_PERM_DENIED':\n+                        ex_perm_denied_found = True\n+                        break\n+\n+        self.assertTrue(ex_perm_denied_found, f\"'EX_PERM_DENIED' not found in {file_path}\")\n+\n+    def test_ex_noperm_not_in_exitcodes(self):\n+        file_path = 'salt/defaults/exitcodes.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        ex_noperm_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.Assign):\n+                for target in node.targets:\n+                    if isinstance(target, ast.Name) and target.id == 'EX_NOPERM':\n+                        ex_noperm_found = True\n+                        break\n+\n+        self.assertFalse(ex_noperm_found, f\"'EX_NOPERM' (misspelled) found in {file_path}\")\n+\n+    def test_ex_noperm_isnt_used_in_ssh(self):\n+        file_path = 'salt/client/ssh/__init__.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        ex_noperm_found = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.Attribute):\n+                if (node.attr == \"EX_NOPERM\" and\n+                    isinstance(node.value, ast.Attribute) and\n+                    node.value.attr == \"exitcodes\" and\n+                    isinstance(node.value.value, ast.Attribute) and\n+                    node.value.value.attr == \"defaults\" and\n+                    isinstance(node.value.value.value, ast.Name) and\n+                    node.value.value.value.id == \"salt\"):\n+                    ex_noperm_found = True\n+                    break\n+\n+        self.assertFalse(ex_noperm_found, \"salt.defaults.exitcodes.EX_NOPERM was found in salt/client/ssh/__init__.py, but it should not be used.\")\n+\n+    def test_ex_perm_denied_is_used_in_crypt(self):\n+        file_path = 'salt/crypt.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        ex_perm_denied_found = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.Attribute):\n+                if (node.attr == \"EX_PERM_DENIED\" and\n+                    isinstance(node.value, ast.Attribute) and\n+                    node.value.attr == \"exitcodes\" and\n+                    isinstance(node.value.value, ast.Attribute) and\n+                    node.value.value.attr == \"defaults\" and\n+                    isinstance(node.value.value.value, ast.Name) and\n+                    node.value.value.value.id == \"salt\"):\n+                    ex_perm_denied_found = True\n+                    break\n+\n+        self.assertTrue(ex_perm_denied_found, \"salt.defaults.exitcodes.EX_PERM_DENIED was not found in salt/crypt.py\")\n+\n+    def test_ex_noperm_isnt_used_in_crypt(self):\n+        file_path = 'salt/crypt.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        ex_noperm_found = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.Attribute):\n+                if (node.attr == \"EX_NOPERM\" and\n+                    isinstance(node.value, ast.Attribute) and\n+                    node.value.attr == \"exitcodes\" and\n+                    isinstance(node.value.value, ast.Attribute) and\n+                    node.value.value.attr == \"defaults\" and\n+                    isinstance(node.value.value.value, ast.Name) and\n+                    node.value.value.value.id == \"salt\"):\n+                    ex_noperm_found = True\n+                    break\n+\n+        self.assertFalse(ex_noperm_found, \"salt.defaults.exitcodes.EX_NOPERM was found in salt/crypt.py, but it should not be used.\")\n+\n+if __name__ == '__main__':\n+    unittest.main()",
    "problem_statement": "Rename EX_NOPERM into EX_PERM_DENIED and update the usage within the codebase.",
    "hints_text": "",
    "created_at": "2025-11-03 22:46:32+00:00",
    "language": "Python",
    "Dockerfile": "N/A",
    "test_command": "python3 -m unittest perm-denied-test.py",
    "task_category": "Refactoring",
    "data_source": "microsoft/RefactorBench",
    "scenario": "brownfield"
  },
  {
    "repo": "saltstack/salt",
    "url": "https://github.com/saltstack/salt",
    "instance_id": "cant-create",
    "base_commit": "cant-create",
    "patch": "N/A",
    "test_patch": "diff --git a/cant-create-test.py b/cant-create-test.py\nnew file mode 100644\nindex 0000000..cb1f077\n--- /dev/null\n+++ b/cant-create-test.py\n@@ -0,0 +1,158 @@\n+import unittest\n+import os\n+import ast\n+\n+class TestSaltExitCodes(unittest.TestCase):\n+\n+    def test_ex_cantcreate_in_exitcodes(self):\n+        file_path = 'salt/defaults/exitcodes.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        ex_cantcreate_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.Assign):\n+                for target in node.targets:\n+                    if isinstance(target, ast.Name) and target.id == 'EX_CANTCREATE':\n+                        ex_cantcreate_found = True\n+                        break\n+\n+        self.assertTrue(ex_cantcreate_found, f\"'EX_CANTCREATE' not found in {file_path}\")\n+\n+    def test_ex_cantcreate_in_ssh_py_shim(self):\n+        file_path = 'salt/client/ssh/ssh_py_shim.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        ex_cantcreate_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.Assign):\n+                for target in node.targets:\n+                    if isinstance(target, ast.Name) and target.id == 'EX_CANTCREATE':\n+                        ex_cantcreate_found = True\n+                        break\n+\n+        self.assertTrue(ex_cantcreate_found, f\"'EX_CANTCREATE' not found in {file_path}\")\n+\n+    def test_ssh_py_shim_uses_local_ex_cantcreate(self):\n+        file_path = 'salt/client/ssh/ssh_py_shim.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        ex_cantcreate_used = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.Name) and node.id == 'EX_CANTCREATE':\n+                ex_cantcreate_used = True\n+                break\n+\n+        self.assertTrue(ex_cantcreate_used, f\"'EX_CANTCREATE' not used in {file_path}\")\n+\n+    def test_ssh_py_shim_does_not_import_exitcodes(self):\n+        file_path = 'salt/client/ssh/ssh_py_shim.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        import_exitcodes_found = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.Import) or isinstance(node, ast.ImportFrom):\n+                for alias in node.names:\n+                    if alias.name == 'salt.defaults.exitcodes':\n+                        import_exitcodes_found = True\n+                        break\n+\n+        self.assertFalse(import_exitcodes_found, f\"'import salt.defaults.exitcodes' should not be found in {file_path}\")\n+\n+    def test_exitcodes_does_not_have_ex_cantcreat(self):\n+        file_path = 'salt/defaults/exitcodes.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        ex_cantcreat_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.Assign):\n+                for target in node.targets:\n+                    if isinstance(target, ast.Name) and target.id == 'EX_CANTCREAT':\n+                        ex_cantcreat_found = True\n+                        break\n+\n+        self.assertFalse(ex_cantcreat_found, f\"'EX_CANTCREAT' (misspelled) found in {file_path}\")\n+\n+    def test_ssh_py_shim_does_not_have_ex_cantcreat(self):\n+        file_path = 'salt/client/ssh/ssh_py_shim.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        ex_cantcreat_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.Assign):\n+                for target in node.targets:\n+                    if isinstance(target, ast.Name) and target.id == 'EX_CANTCREAT':\n+                        ex_cantcreat_found = True\n+                        break\n+\n+        self.assertFalse(ex_cantcreat_found, f\"'EX_CANTCREAT' (misspelled) found in {file_path}\")\n+        \n+    def test_ex_cantcreate_is_used(self):\n+        file_path = 'salt/client/ssh/__init__.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, \"r\") as file:\n+            tree = ast.parse(file.read(), filename=\"__init__.py\")\n+        \n+        ex_cantcreate_found = False\n+        \n+        # Traverse the syntax tree\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.Attribute):\n+                if (node.attr == \"EX_CANTCREATE\" and\n+                    isinstance(node.value, ast.Attribute) and\n+                    node.value.attr == \"exitcodes\" and\n+                    isinstance(node.value.value, ast.Attribute) and\n+                    node.value.value.attr == \"defaults\" and\n+                    isinstance(node.value.value.value, ast.Name) and\n+                    node.value.value.value.id == \"salt\"):\n+                    ex_cantcreate_found = True\n+                    break\n+        \n+        self.assertTrue(ex_cantcreate_found, \"salt.defaults.exitcodes.EX_CANTCREATE was not found in salt/client/ssh/__init__.py\")\n+\n+    def test_ex_cantcreat_isnt_used(self):\n+        file_path = 'salt/client/ssh/__init__.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, \"r\") as file:\n+            tree = ast.parse(file.read(), filename=\"__init__.py\")\n+        \n+        ex_cantcreat_found = False\n+        \n+        # Traverse the syntax tree\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.Attribute):\n+                if (node.attr == \"EX_CANTCREAT\" and\n+                    isinstance(node.value, ast.Attribute) and\n+                    node.value.attr == \"exitcodes\" and\n+                    isinstance(node.value.value, ast.Attribute) and\n+                    node.value.value.attr == \"defaults\" and\n+                    isinstance(node.value.value.value, ast.Name) and\n+                    node.value.value.value.id == \"salt\"):\n+                    ex_cantcreat_found = True\n+                    break\n+        \n+        self.assertFalse(ex_cantcreat_found, \"salt.defaults.exitcodes.EX_CANTCREAT was found in salt/client/ssh/__init__.py, but it should not be used.\")\n+\n+if __name__ == '__main__':\n+    unittest.main()",
    "problem_statement": "Rename all the EX_CANTCREAT to EX_CANTCREATE and update the repository based on that.",
    "hints_text": "",
    "created_at": "2025-11-03 22:46:32+00:00",
    "language": "Python",
    "Dockerfile": "N/A",
    "test_command": "python3 -m unittest cant-create-test.py",
    "task_category": "Refactoring",
    "data_source": "microsoft/RefactorBench",
    "scenario": "brownfield"
  },
  {
    "repo": "saltstack/salt",
    "url": "https://github.com/saltstack/salt",
    "instance_id": "paged-call-boto-mod",
    "base_commit": "paged-call-boto-mod",
    "patch": "N/A",
    "test_patch": "diff --git a/paged-call-boto-mod-test.py b/paged-call-boto-mod-test.py\nnew file mode 100644\nindex 0000000..c5f1c5d\n--- /dev/null\n+++ b/paged-call-boto-mod-test.py\n@@ -0,0 +1,87 @@\n+import unittest\n+import os\n+import ast\n+\n+class TestPagedCallRedefinition(unittest.TestCase):\n+\n+    def test_imported_paged_call_exists(self):\n+        file_path = 'salt/utils/boto3mod.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        imported_paged_call_exists = any(\n+            isinstance(node, ast.ImportFrom) and\n+            node.module == 'salt.utils.botomod' and\n+            any(alias.name == 'paged_call' and alias.asname == 'imported_paged_call' for alias in node.names)\n+            for node in ast.walk(tree)\n+        )\n+\n+        self.assertTrue(imported_paged_call_exists, f\"Import for 'paged_call as imported_paged_call' from 'salt.utils.botomod' not found in {file_path}\")\n+\n+    def test_paged_call_redefinition_exists(self):\n+        file_path = 'salt/utils/boto3mod.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        paged_call_function = next(\n+            (node for node in ast.walk(tree) if isinstance(node, ast.FunctionDef) and node.name == 'paged_call'),\n+            None\n+        )\n+\n+        self.assertIsNotNone(paged_call_function, f\"'paged_call' function not found in {file_path}\")\n+\n+    def test_paged_call_calls_imported_paged_call(self):\n+        file_path = 'salt/utils/boto3mod.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        paged_call_function = next(\n+            (node for node in ast.walk(tree) if isinstance(node, ast.FunctionDef) and node.name == 'paged_call'),\n+            None\n+        )\n+\n+        self.assertIsNotNone(paged_call_function, f\"'paged_call' function not found in {file_path}\")\n+\n+        # Check if the function contains a call to `imported_paged_call`\n+        function_calls_imported_paged_call = any(\n+            isinstance(node, ast.Call) and isinstance(node.func, ast.Name) and node.func.id == 'imported_paged_call'\n+            for node in ast.walk(paged_call_function)\n+        )\n+\n+        self.assertTrue(function_calls_imported_paged_call, f\"'paged_call' function does not call 'imported_paged_call' in {file_path}\")\n+\n+    def test_original_paged_call_has_key_elements(self):\n+        file_path = 'salt/utils/botomod.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        paged_call_function = next(\n+            (node for node in ast.walk(tree) if isinstance(node, ast.FunctionDef) and node.name == 'paged_call'),\n+            None\n+        )\n+\n+        self.assertIsNotNone(paged_call_function, f\"'paged_call' function not found in {file_path}\")\n+\n+        # Check for key elements in the function\n+        has_docstring = isinstance(paged_call_function.body[0], ast.Expr) and isinstance(paged_call_function.body[0].value, ast.Str)\n+        has_pop_marker_flag = any(\n+            isinstance(node, ast.Call) and isinstance(node.func, ast.Attribute) and node.func.attr == 'pop' and\n+            isinstance(node.args[0], ast.Str) and node.args[0].s == 'marker_flag'\n+            for node in ast.walk(paged_call_function)\n+        )\n+        has_while_loop = any(isinstance(node, ast.While) for node in paged_call_function.body)\n+\n+        self.assertTrue(has_docstring, \"'paged_call' function does not contain the expected docstring\")\n+        self.assertTrue(has_pop_marker_flag, \"'paged_call' function does not pop 'marker_flag' from kwargs\")\n+        self.assertTrue(has_while_loop, \"'paged_call' function does not contain the expected while loop\")\n+\n+if __name__ == '__main__':\n+    unittest.main()",
    "problem_statement": "Keep the paged_call function in botomod and just define the function in boto3mod as the import of imported_paged_call so the code isn't as repetitive.",
    "hints_text": "",
    "created_at": "2025-11-03 22:46:32+00:00",
    "language": "Python",
    "Dockerfile": "N/A",
    "test_command": "python3 -m unittest paged-call-boto-mod-test.py",
    "task_category": "Refactoring",
    "data_source": "microsoft/RefactorBench",
    "scenario": "brownfield"
  },
  {
    "repo": "saltstack/salt",
    "url": "https://github.com/saltstack/salt",
    "instance_id": "add-log-parameter-recursive-diff",
    "base_commit": "add-log-parameter-recursive-diff",
    "patch": "N/A",
    "test_patch": "diff --git a/add-log-parameter-recursive-diff-test.py b/add-log-parameter-recursive-diff-test.py\nnew file mode 100644\nindex 0000000..b90844b\n--- /dev/null\n+++ b/add-log-parameter-recursive-diff-test.py\n@@ -0,0 +1,145 @@\n+import unittest\n+import os\n+import ast\n+\n+class TestSaltUtilsData(unittest.TestCase):\n+\n+    def test_recursive_diff_has_log_parameter(self):\n+        file_path = 'salt/utils/data.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        recursive_diff_function = None\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.FunctionDef) and node.name == 'recursive_diff':\n+                recursive_diff_function = node\n+                break\n+\n+        self.assertIsNotNone(recursive_diff_function, f\"'recursive_diff' function not found in {file_path}\")\n+        log_param_found = any(arg.arg == 'log' for arg in recursive_diff_function.args.args)\n+        self.assertTrue(log_param_found, f\"'log' parameter not found in 'recursive_diff' function in {file_path}\")\n+\n+    def test_recursive_diff_calls_have_log_argument(self):\n+        file_path = 'salt/utils/data.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        calls_to_recursive_diff = [\n+            node for node in ast.walk(tree)\n+            if isinstance(node, ast.Call) and isinstance(node.func, ast.Name) and node.func.id == 'recursive_diff'\n+        ]\n+\n+        self.assertGreater(len(calls_to_recursive_diff), 0, f\"No calls to 'recursive_diff' found in {file_path}\")\n+\n+        for call in calls_to_recursive_diff:\n+            log_argument = any(\n+                isinstance(arg, ast.keyword) and arg.arg == 'log' for arg in call.keywords\n+            )\n+            self.assertTrue(\n+                log_argument,\n+                f\"Call to 'recursive_diff' without 'log=log' found in {file_path}: {ast.dump(call)}\"\n+            )\n+    \n+    def test_recursive_diff_does_not_have_log_parameter(self):\n+        file_path = 'salt/utils/dictdiffer.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        recursive_diff_function = None\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.FunctionDef) and node.name == 'recursive_diff':\n+                recursive_diff_function = node\n+                break\n+\n+        self.assertIsNotNone(recursive_diff_function, f\"'recursive_diff' function not found in {file_path}\")\n+        log_param_found = any(arg.arg == 'log' for arg in recursive_diff_function.args.args)\n+        self.assertFalse(log_param_found, f\"'log' parameter should not be present in 'recursive_diff' function in {file_path}\")\n+\n+    def test_recursive_diff_calls_do_not_have_log_argument(self):\n+        file_path = 'salt/utils/listdiffer.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        calls_to_recursive_diff = [\n+            node for node in ast.walk(tree)\n+            if isinstance(node, ast.Call) and isinstance(node.func, ast.Name) and node.func.id == 'recursive_diff'\n+        ]\n+\n+        self.assertGreater(len(calls_to_recursive_diff), 0, f\"No calls to 'recursive_diff' found in {file_path}\")\n+\n+        for call in calls_to_recursive_diff:\n+            log_argument = any(\n+                isinstance(arg, ast.keyword) and arg.arg == 'log' for arg in call.keywords\n+            )\n+            self.assertFalse(\n+                log_argument,\n+                f\"Call to 'recursive_diff' with 'log' argument found in {file_path}: {ast.dump(call)}\"\n+            )\n+            \n+    def test_recursive_diff_calls_have_log_true_argument(self):\n+        file_path = 'salt/states/win_lgpo_reg.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        calls_to_recursive_diff = [\n+            node for node in ast.walk(tree)\n+            if isinstance(node, ast.Call) and isinstance(node.func, ast.Attribute)\n+            and node.func.attr == 'recursive_diff' and isinstance(node.func.value, ast.Attribute)\n+            and node.func.value.attr == 'data' and isinstance(node.func.value.value, ast.Attribute)\n+            and node.func.value.value.attr == 'utils' and isinstance(node.func.value.value.value, ast.Name)\n+            and node.func.value.value.value.id == 'salt'\n+        ]\n+\n+        self.assertGreater(len(calls_to_recursive_diff), 0, f\"No calls to 'salt.utils.data.recursive_diff' found in {file_path}\")\n+\n+        for call in calls_to_recursive_diff:\n+            log_argument_found = False\n+            for keyword in call.keywords:\n+                if keyword.arg == 'log' and isinstance(keyword.value, ast.Constant) and keyword.value.value is True:\n+                    log_argument_found = True\n+                    break\n+\n+            self.assertTrue(\n+                log_argument_found,\n+                f\"Call to 'salt.utils.data.recursive_diff' without 'log=True' found in {file_path}: {ast.dump(call)}\"\n+            )\n+            \n+    def test_dictdiffer_recursive_diff_calls_do_not_have_log_argument(self):\n+        file_path = 'salt/states/file.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        calls_to_recursive_diff = [\n+            node for node in ast.walk(tree)\n+            if isinstance(node, ast.Call) and isinstance(node.func, ast.Attribute)\n+            and node.func.attr == 'recursive_diff' and isinstance(node.func.value, ast.Attribute)\n+            and node.func.value.attr == 'dictdiffer' and isinstance(node.func.value.value, ast.Attribute)\n+            and node.func.value.value.attr == 'utils' and isinstance(node.func.value.value.value, ast.Name)\n+            and node.func.value.value.value.id == 'salt'\n+        ]\n+\n+        self.assertGreater(len(calls_to_recursive_diff), 0, f\"No calls to 'salt.utils.dictdiffer.recursive_diff' found in {file_path}\")\n+\n+        for call in calls_to_recursive_diff:\n+            log_argument = any(\n+                isinstance(arg, ast.keyword) and arg.arg == 'log' for arg in call.keywords\n+            )\n+            self.assertFalse(\n+                log_argument,\n+                f\"Call to 'salt.utils.dictdiffer.recursive_diff' with 'log' argument found in {file_path}: {ast.dump(call)}\"\n+            )\n+\n+if __name__ == '__main__':\n+    unittest.main()",
    "problem_statement": "Add a log boolean parameter to recursive_diff in data.py and keep the base case as false. Then make all usages throughout the repository except for testing files as True. All internal recursive calls from the function should follow the initial log setting as well.",
    "hints_text": "",
    "created_at": "2025-11-03 22:46:32+00:00",
    "language": "Python",
    "Dockerfile": "N/A",
    "test_command": "python3 -m unittest add-log-parameter-recursive-diff-test.py",
    "task_category": "Refactoring",
    "data_source": "microsoft/RefactorBench",
    "scenario": "brownfield"
  },
  {
    "repo": "saltstack/salt",
    "url": "https://github.com/saltstack/salt",
    "instance_id": "mksls-to-specific",
    "base_commit": "mksls-to-specific",
    "patch": "N/A",
    "test_patch": "diff --git a/mksls-to-specific-test.py b/mksls-to-specific-test.py\nnew file mode 100644\nindex 0000000..cf8d9bb\n--- /dev/null\n+++ b/mksls-to-specific-test.py\n@@ -0,0 +1,98 @@\n+import unittest\n+import os\n+import ast\n+\n+class TestSaltUtilsModules(unittest.TestCase):\n+\n+    # Check that 'mksls' does not exist in preseed.py\n+    def test_preseed_py_does_not_have_mksls(self):\n+        file_path = 'salt/utils/preseed.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        mksls_function_found = any(\n+            isinstance(node, ast.FunctionDef) and node.name == 'mksls'\n+            for node in ast.walk(tree)\n+        )\n+\n+        self.assertFalse(mksls_function_found, f\"'mksls' should not be found in {file_path}\")\n+\n+    # Check that 'mksls' does not exist in kickstart.py\n+    def test_kickstart_py_does_not_have_mksls(self):\n+        file_path = 'salt/utils/kickstart.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        mksls_function_found = any(\n+            isinstance(node, ast.FunctionDef) and node.name == 'mksls'\n+            for node in ast.walk(tree)\n+        )\n+\n+        self.assertFalse(mksls_function_found, f\"'mksls' should not be found in {file_path}\")\n+\n+    # Check that 'mksls' does not exist in yast.py\n+    def test_yast_py_does_not_have_mksls(self):\n+        file_path = 'salt/utils/yast.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        mksls_function_found = any(\n+            isinstance(node, ast.FunctionDef) and node.name == 'mksls'\n+            for node in ast.walk(tree)\n+        )\n+\n+        self.assertFalse(mksls_function_found, f\"'mksls' should not be found in {file_path}\")\n+\n+    # Check that 'preseed_to_sls' exists in preseed.py\n+    def test_preseed_py_has_preseed_to_sls(self):\n+        file_path = 'salt/utils/preseed.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        preseed_to_sls_function_found = any(\n+            isinstance(node, ast.FunctionDef) and node.name == 'preseed_to_sls'\n+            for node in ast.walk(tree)\n+        )\n+\n+        self.assertTrue(preseed_to_sls_function_found, f\"'preseed_to_sls' not found in {file_path}\")\n+\n+    # Check that 'kickstart_to_sls' exists in kickstart.py\n+    def test_kickstart_py_has_kickstart_to_sls(self):\n+        file_path = 'salt/utils/kickstart.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        kickstart_to_sls_function_found = any(\n+            isinstance(node, ast.FunctionDef) and node.name == 'kickstart_to_sls'\n+            for node in ast.walk(tree)\n+        )\n+\n+        self.assertTrue(kickstart_to_sls_function_found, f\"'kickstart_to_sls' not found in {file_path}\")\n+\n+    # Check that 'autoyast_to_sls' exists in yast.py\n+    def test_yast_py_has_autoyast_to_sls(self):\n+        file_path = 'salt/utils/yast.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        autoyast_to_sls_function_found = any(\n+            isinstance(node, ast.FunctionDef) and node.name == 'autoyast_to_sls'\n+            for node in ast.walk(tree)\n+        )\n+\n+        self.assertTrue(autoyast_to_sls_function_found, f\"'autoyast_to_sls' not found in {file_path}\")\n+\n+if __name__ == '__main__':\n+    unittest.main()",
    "problem_statement": "Rename all the mksls to new function names based on the conversions they actually do. Make all three autoyast_to_sls, kickstart_to_sls, and preseed_to_sls",
    "hints_text": "",
    "created_at": "2025-11-03 22:46:32+00:00",
    "language": "Python",
    "Dockerfile": "N/A",
    "test_command": "python3 -m unittest mksls-to-specific-test.py",
    "task_category": "Refactoring",
    "data_source": "microsoft/RefactorBench",
    "scenario": "brownfield"
  },
  {
    "repo": "saltstack/salt",
    "url": "https://github.com/saltstack/salt",
    "instance_id": "get-unavail",
    "base_commit": "get-unavail",
    "patch": "N/A",
    "test_patch": "diff --git a/get-unavail-test.py b/get-unavail-test.py\nnew file mode 100644\nindex 0000000..1609b52\n--- /dev/null\n+++ b/get-unavail-test.py\n@@ -0,0 +1,221 @@\n+import unittest\n+import os\n+import ast\n+\n+class TestSaltExitCodes(unittest.TestCase):\n+\n+    def test_exitcodes_has_ex_unavail(self):\n+        file_path = 'salt/defaults/exitcodes.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        ex_unavail_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.Assign):\n+                for target in node.targets:\n+                    if isinstance(target, ast.Name) and target.id == 'EX_UNAVAIL':\n+                        if isinstance(node.value, ast.Constant) and node.value.value == 69:\n+                            ex_unavail_found = True\n+                            break\n+\n+        self.assertTrue(ex_unavail_found, f\"'EX_UNAVAIL = 69' not found in {file_path}\")\n+\n+    def test_scripts_py_uses_ex_unavail(self):\n+        file_path = 'salt/scripts.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        ex_unavail_used = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.Attribute):\n+                if (isinstance(node.value, ast.Attribute) and \n+                    isinstance(node.value.value, ast.Attribute) and \n+                    isinstance(node.value.value.value, ast.Name) and \n+                    node.value.value.value.id == 'salt' and \n+                    node.value.value.attr == 'defaults' and \n+                    node.value.attr == 'exitcodes' and \n+                    node.attr == 'EX_UNAVAIL'):\n+                    ex_unavail_used = True\n+                    break\n+\n+        self.assertTrue(ex_unavail_used, f\"'salt.defaults.exitcodes.EX_UNAVAIL' not found in {file_path}\")\n+    \n+    def test_scripts_py_does_not_use_ex_unavailable(self):\n+        file_path = 'salt/scripts.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        ex_unavailable_used = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.Attribute):\n+                if (isinstance(node.value, ast.Attribute) and \n+                    isinstance(node.value.value, ast.Attribute) and \n+                    isinstance(node.value.value.value, ast.Name) and \n+                    node.value.value.value.id == 'salt' and \n+                    node.value.value.attr == 'defaults' and \n+                    node.value.attr == 'exitcodes' and \n+                    node.attr == 'EX_UNAVAILABLE'):\n+                    ex_unavailable_used = True\n+                    break\n+\n+        self.assertFalse(ex_unavailable_used, f\"'salt.defaults.exitcodes.EX_UNAVAILABLE' found in {file_path}\")\n+\n+    def test_parsers_py_uses_ex_unavail(self):\n+        file_path = 'salt/utils/parsers.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        ex_unavail_used = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.Attribute):\n+                if (isinstance(node.value, ast.Attribute) and \n+                    isinstance(node.value.value, ast.Attribute) and \n+                    isinstance(node.value.value.value, ast.Name) and \n+                    node.value.value.value.id == 'salt' and \n+                    node.value.value.attr == 'defaults' and \n+                    node.value.attr == 'exitcodes' and \n+                    node.attr == 'EX_UNAVAIL'):\n+                    ex_unavail_used = True\n+                    break\n+\n+        self.assertTrue(ex_unavail_used, f\"'salt.defaults.exitcodes.EX_UNAVAIL' not found in {file_path}\")\n+    \n+    def test_parsers_py_does_not_use_ex_unavailable(self):\n+        file_path = 'salt/utils/parsers.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        ex_unavailable_used = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.Attribute):\n+                if (isinstance(node.value, ast.Attribute) and \n+                    isinstance(node.value.value, ast.Attribute) and \n+                    isinstance(node.value.value.value, ast.Name) and \n+                    node.value.value.value.id == 'salt' and \n+                    node.value.value.attr == 'defaults' and \n+                    node.value.attr == 'exitcodes' and \n+                    node.attr == 'EX_UNAVAILABLE'):\n+                    ex_unavailable_used = True\n+                    break\n+\n+        self.assertFalse(ex_unavailable_used, f\"'salt.defaults.exitcodes.EX_UNAVAILABLE' found in {file_path}\")\n+\n+    def test_salt_call_py_uses_ex_unavail(self):\n+        file_path = 'tests/pytests/integration/cli/test_salt_call.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        ex_unavail_used = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.Attribute):\n+                if (isinstance(node.value, ast.Attribute) and \n+                    isinstance(node.value.value, ast.Attribute) and \n+                    isinstance(node.value.value.value, ast.Name) and \n+                    node.value.value.value.id == 'salt' and \n+                    node.value.value.attr == 'defaults' and \n+                    node.value.attr == 'exitcodes' and \n+                    node.attr == 'EX_UNAVAIL'):\n+                    ex_unavail_used = True\n+                    break\n+\n+        self.assertTrue(ex_unavail_used, f\"'salt.defaults.exitcodes.EX_UNAVAIL' not found in {file_path}\")\n+    \n+    def test_salt_call_py_does_not_use_ex_unavailable(self):\n+        file_path = 'tests/pytests/integration/cli/test_salt_call.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        ex_unavailable_used = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.Attribute):\n+                if (isinstance(node.value, ast.Attribute) and \n+                    isinstance(node.value.value, ast.Attribute) and \n+                    isinstance(node.value.value.value, ast.Name) and \n+                    node.value.value.value.id == 'salt' and \n+                    node.value.value.attr == 'defaults' and \n+                    node.value.attr == 'exitcodes' and \n+                    node.attr == 'EX_UNAVAILABLE'):\n+                    ex_unavailable_used = True\n+                    break\n+\n+        self.assertFalse(ex_unavailable_used, f\"'salt.defaults.exitcodes.EX_UNAVAILABLE' found in {file_path}\")\n+\n+    def test_scripts_py_imports_exitcodes(self):\n+        file_path = 'salt/scripts.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        import_found = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.Import) or isinstance(node, ast.ImportFrom):\n+                for alias in node.names:\n+                    if alias.name == 'salt.defaults.exitcodes':\n+                        import_found = True\n+                        break\n+\n+        self.assertTrue(import_found, f\"'import salt.defaults.exitcodes' not found in {file_path}\")\n+\n+    def test_parsers_py_imports_exitcodes(self):\n+        file_path = 'salt/utils/parsers.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        import_found = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.Import) or isinstance(node, ast.ImportFrom):\n+                for alias in node.names:\n+                    if alias.name == 'salt.defaults.exitcodes':\n+                        import_found = True\n+                        break\n+\n+        self.assertTrue(import_found, f\"'import salt.defaults.exitcodes' not found in {file_path}\")\n+\n+    def test_salt_call_py_imports_exitcodes(self):\n+        file_path = 'tests/pytests/integration/cli/test_salt_call.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        import_found = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.Import) or isinstance(node, ast.ImportFrom):\n+                for alias in node.names:\n+                    if alias.name == 'salt.defaults.exitcodes':\n+                        import_found = True\n+                        break\n+\n+        self.assertTrue(import_found, f\"'import salt.defaults.exitcodes' not found in {file_path}\")\n+\n+\n+\n+    \n+if __name__ == '__main__':\n+    unittest.main()",
    "problem_statement": "Rename the EX_UNAVAILABLE exitcode to EX_UNAVAIL for brevity and update the repository based on that.",
    "hints_text": "",
    "created_at": "2025-11-03 22:46:32+00:00",
    "language": "Python",
    "Dockerfile": "N/A",
    "test_command": "python3 -m unittest get-unavail-test.py",
    "task_category": "Refactoring",
    "data_source": "microsoft/RefactorBench",
    "scenario": "brownfield"
  },
  {
    "repo": "saltstack/salt",
    "url": "https://github.com/saltstack/salt",
    "instance_id": "namecheap-xmlutil",
    "base_commit": "namecheap-xmlutil",
    "patch": "N/A",
    "test_patch": "diff --git a/namecheap-xmlutil-test.py b/namecheap-xmlutil-test.py\nnew file mode 100644\nindex 0000000..e60a403\n--- /dev/null\n+++ b/namecheap-xmlutil-test.py\n@@ -0,0 +1,74 @@\n+import unittest\n+import os\n+import ast\n+\n+class TestXmlUtilFunctions(unittest.TestCase):\n+\n+    def test_xml_to_dict_in_xmlutil(self):\n+        file_path = 'salt/utils/xmlutil.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        xml_to_dict_found = any(isinstance(node, ast.FunctionDef) and node.name == 'xml_to_dict' for node in ast.walk(tree))\n+\n+        self.assertTrue(xml_to_dict_found, f\"Function 'xml_to_dict' not found in {file_path}, but it should be present\")\n+\n+    def test_atts_to_dict_in_xmlutil(self):\n+        file_path = 'salt/utils/xmlutil.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        atts_to_dict_found = any(isinstance(node, ast.FunctionDef) and node.name == 'atts_to_dict' for node in ast.walk(tree))\n+\n+        self.assertTrue(atts_to_dict_found, f\"Function 'atts_to_dict' not found in {file_path}, but it should be present\")\n+\n+    def test_string_to_value_in_xmlutil(self):\n+        file_path = 'salt/utils/xmlutil.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        string_to_value_found = any(isinstance(node, ast.FunctionDef) and node.name == 'string_to_value' for node in ast.walk(tree))\n+\n+        self.assertTrue(string_to_value_found, f\"Function 'string_to_value' not found in {file_path}, but it should be present\")\n+\n+    def test_xml_to_dict_not_in_namecheap(self):\n+        file_path = 'salt/utils/namecheap.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        xml_to_dict_found = any(isinstance(node, ast.FunctionDef) and node.name == 'xml_to_dict' for node in ast.walk(tree))\n+\n+        self.assertFalse(xml_to_dict_found, f\"Function 'xml_to_dict' found in {file_path}, but it should not be present\")\n+\n+    def test_atts_to_dict_not_in_namecheap(self):\n+        file_path = 'salt/utils/namecheap.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        atts_to_dict_found = any(isinstance(node, ast.FunctionDef) and node.name == 'atts_to_dict' for node in ast.walk(tree))\n+\n+        self.assertFalse(atts_to_dict_found, f\"Function 'atts_to_dict' found in {file_path}, but it should not be present\")\n+\n+    def test_string_to_value_not_in_namecheap(self):\n+        file_path = 'salt/utils/namecheap.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        string_to_value_found = any(isinstance(node, ast.FunctionDef) and node.name == 'string_to_value' for node in ast.walk(tree))\n+\n+        self.assertFalse(string_to_value_found, f\"Function 'string_to_value' found in {file_path}, but it should not be present\")\n+\n+if __name__ == '__main__':\n+    unittest.main()",
    "problem_statement": "Move the to_dict and to_value functions in namecheap to xmlutil.py and update all references accordingly.",
    "hints_text": "",
    "created_at": "2025-11-03 22:46:32+00:00",
    "language": "Python",
    "Dockerfile": "N/A",
    "test_command": "python3 -m unittest namecheap-xmlutil-test.py",
    "task_category": "Refactoring",
    "data_source": "microsoft/RefactorBench",
    "scenario": "brownfield"
  },
  {
    "repo": "saltstack/salt",
    "url": "https://github.com/saltstack/salt",
    "instance_id": "add-log-parameter-get-capability-definitions",
    "base_commit": "add-log-parameter-get-capability-definitions",
    "patch": "N/A",
    "test_patch": "diff --git a/add-log-parameter-get-capability-definitions-test.py b/add-log-parameter-get-capability-definitions-test.py\nnew file mode 100644\nindex 0000000..05baf33\n--- /dev/null\n+++ b/add-log-parameter-get-capability-definitions-test.py\n@@ -0,0 +1,119 @@\n+import unittest\n+import os\n+import ast\n+\n+class TestSaltUtilsPBM(unittest.TestCase):\n+\n+    def test_get_capability_definitions_has_log_parameter(self):\n+        file_path = 'salt/utils/pbm.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        get_capability_definitions_function = None\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.FunctionDef) and node.name == 'get_capability_definitions':\n+                get_capability_definitions_function = node\n+                break\n+\n+        self.assertIsNotNone(get_capability_definitions_function, f\"'get_capability_definitions' function not found in {file_path}\")\n+        \n+        log_param_found = False\n+        log_param_default_is_false = False\n+        for i, arg in enumerate(get_capability_definitions_function.args.args):\n+            if arg.arg == 'log':\n+                log_param_found = True\n+                # Ensure the corresponding default value is False\n+                if i >= len(get_capability_definitions_function.args.args) - len(get_capability_definitions_function.args.defaults):\n+                    default_index = i - (len(get_capability_definitions_function.args.args) - len(get_capability_definitions_function.args.defaults))\n+                    log_param_default_is_false = isinstance(get_capability_definitions_function.args.defaults[default_index], ast.Constant) and get_capability_definitions_function.args.defaults[default_index].value is False\n+                break\n+\n+        self.assertTrue(log_param_found, f\"'log' parameter not found in 'get_capability_definitions' function in {file_path}\")\n+        self.assertTrue(log_param_default_is_false, f\"'log' parameter in 'get_capability_definitions' function does not default to False in {file_path}\")\n+\n+    def test_get_capability_definitions_usage_has_log_true(self):\n+        file_path = 'salt/modules/vsphere.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        get_capability_definitions_calls = []\n+\n+        # Walk through all nodes in the AST tree\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.Call):\n+                func = node.func\n+                if isinstance(func, ast.Attribute):\n+                    # Handle cases like salt.utils.pbm.get_capability_definitions()\n+                    if func.attr == 'get_capability_definitions':\n+                        # Traverse the chain of attributes (e.g., salt.utils.pbm)\n+                        current_node = func.value\n+                        full_name = []\n+                        while isinstance(current_node, ast.Attribute):\n+                            full_name.insert(0, current_node.attr)\n+                            current_node = current_node.value\n+                        if isinstance(current_node, ast.Name):\n+                            full_name.insert(0, current_node.id)\n+                        # Check if the full name matches 'salt.utils.pbm'\n+                        if full_name == ['salt', 'utils', 'pbm']:\n+                            get_capability_definitions_calls.append(node)\n+\n+        self.assertGreater(len(get_capability_definitions_calls), 0, f\"No calls to 'salt.utils.pbm.get_capability_definitions()' found in {file_path}\")\n+\n+        for call in get_capability_definitions_calls:\n+            log_argument = any(\n+                isinstance(arg, ast.keyword) and arg.arg == 'log' and isinstance(arg.value, ast.Constant) and arg.value.value is True\n+                for arg in call.keywords\n+            )\n+            self.assertTrue(\n+                log_argument,\n+                f\"Call to 'salt.utils.pbm.get_capability_definitions()' without 'log=True' found in {file_path}: {ast.dump(call)}\"\n+            )\n+    def test_get_capability_definitions_usage_has_log_false_or_no_log(self):\n+        file_path = 'tests/unit/utils/test_pbm.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        get_capability_definitions_calls = []\n+\n+        # Walk through all nodes in the AST tree\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.Call):\n+                func = node.func\n+                if isinstance(func, ast.Attribute):\n+                    # Handle cases like salt.utils.pbm.get_capability_definitions()\n+                    if func.attr == 'get_capability_definitions':\n+                        # Traverse the chain of attributes (e.g., salt.utils.pbm)\n+                        current_node = func.value\n+                        full_name = []\n+                        while isinstance(current_node, ast.Attribute):\n+                            full_name.insert(0, current_node.attr)\n+                            current_node = current_node.value\n+                        if isinstance(current_node, ast.Name):\n+                            full_name.insert(0, current_node.id)\n+                        # Check if the full name matches 'salt.utils.pbm'\n+                        if full_name == ['salt', 'utils', 'pbm']:\n+                            get_capability_definitions_calls.append(node)\n+\n+        self.assertGreater(len(get_capability_definitions_calls), 0, f\"No calls to 'salt.utils.pbm.get_capability_definitions()' found in {file_path}\")\n+\n+        for call in get_capability_definitions_calls:\n+            log_argument = None\n+            for arg in call.keywords:\n+                if arg.arg == 'log':\n+                    log_argument = arg.value\n+                    break\n+\n+            # Ensure log is False or not provided\n+            if log_argument is not None:\n+                self.assertIsInstance(log_argument, ast.Constant, f\"Unexpected 'log' argument in call: {ast.dump(call)}\")\n+                self.assertFalse(log_argument.value, f\"Call to 'salt.utils.pbm.get_capability_definitions()' has 'log=True' in {file_path}: {ast.dump(call)}\")\n+    \n+            \n+if __name__ == '__main__':\n+    unittest.main()",
    "problem_statement": "Add a log boolean parameter in get_capability_definitions with the base log=False and make the log=True in all cases except testing files.",
    "hints_text": "",
    "created_at": "2025-11-03 22:46:32+00:00",
    "language": "Python",
    "Dockerfile": "N/A",
    "test_command": "python3 -m unittest add-log-parameter-get-capability-definitions-test.py",
    "task_category": "Refactoring",
    "data_source": "microsoft/RefactorBench",
    "scenario": "brownfield"
  },
  {
    "repo": "saltstack/salt",
    "url": "https://github.com/saltstack/salt",
    "instance_id": "add-log-parameter-delete-directory",
    "base_commit": "add-log-parameter-delete-directory",
    "patch": "N/A",
    "test_patch": "diff --git a/add-log-parameter-delete-directory-test.py b/add-log-parameter-delete-directory-test.py\nnew file mode 100644\nindex 0000000..1522ca5\n--- /dev/null\n+++ b/add-log-parameter-delete-directory-test.py\n@@ -0,0 +1,135 @@\n+import unittest\n+import os\n+import ast\n+\n+class TestSaltUtilsSMB(unittest.TestCase):\n+\n+    def test_delete_directory_has_log_parameter(self):\n+        file_path = 'salt/utils/smb.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        delete_directory_function = None\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.FunctionDef) and node.name == 'delete_directory':\n+                delete_directory_function = node\n+                break\n+\n+        self.assertIsNotNone(delete_directory_function, f\"'delete_directory' function not found in {file_path}\")\n+        \n+        log_param_found = False\n+        log_param_default_is_false = False\n+        for i, arg in enumerate(delete_directory_function.args.args):\n+            if arg.arg == 'log':\n+                log_param_found = True\n+                # Ensure the corresponding default value is False\n+                if i >= len(delete_directory_function.args.args) - len(delete_directory_function.args.defaults):\n+                    default_index = i - (len(delete_directory_function.args.args) - len(delete_directory_function.args.defaults))\n+                    log_param_default_is_false = isinstance(delete_directory_function.args.defaults[default_index], ast.Constant) and delete_directory_function.args.defaults[default_index].value is False\n+                break\n+\n+        self.assertTrue(log_param_found, f\"'log' parameter not found in 'delete_directory' function in {file_path}\")\n+        self.assertTrue(log_param_default_is_false, f\"'log' parameter in 'delete_directory' function does not default to False in {file_path}\")\n+\n+    def test_delete_directory_usage_has_log_true(self):\n+        file_path = 'salt/utils/cloud.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        delete_directory_calls = []\n+\n+        # Walk through all nodes in the AST tree\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.Call):\n+                func = node.func\n+                if isinstance(func, ast.Attribute):\n+                    # Handle cases like salt.utils.smb.delete_directory()\n+                    if func.attr == 'delete_directory':\n+                        # Traverse the chain of attributes (e.g., salt.utils.smb)\n+                        current_node = func.value\n+                        full_name = []\n+                        while isinstance(current_node, ast.Attribute):\n+                            full_name.insert(0, current_node.attr)\n+                            current_node = current_node.value\n+                        if isinstance(current_node, ast.Name):\n+                            full_name.insert(0, current_node.id)\n+                        # Check if the full name matches 'salt.utils.smb'\n+                        if full_name == ['salt', 'utils', 'smb']:\n+                            delete_directory_calls.append(node)\n+\n+        self.assertGreater(len(delete_directory_calls), 0, f\"No calls to 'salt.utils.smb.delete_directory()' found in {file_path}\")\n+\n+        for call in delete_directory_calls:\n+            log_argument = any(\n+                isinstance(arg, ast.keyword) and arg.arg == 'log' and isinstance(arg.value, ast.Constant) and arg.value.value is True\n+                for arg in call.keywords\n+            )\n+            self.assertTrue(\n+                log_argument,\n+                f\"Call to 'salt.utils.smb.delete_directory()' without 'log=True' found in {file_path}: {ast.dump(call)}\"\n+            )\n+       \n+    def test_delete_directory_calls_integration_tests(self):\n+        file_path = 'tests/integration/utils/test_smb.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        delete_directory_calls = []\n+\n+        # Walk through all nodes in the AST tree\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.Call):\n+                func = node.func\n+                if isinstance(func, ast.Attribute):\n+                    # Handle cases like salt.utils.smb.delete_directory()\n+                    if func.attr == 'delete_directory':\n+                        # Traverse the chain of attributes (e.g., salt.utils.smb)\n+                        current_node = func.value\n+                        full_name = []\n+                        while isinstance(current_node, ast.Attribute):\n+                            full_name.insert(0, current_node.attr)\n+                            current_node = current_node.value\n+                        if isinstance(current_node, ast.Name):\n+                            full_name.insert(0, current_node.id)\n+                        # Check if the full name matches 'salt.utils.smb'\n+                        if full_name == ['salt', 'utils', 'smb']:\n+                            delete_directory_calls.append(node)\n+\n+        self.assertGreater(len(delete_directory_calls), 0, f\"No calls to 'salt.utils.smb.delete_directory()' found in {file_path}\")\n+\n+        for call in delete_directory_calls:\n+            log_argument = None\n+            for arg in call.keywords:\n+                if arg.arg == 'log':\n+                    log_argument = arg.value\n+                    break\n+\n+            # Ensure log is False or not provided\n+            if log_argument is not None:\n+                self.assertIsInstance(log_argument, ast.Constant, f\"Unexpected 'log' argument in call: {ast.dump(call)}\")\n+                self.assertFalse(log_argument.value, f\"Call to 'salt.utils.smb.delete_directory()' has 'log=True' in {file_path}: {ast.dump(call)}\")\n+    \n+    def test_smb_py_has_delete_directory(self):\n+        file_path = 'salt/utils/smb.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        delete_directory_function = None\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.FunctionDef) and node.name == 'delete_directory':\n+                delete_directory_function = node\n+                break\n+\n+        self.assertIsNotNone(delete_directory_function, f\"'delete_directory' function not found in {file_path}\")\n+     \n+            \n+if __name__ == '__main__':\n+    unittest.main()",
    "problem_statement": "Add a log boolean parameter to delete_directory function and make the base log=False, but for all calls excepts in tests make log=True.",
    "hints_text": "",
    "created_at": "2025-11-03 22:46:32+00:00",
    "language": "Python",
    "Dockerfile": "N/A",
    "test_command": "python3 -m unittest add-log-parameter-delete-directory-test.py",
    "task_category": "Refactoring",
    "data_source": "microsoft/RefactorBench",
    "scenario": "brownfield"
  },
  {
    "repo": "saltstack/salt",
    "url": "https://github.com/saltstack/salt",
    "instance_id": "ex-state-fail",
    "base_commit": "ex-state-fail",
    "patch": "N/A",
    "test_patch": "diff --git a/ex-state-fail-test.py b/ex-state-fail-test.py\nnew file mode 100644\nindex 0000000..4b905c0\n--- /dev/null\n+++ b/ex-state-fail-test.py\n@@ -0,0 +1,134 @@\n+import unittest\n+import os\n+import ast\n+\n+class TestSaltUtilsStateFail(unittest.TestCase):\n+\n+    def test_ex_state_failure_not_in_exitcodes(self):\n+        file_path = 'salt/defaults/exitcodes.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        ex_state_failure_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.Assign):\n+                for target in node.targets:\n+                    if isinstance(target, ast.Name) and target.id == 'EX_STATE_FAILURE':\n+                        ex_state_failure_found = True\n+                        break\n+\n+        self.assertFalse(ex_state_failure_found, f\"'EX_STATE_FAILURE' should not exist in {file_path}\")\n+\n+    def test_ex_state_fail_in_exitcodes(self):\n+        file_path = 'salt/defaults/exitcodes.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        ex_state_fail_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.Assign):\n+                for target in node.targets:\n+                    if isinstance(target, ast.Name) and target.id == 'EX_STATE_FAIL':\n+                        ex_state_fail_found = True\n+                        break\n+\n+        self.assertTrue(ex_state_fail_found, f\"'EX_STATE_FAIL' not found in {file_path}\")\n+\n+    def test_ex_state_failure_not_in_state(self):\n+        file_path = 'salt/modules/state.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        ex_state_failure_found = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.Attribute):\n+                if (node.attr == \"EX_STATE_FAILURE\" and\n+                    isinstance(node.value, ast.Attribute) and\n+                    node.value.attr == \"exitcodes\" and\n+                    isinstance(node.value.value, ast.Attribute) and\n+                    node.value.value.attr == \"defaults\" and\n+                    isinstance(node.value.value.value, ast.Name) and\n+                    node.value.value.value.id == \"salt\"):\n+                    ex_state_failure_found = True\n+                    break\n+\n+        self.assertFalse(ex_state_failure_found, \"salt.defaults.exitcodes.EX_STATE_FAILURE should not exist in salt/modules/state.py\")\n+\n+    def test_ex_state_fail_is_used_in_state(self):\n+        file_path = 'salt/modules/state.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        ex_state_fail_found = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.Attribute):\n+                if (node.attr == \"EX_STATE_FAIL\" and\n+                    isinstance(node.value, ast.Attribute) and\n+                    node.value.attr == \"exitcodes\" and\n+                    isinstance(node.value.value, ast.Attribute) and\n+                    node.value.value.attr == \"defaults\" and\n+                    isinstance(node.value.value.value, ast.Name) and\n+                    node.value.value.value.id == \"salt\"):\n+                    ex_state_fail_found = True\n+                    break\n+\n+        self.assertTrue(ex_state_fail_found, \"salt.defaults.exitcodes.EX_STATE_FAIL was not found in salt/modules/state.py\")\n+\n+    def test_ex_state_failure_not_in_test_salt_call(self):\n+        file_path = 'tests/pytests/integration/cli/test_salt_call.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        ex_state_failure_found = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.Attribute):\n+                if (node.attr == \"EX_STATE_FAILURE\" and\n+                    isinstance(node.value, ast.Attribute) and\n+                    node.value.attr == \"exitcodes\" and\n+                    isinstance(node.value.value, ast.Attribute) and\n+                    node.value.value.attr == \"defaults\" and\n+                    isinstance(node.value.value.value, ast.Name) and\n+                    node.value.value.value.id == \"salt\"):\n+                    ex_state_failure_found = True\n+                    break\n+\n+        self.assertFalse(ex_state_failure_found, \"salt.defaults.exitcodes.EX_STATE_FAILURE should not exist in tests/pytests/integration/cli/test_salt_call.py\")\n+\n+    def test_ex_state_fail_is_used_in_test_salt_call(self):\n+        file_path = 'tests/pytests/integration/cli/test_salt_call.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        ex_state_fail_found = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.Attribute):\n+                if (node.attr == \"EX_STATE_FAIL\" and\n+                    isinstance(node.value, ast.Attribute) and\n+                    node.value.attr == \"exitcodes\" and\n+                    isinstance(node.value.value, ast.Attribute) and\n+                    node.value.value.attr == \"defaults\" and\n+                    isinstance(node.value.value.value, ast.Name) and\n+                    node.value.value.value.id == \"salt\"):\n+                    ex_state_fail_found = True\n+                    break\n+\n+        self.assertTrue(ex_state_fail_found, \"salt.defaults.exitcodes.EX_STATE_FAIL was not found in tests/pytests/integration/cli/test_salt_call.py\")\n+\n+if __name__ == '__main__':\n+    unittest.main()",
    "problem_statement": "Rename EX_STATE_FAILURE to EX_STATE_FAIL and update all references throughout the repository.",
    "hints_text": "",
    "created_at": "2025-11-03 22:46:32+00:00",
    "language": "Python",
    "Dockerfile": "N/A",
    "test_command": "python3 -m unittest ex-state-fail-test.py",
    "task_category": "Refactoring",
    "data_source": "microsoft/RefactorBench",
    "scenario": "brownfield"
  },
  {
    "repo": "saltstack/salt",
    "url": "https://github.com/saltstack/salt",
    "instance_id": "channel-to-transport",
    "base_commit": "channel-to-transport",
    "patch": "N/A",
    "test_patch": "diff --git a/channel-to-transport-test.py b/channel-to-transport-test.py\nnew file mode 100644\nindex 0000000..5f69559\n--- /dev/null\n+++ b/channel-to-transport-test.py\n@@ -0,0 +1,85 @@\n+import unittest\n+import os\n+import ast\n+\n+class TestSaltUtilsAndMaster(unittest.TestCase):\n+\n+    def test_channel_py_does_not_exist(self):\n+        file_path = 'salt/utils/channel.py'\n+        self.assertFalse(os.path.exists(file_path), f\"{file_path} should not exist\")\n+\n+    def test_transport_py_exists(self):\n+        file_path = 'salt/utils/transport.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+    def test_transport_has_iter_transport_opts(self):\n+        file_path = 'salt/utils/transport.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        iter_transport_opts_function = next(\n+            (node for node in ast.walk(tree) if isinstance(node, ast.FunctionDef) and node.name == 'iter_transport_opts'),\n+            None\n+        )\n+\n+        self.assertIsNotNone(iter_transport_opts_function, f\"'iter_transport_opts' function not found in {file_path}\")\n+\n+    def test_master_imports_iter_transport_opts(self):\n+        file_path = 'salt/master.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        import_statement_exists = any(\n+            isinstance(node, ast.ImportFrom) and\n+            node.module == 'salt.utils.transport' and\n+            any(alias.name == 'iter_transport_opts' for alias in node.names)\n+            for node in ast.walk(tree)\n+        )\n+\n+        self.assertTrue(import_statement_exists, f\"'iter_transport_opts' is not imported from 'salt.utils.transport' in {file_path}\")\n+\n+    def test_imports_salt_utils_transport(self):\n+        file_path = 'salt/channel/server.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        import_statement_exists = any(\n+            isinstance(node, ast.Import) and\n+            any(alias.name == 'salt.utils.transport' for alias in node.names)\n+            for node in ast.walk(tree)\n+        )\n+\n+        self.assertTrue(import_statement_exists, f\"'import salt.utils.transport' is not found in {file_path}\")\n+\n+\n+    def test_uses_iter_transport_opts(self):\n+        file_path = 'salt/channel/server.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        iter_transport_opts_used = any(\n+            isinstance(node, ast.Call) and\n+            isinstance(node.func, ast.Attribute) and\n+            isinstance(node.func.value, ast.Attribute) and\n+            node.func.value.attr == 'transport' and\n+            node.func.attr == 'iter_transport_opts' and\n+            isinstance(node.args[0], ast.Name) and\n+            node.args[0].id == 'opts'\n+            for node in ast.walk(tree)\n+        )\n+\n+        self.assertTrue(\n+            iter_transport_opts_used,\n+            f\"'salt.utils.transport.iter_transport_opts(opts)' is not used in {file_path}\"\n+        )\n+        \n+if __name__ == '__main__':\n+    unittest.main()",
    "problem_statement": "Rename utils channel.py to transport.py and update the repository based on that change.",
    "hints_text": "",
    "created_at": "2025-11-03 22:46:32+00:00",
    "language": "Python",
    "Dockerfile": "N/A",
    "test_command": "python3 -m unittest channel-to-transport-test.py",
    "task_category": "Refactoring",
    "data_source": "microsoft/RefactorBench",
    "scenario": "brownfield"
  },
  {
    "repo": "saltstack/salt",
    "url": "https://github.com/saltstack/salt",
    "instance_id": "ex-pillar-fail",
    "base_commit": "ex-pillar-fail",
    "patch": "N/A",
    "test_patch": "diff --git a/ex-pillar-fail-test.py b/ex-pillar-fail-test.py\nnew file mode 100644\nindex 0000000..92a883f\n--- /dev/null\n+++ b/ex-pillar-fail-test.py\n@@ -0,0 +1,121 @@\n+import unittest\n+import os\n+import ast\n+\n+class TestSaltUtilsSMB(unittest.TestCase):\n+\n+    def test_ex_pillar_fail_in_exitcodes(self):\n+        file_path = 'salt/defaults/exitcodes.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        ex_pillar_fail_found = False\n+        ex_pillar_failure_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.Assign):\n+                for target in node.targets:\n+                    if isinstance(target, ast.Name):\n+                        if target.id == 'EX_PILLAR_FAIL':\n+                            ex_pillar_fail_found = True\n+                        if target.id == 'EX_PILLAR_FAILURE':\n+                            ex_pillar_failure_found = True\n+\n+        self.assertTrue(ex_pillar_fail_found, f\"'EX_PILLAR_FAIL' not found in {file_path}\")\n+        self.assertFalse(ex_pillar_failure_found, f\"'EX_PILLAR_FAILURE' (misspelled) found in {file_path}\")\n+\n+    def test_ex_pillar_failure_isnt_used_in_state_wrapper(self):\n+        file_path = 'salt/client/ssh/wrapper/state.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        ex_pillar_failure_found = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.Attribute):\n+                if (node.attr == \"EX_PILLAR_FAILURE\" and\n+                    isinstance(node.value, ast.Attribute) and\n+                    node.value.attr == \"exitcodes\" and\n+                    isinstance(node.value.value, ast.Attribute) and\n+                    node.value.value.attr == \"defaults\" and\n+                    isinstance(node.value.value.value, ast.Name) and\n+                    node.value.value.value.id == \"salt\"):\n+                    ex_pillar_failure_found = True\n+                    break\n+\n+        self.assertFalse(ex_pillar_failure_found, \"salt.defaults.exitcodes.EX_PILLAR_FAILURE was found in salt/client/ssh/wrapper/state.py, but it should not be used.\")\n+\n+    def test_ex_pillar_fail_is_used_in_state_wrapper(self):\n+        file_path = 'salt/client/ssh/wrapper/state.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        ex_pillar_fail_found = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.Attribute):\n+                if (node.attr == \"EX_PILLAR_FAIL\" and\n+                    isinstance(node.value, ast.Attribute) and\n+                    node.value.attr == \"exitcodes\" and\n+                    isinstance(node.value.value, ast.Attribute) and\n+                    node.value.value.attr == \"defaults\" and\n+                    isinstance(node.value.value.value, ast.Name) and\n+                    node.value.value.value.id == \"salt\"):\n+                    ex_pillar_fail_found = True\n+                    break\n+\n+        self.assertTrue(ex_pillar_fail_found, \"salt.defaults.exitcodes.EX_PILLAR_FAIL was not found in salt/client/ssh/wrapper/state.py\")\n+\n+    def test_ex_pillar_failure_isnt_used_in_state_module(self):\n+        file_path = 'salt/modules/state.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        ex_pillar_failure_found = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.Attribute):\n+                if (node.attr == \"EX_PILLAR_FAILURE\" and\n+                    isinstance(node.value, ast.Attribute) and\n+                    node.value.attr == \"exitcodes\" and\n+                    isinstance(node.value.value, ast.Attribute) and\n+                    node.value.value.attr == \"defaults\" and\n+                    isinstance(node.value.value.value, ast.Name) and\n+                    node.value.value.value.id == \"salt\"):\n+                    ex_pillar_failure_found = True\n+                    break\n+\n+        self.assertFalse(ex_pillar_failure_found, \"salt.defaults.exitcodes.EX_PILLAR_FAILURE was found in salt/modules/state.py, but it should not be used.\")\n+\n+    def test_ex_pillar_fail_is_used_in_state_module(self):\n+        file_path = 'salt/modules/state.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        ex_pillar_fail_found = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.Attribute):\n+                if (node.attr == \"EX_PILLAR_FAIL\" and\n+                    isinstance(node.value, ast.Attribute) and\n+                    node.value.attr == \"exitcodes\" and\n+                    isinstance(node.value.value, ast.Attribute) and\n+                    node.value.value.attr == \"defaults\" and\n+                    isinstance(node.value.value.value, ast.Name) and\n+                    node.value.value.value.id == \"salt\"):\n+                    ex_pillar_fail_found = True\n+                    break\n+\n+        self.assertTrue(ex_pillar_fail_found, \"salt.defaults.exitcodes.EX_PILLAR_FAIL was not found in salt/modules/state.py\")\n+\n+if __name__ == '__main__':\n+    unittest.main()",
    "problem_statement": "Rename EX_PILLAR_FAILURE to EX_PILLAR_FAIL and update the references throughout the repo.",
    "hints_text": "",
    "created_at": "2025-11-03 22:46:32+00:00",
    "language": "Python",
    "Dockerfile": "N/A",
    "test_command": "python3 -m unittest ex-pillar-fail-test.py",
    "task_category": "Refactoring",
    "data_source": "microsoft/RefactorBench",
    "scenario": "brownfield"
  },
  {
    "repo": "saltstack/salt",
    "url": "https://github.com/saltstack/salt",
    "instance_id": "iam-to-aws",
    "base_commit": "iam-to-aws",
    "patch": "N/A",
    "test_patch": "diff --git a/iam-to-aws-test.py b/iam-to-aws-test.py\nnew file mode 100644\nindex 0000000..148594f\n--- /dev/null\n+++ b/iam-to-aws-test.py\n@@ -0,0 +1,63 @@\n+import unittest\n+import os\n+import ast\n+\n+class TestSaltUtilsAWS(unittest.TestCase):\n+\n+    def test_aws_py_exists(self):\n+        file_path = 'salt/utils/aws.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+    def test_aws_py_imports_pprint(self):\n+        file_path = 'salt/utils/aws.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        pprint_imported = any(\n+            isinstance(node, ast.ImportFrom) and node.module == 'pprint'\n+            for node in ast.walk(tree)\n+        ) or any(\n+            isinstance(node, ast.Import) and any(alias.name == 'pprint' for alias in node.names)\n+            for node in ast.walk(tree)\n+        )\n+\n+        self.assertTrue(pprint_imported, f\"'pprint' is not imported in {file_path}\")\n+\n+    def test_convert_key_to_str_function_exists(self):\n+        file_path = 'salt/utils/aws.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        convert_key_to_str_function = None\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.FunctionDef) and node.name == '_convert_key_to_str':\n+                convert_key_to_str_function = node\n+                break\n+\n+        self.assertIsNotNone(convert_key_to_str_function, f\"'_convert_key_to_str' function not found in {file_path}\")\n+\n+    def test_retry_get_url_function_exists(self):\n+        file_path = 'salt/utils/aws.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        retry_get_url_function = None\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.FunctionDef) and node.name == '_retry_get_url':\n+                retry_get_url_function = node\n+                break\n+\n+        self.assertIsNotNone(retry_get_url_function, f\"'_retry_get_url' function not found in {file_path}\")\n+\n+    def test_utils_iam_py_does_not_exist(self):\n+        file_path = 'utils/iam.py'\n+        self.assertFalse(os.path.exists(file_path), f\"{file_path} should not exist\")\n+\n+if __name__ == '__main__':\n+    unittest.main()",
    "problem_statement": "Remove the iam.py file and move all of it into the aws utils file and update the repository accordingly.",
    "hints_text": "",
    "created_at": "2025-11-03 22:46:32+00:00",
    "language": "Python",
    "Dockerfile": "N/A",
    "test_command": "python3 -m unittest iam-to-aws-test.py",
    "task_category": "Refactoring",
    "data_source": "microsoft/RefactorBench",
    "scenario": "brownfield"
  },
  {
    "repo": "saltstack/salt",
    "url": "https://github.com/saltstack/salt",
    "instance_id": "pem-fingerprint",
    "base_commit": "pem-fingerprint",
    "patch": "N/A",
    "test_patch": "diff --git a/pem-fingerprint-test.py b/pem-fingerprint-test.py\nnew file mode 100644\nindex 0000000..ab294e8\n--- /dev/null\n+++ b/pem-fingerprint-test.py\n@@ -0,0 +1,131 @@\n+import unittest\n+import os\n+import ast\n+\n+class TestSaltCryptFunctions(unittest.TestCase):\n+\n+    def test_salt_cloud_init_py(self):\n+        file_path = 'salt/cloud/__init__.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        old_function_found = any(isinstance(node, ast.Attribute) and node.attr == 'pem_finger' for node in ast.walk(tree))\n+        new_function_found = any(isinstance(node, ast.Attribute) and node.attr == 'pem_fingerprint' for node in ast.walk(tree))\n+\n+        self.assertFalse(old_function_found, f\"'pem_finger' found in {file_path}, but it should not be used\")\n+        self.assertTrue(new_function_found, f\"'pem_fingerprint' not found in {file_path}, but it should be used\")\n+\n+    def test_salt_crypt_py(self):\n+        file_path = 'salt/crypt.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        old_function_found = any(isinstance(node, ast.Attribute) and node.attr == 'pem_finger' for node in ast.walk(tree))\n+        new_function_found = any(isinstance(node, ast.Attribute) and node.attr == 'pem_fingerprint' for node in ast.walk(tree))\n+\n+        self.assertFalse(old_function_found, f\"'pem_finger' found in {file_path}, but it should not be used\")\n+        self.assertTrue(new_function_found, f\"'pem_fingerprint' not found in {file_path}, but it should be used\")\n+\n+    def test_salt_key_py(self):\n+        file_path = 'salt/key.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        old_function_found = any(isinstance(node, ast.Attribute) and node.attr == 'pem_finger' for node in ast.walk(tree))\n+        new_function_found = any(isinstance(node, ast.Attribute) and node.attr == 'pem_fingerprint' for node in ast.walk(tree))\n+\n+        self.assertFalse(old_function_found, f\"'pem_finger' found in {file_path}, but it should not be used\")\n+        self.assertTrue(new_function_found, f\"'pem_fingerprint' not found in {file_path}, but it should be used\")\n+\n+    def test_salt_modules_key_py(self):\n+        file_path = 'salt/modules/key.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        old_function_found = any(isinstance(node, ast.Attribute) and node.attr == 'pem_finger' for node in ast.walk(tree))\n+        new_function_found = any(isinstance(node, ast.Attribute) and node.attr == 'pem_fingerprint' for node in ast.walk(tree))\n+\n+        self.assertFalse(old_function_found, f\"'pem_finger' found in {file_path}, but it should not be used\")\n+        self.assertTrue(new_function_found, f\"'pem_fingerprint' not found in {file_path}, but it should be used\")\n+\n+    def test_salt_utils_cloud_py(self):\n+        file_path = 'salt/utils/cloud.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        old_function_found = any(isinstance(node, ast.Attribute) and node.attr == 'pem_finger' for node in ast.walk(tree))\n+        new_function_found = any(isinstance(node, ast.Attribute) and node.attr == 'pem_fingerprint' for node in ast.walk(tree))\n+\n+        self.assertFalse(old_function_found, f\"'pem_finger' found in {file_path}, but it should not be used\")\n+        self.assertTrue(new_function_found, f\"'pem_fingerprint' not found in {file_path}, but it should be used\")\n+\n+    def test_salt_wheel_key_py(self):\n+        file_path = 'salt/wheel/key.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        old_function_found = any(isinstance(node, ast.Attribute) and node.attr == 'pem_finger' for node in ast.walk(tree))\n+        new_function_found = any(isinstance(node, ast.Attribute) and node.attr == 'pem_fingerprint' for node in ast.walk(tree))\n+\n+        self.assertFalse(old_function_found, f\"'pem_finger' found in {file_path}, but it should not be used\")\n+        self.assertTrue(new_function_found, f\"'pem_fingerprint' not found in {file_path}, but it should be used\")\n+\n+    def test_tests_pytests_unit_utils_test_crypt_py(self):\n+        file_path = 'tests/pytests/unit/utils/test_crypt.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        old_function_found = any(isinstance(node, ast.Attribute) and node.attr == 'pem_finger' for node in ast.walk(tree))\n+        new_function_found = any(isinstance(node, ast.Attribute) and node.attr == 'pem_fingerprint' for node in ast.walk(tree))\n+\n+        self.assertFalse(old_function_found, f\"'pem_finger' found in {file_path}, but it should not be used\")\n+        self.assertTrue(new_function_found, f\"'pem_fingerprint' not found in {file_path}, but it should be used\")\n+\n+    def test_pem_finger_def_not_exists_in_utils_crypt(self):\n+        file_path = 'salt/utils/crypt.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        pem_finger_def_found = any(isinstance(node, ast.FunctionDef) and node.name == 'pem_finger' for node in ast.walk(tree))\n+\n+        self.assertFalse(pem_finger_def_found, f\"Function definition 'pem_finger' found in {file_path}, but it should not exist\")\n+\n+    def test_pem_fingerprint_def_exists_in_utils_crypt(self):\n+        file_path = 'salt/utils/crypt.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        pem_fingerprint_def_found = any(isinstance(node, ast.FunctionDef) and node.name == 'pem_fingerprint' for node in ast.walk(tree))\n+\n+        self.assertTrue(pem_fingerprint_def_found, f\"Function definition 'pem_fingerprint' not found in {file_path}, but it should exist\")\n+\n+    def test_patch_pem_fingerprint_in_test_key_py(self):\n+        file_path = 'tests/pytests/unit/modules/test_key.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            content = file.read()\n+\n+        self.assertIn(\"patch.object\", content, f\"'patch.object' not found in {file_path}\")\n+        self.assertIn(\"pem_fingerprint\", content, f\"'pem_fingerprint' not found in a patch.object() call in {file_path}\")\n+\n+if __name__ == '__main__':\n+    unittest.main()",
    "problem_statement": "Rename pem_finger to pem_fingerprint and update the usage of the crypt function throughout the repo without changing any function names or variable names.",
    "hints_text": "",
    "created_at": "2025-11-03 22:46:32+00:00",
    "language": "Python",
    "Dockerfile": "N/A",
    "test_command": "python3 -m unittest pem-fingerprint-test.py",
    "task_category": "Refactoring",
    "data_source": "microsoft/RefactorBench",
    "scenario": "brownfield"
  },
  {
    "repo": "tornadoweb/tornado",
    "url": "https://github.com/tornadoweb/tornado",
    "instance_id": "global-objects",
    "base_commit": "global-objects",
    "patch": "N/A",
    "test_patch": "diff --git a/global-objects-test.py b/global-objects-test.py\nnew file mode 100644\nindex 0000000..80acb56\n--- /dev/null\n+++ b/global-objects-test.py\n@@ -0,0 +1,112 @@\n+import unittest\n+import os\n+import ast\n+\n+class TestTornadoImports(unittest.TestCase):\n+\n+    def test_import_in_wsgi_py(self):\n+        # Path to the file where the import should be checked\n+        file_path = 'tornado/wsgi.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Read and parse the content of wsgi.py\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        # Check if 'from tornado._globals import dummy_executor' exists\n+        import_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom) and node.module == 'tornado._globals':\n+                if any(alias.name == 'dummy_executor' for alias in node.names):\n+                    import_found = True\n+                    break\n+\n+        self.assertTrue(import_found, \"'from tornado._globals import dummy_executor' not found in wsgi.py\")\n+\n+    def test_imports_in_netutil_py(self):\n+        # Path to the file where the imports should be checked\n+        file_path = 'tornado/netutil.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Read and parse the content of netutil.py\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        # Check if 'from tornado._globals import dummy_executor' and 'from tornado.concurrent import run_on_executor' exist\n+        import_globals_found = False\n+        import_concurrent_found = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom):\n+                if node.module == 'tornado._globals':\n+                    if any(alias.name == 'dummy_executor' for alias in node.names):\n+                        import_globals_found = True\n+                if node.module == 'tornado.concurrent':\n+                    if any(alias.name == 'run_on_executor' for alias in node.names):\n+                        import_concurrent_found = True\n+\n+        self.assertTrue(import_globals_found, \"'from tornado._globals import dummy_executor' not found in netutil.py\")\n+        self.assertTrue(import_concurrent_found, \"'from tornado.concurrent import run_on_executor' not found in netutil.py\")\n+\n+    def test_globals_py_exists_and_has_dummy_executor(self):\n+        # Path to the file where the existence and content should be checked\n+        file_path = 'tornado/_globals.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Read and parse the content of _globals.py\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        # Check if 'from tornado.concurrent import DummyExecutor' exists and dummy_executor is defined\n+        import_found = False\n+        dummy_executor_defined = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom) and node.module == 'tornado.concurrent':\n+                if any(alias.name == 'DummyExecutor' for alias in node.names):\n+                    import_found = True\n+            if isinstance(node, ast.Assign):\n+                if (isinstance(node.targets[0], ast.Name) and\n+                        node.targets[0].id == 'dummy_executor' and\n+                        isinstance(node.value, ast.Call) and\n+                        isinstance(node.value.func, ast.Name) and\n+                        node.value.func.id == 'DummyExecutor'):\n+                    dummy_executor_defined = True\n+\n+        self.assertTrue(import_found, \"'from tornado.concurrent import DummyExecutor' not found in _globals.py\")\n+        self.assertTrue(dummy_executor_defined, \"'dummy_executor = DummyExecutor()' not found in _globals.py\")\n+\n+    def test_concurrent_py_does_not_have_dummy_executor(self):\n+        # Path to the file where we should ensure dummy_executor is not defined\n+        file_path = 'tornado/concurrent.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Read and parse the content of concurrent.py\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        # Ensure 'dummy_executor = DummyExecutor()' is not present\n+        dummy_executor_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.Assign):\n+                if (isinstance(node.targets[0], ast.Name) and\n+                        node.targets[0].id == 'dummy_executor' and\n+                        isinstance(node.value, ast.Call) and\n+                        isinstance(node.value.func, ast.Name) and\n+                        node.value.func.id == 'DummyExecutor'):\n+                    dummy_executor_found = True\n+                    break\n+\n+        self.assertFalse(dummy_executor_found, \"'dummy_executor = DummyExecutor()' should not be found in concurrent.py\")\n+\n+\n+if __name__ == '__main__':\n+    unittest.main()\n\\ No newline at end of file",
    "problem_statement": "tornado.concurrent.dummy_executor is supposed to be referenced globally. Move it into a `_globals.py`.",
    "hints_text": "",
    "created_at": "2025-11-03 22:46:32+00:00",
    "language": "Python",
    "Dockerfile": "N/A",
    "test_command": "python3 -m unittest global-objects-test.py",
    "task_category": "Refactoring",
    "data_source": "microsoft/RefactorBench",
    "scenario": "brownfield"
  },
  {
    "repo": "tornadoweb/tornado",
    "url": "https://github.com/tornadoweb/tornado",
    "instance_id": "resolvers-as-separate",
    "base_commit": "resolvers-as-separate",
    "patch": "N/A",
    "test_patch": "diff --git a/resolvers-as-separate-test.py b/resolvers-as-separate-test.py\nnew file mode 100644\nindex 0000000..ac5a18a\n--- /dev/null\n+++ b/resolvers-as-separate-test.py\n@@ -0,0 +1,422 @@\n+import unittest\n+import os\n+import ast\n+\n+class TestTornadoImports(unittest.TestCase):\n+\n+    def test_import_resolver_in_websocket(self):\n+        # Path to the file where the import should be checked\n+        file_path = 'tornado/websocket.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Read and parse the content of websocket.py\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        # Check if 'from tornado.resolver import Resolver' is present\n+        import_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom):\n+                if node.module == 'tornado.resolver' and \\\n+                   any(alias.name == 'Resolver' for alias in node.names):\n+                    import_found = True\n+                    break\n+\n+        self.assertTrue(import_found, \"Import 'from tornado.resolver import Resolver' not found in websocket.py\")\n+\n+    def test_import_resolver_in_websocket_test(self):\n+        # Path to the file where the import should be checked\n+        file_path = 'tornado/test/websocket_test.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Read and parse the content of websocket_test.py\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        # Check if 'from tornado.resolver import Resolver' is present\n+        import_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom):\n+                if node.module == 'tornado.resolver' and \\\n+                   any(alias.name == 'Resolver' for alias in node.names):\n+                    import_found = True\n+                    break\n+\n+        self.assertTrue(import_found, \"Import 'from tornado.resolver import Resolver' not found in websocket_test.py\")\n+\n+    def test_import_resolver_in_tcpclient_test(self):\n+        # Path to the file where the imports should be checked\n+        file_path = 'tornado/test/tcpclient_test.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Read and parse the content of tcpclient_test.py\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        # Check if 'from tornado.resolver import Resolver' is present\n+        resolver_import_found = False\n+        bind_sockets_import_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom):\n+                if node.module == 'tornado.resolver' and \\\n+                   any(alias.name == 'Resolver' for alias in node.names):\n+                    resolver_import_found = True\n+                if node.module == 'tornado.netutil' and \\\n+                   any(alias.name == 'bind_sockets' for alias in node.names):\n+                    bind_sockets_import_found = True\n+\n+        self.assertTrue(resolver_import_found, \"Import 'from tornado.resolver import Resolver' not found in tcpclient_test.py\")\n+        self.assertTrue(bind_sockets_import_found, \"Import 'from tornado.netutil import bind_sockets' not found in tcpclient_test.py\")\n+\n+    def test_import_resolver_in_simple_httpclient_test(self):\n+        # Path to the file where the imports should be checked\n+        file_path = 'tornado/test/simple_httpclient_test.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Read and parse the content of simple_httpclient_test.py\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        # Check if 'from tornado.resolver import Resolver' is present\n+        resolver_import_found = False\n+        bind_sockets_import_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom):\n+                if node.module == 'tornado.resolver' and \\\n+                   any(alias.name == 'Resolver' for alias in node.names):\n+                    resolver_import_found = True\n+                if node.module == 'tornado.netutil' and \\\n+                   any(alias.name == 'bind_sockets' for alias in node.names):\n+                    bind_sockets_import_found = True\n+\n+        self.assertTrue(resolver_import_found, \"Import 'from tornado.resolver import Resolver' not found in simple_httpclient_test.py\")\n+        self.assertTrue(bind_sockets_import_found, \"Import 'from tornado.netutil import bind_sockets' not found in simple_httpclient_test.py\")\n+\n+    def test_import_resolver_in_runtests(self):\n+        # Path to the file where the import should be checked\n+        file_path = 'tornado/test/runtests.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Read and parse the content of runtests.py\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        # Check if 'from tornado.resolver import Resolver' is present\n+        import_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom):\n+                if node.module == 'tornado.resolver' and \\\n+                   any(alias.name == 'Resolver' for alias in node.names):\n+                    import_found = True\n+                    break\n+\n+        self.assertTrue(import_found, \"Import 'from tornado.resolver import Resolver' not found in runtests.py\")\n+\n+    def test_import_resolver_in_tcpclient(self):\n+        # Path to the file where the import should be checked\n+        file_path = 'tornado/tcpclient.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Read and parse the content of tcpclient.py\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        # Check if 'from tornado.resolver import Resolver' is present\n+        import_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom):\n+                if node.module == 'tornado.resolver' and \\\n+                   any(alias.name == 'Resolver' for alias in node.names):\n+                    import_found = True\n+                    break\n+\n+        self.assertTrue(import_found, \"Import 'from tornado.resolver import Resolver' not found in tcpclient.py\")\n+\n+    def test_import_resolver_and_errno_in_netutil(self):\n+        # Path to the file where the imports should be checked\n+        file_path = 'tornado/netutil.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Read and parse the content of netutil.py\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        resolver_import_found = False\n+        threaded_resolver_import_found = False\n+        errno_import_found = False\n+\n+        # Check if 'from tornado.resolver import Resolver, ThreadedResolver' and 'from tornado.util import errno_from_exception' are present\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom):\n+                if node.module == 'tornado.resolver' and \\\n+                any(alias.name == 'Resolver' for alias in node.names) and \\\n+                any(alias.name == 'ThreadedResolver' for alias in node.names):\n+                    resolver_import_found = True\n+                    threaded_resolver_import_found = True\n+                if node.module == 'tornado.util' and \\\n+                any(alias.name == 'errno_from_exception' for alias in node.names):\n+                    errno_import_found = True\n+\n+        self.assertTrue(resolver_import_found and threaded_resolver_import_found, \n+                        \"Import 'from tornado.resolver import Resolver, ThreadedResolver' not found in netutil.py\")\n+        self.assertTrue(errno_import_found, \n+                        \"Import 'from tornado.util import errno_from_exception' not found in netutil.py\")\n+    \n+    def test_import_is_valid_ip_and_resolver_in_caresresolver(self):\n+        # Path to the file where the imports should be checked\n+        file_path = 'tornado/platform/caresresolver.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Read and parse the content of caresresolver.py\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        is_valid_ip_import_found = False\n+        resolver_import_found = False\n+\n+        # Check if 'from tornado.netutil import is_valid_ip' and 'from tornado.resolver import Resolver' are present\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom):\n+                if node.module == 'tornado.netutil' and \\\n+                any(alias.name == 'is_valid_ip' for alias in node.names):\n+                    is_valid_ip_import_found = True\n+                if node.module == 'tornado.resolver' and \\\n+                any(alias.name == 'Resolver' for alias in node.names):\n+                    resolver_import_found = True\n+\n+        self.assertTrue(is_valid_ip_import_found, \n+                        \"Import 'from tornado.netutil import is_valid_ip' not found in caresresolver.py\")\n+        self.assertTrue(resolver_import_found, \n+                        \"Import 'from tornado.resolver import Resolver' not found in caresresolver.py\")\n+    \n+    def test_resolver_file_exists(self):\n+        # Path to the file that should be checked\n+        file_path = 'tornado/resolver.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+    def test_class_resolver_exists(self):\n+        # Path to the file where the class should be checked\n+        file_path = 'tornado/resolver.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Read and parse the content of resolver.py\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        # Check if class Resolver(Configurable) is present\n+        class_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ClassDef) and node.name == 'Resolver':\n+                for base in node.bases:\n+                    if isinstance(base, ast.Name) and base.id == 'Configurable':\n+                        class_found = True\n+                        break\n+\n+        self.assertTrue(class_found, \"Class 'Resolver(Configurable)' not found in resolver.py\")\n+\n+    def test_method_resolve_addr_exists(self):\n+        # Path to the file where the method should be checked\n+        file_path = 'tornado/resolver.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Read and parse the content of resolver.py\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        # Check if method _resolve_addr exists\n+        method_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.FunctionDef) and node.name == '_resolve_addr':\n+                method_found = True\n+                break\n+\n+        self.assertTrue(method_found, \"Method '_resolve_addr' not found in resolver.py\")\n+\n+    def test_class_default_executor_resolver_exists(self):\n+        # Path to the file where the class should be checked\n+        file_path = 'tornado/resolver.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Read and parse the content of resolver.py\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        # Check if class DefaultExecutorResolver(Resolver) is present\n+        class_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ClassDef) and node.name == 'DefaultExecutorResolver':\n+                for base in node.bases:\n+                    if isinstance(base, ast.Name) and base.id == 'Resolver':\n+                        class_found = True\n+                        break\n+\n+        self.assertTrue(class_found, \"Class 'DefaultExecutorResolver(Resolver)' not found in resolver.py\")\n+\n+    def test_class_default_loop_resolver_exists(self):\n+        # Path to the file where the class should be checked\n+        file_path = 'tornado/resolver.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Read and parse the content of resolver.py\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        # Check if class DefaultLoopResolver(Resolver) is present\n+        class_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ClassDef) and node.name == 'DefaultLoopResolver':\n+                for base in node.bases:\n+                    if isinstance(base, ast.Name) and base.id == 'Resolver':\n+                        class_found = True\n+                        break\n+\n+        self.assertTrue(class_found, \"Class 'DefaultLoopResolver(Resolver)' not found in resolver.py\")\n+\n+    def test_class_executor_resolver_exists(self):\n+        # Path to the file where the class should be checked\n+        file_path = 'tornado/resolver.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Read and parse the content of resolver.py\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        # Check if class ExecutorResolver(Resolver) is present\n+        class_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ClassDef) and node.name == 'ExecutorResolver':\n+                for base in node.bases:\n+                    if isinstance(base, ast.Name) and base.id == 'Resolver':\n+                        class_found = True\n+                        break\n+\n+        self.assertTrue(class_found, \"Class 'ExecutorResolver(Resolver)' not found in resolver.py\")\n+\n+    def test_class_blocking_resolver_exists(self):\n+        # Path to the file where the class should be checked\n+        file_path = 'tornado/resolver.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Read and parse the content of resolver.py\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        # Check if class BlockingResolver(ExecutorResolver) is present\n+        class_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ClassDef) and node.name == 'BlockingResolver':\n+                for base in node.bases:\n+                    if isinstance(base, ast.Name) and base.id == 'ExecutorResolver':\n+                        class_found = True\n+                        break\n+\n+        self.assertTrue(class_found, \"Class 'BlockingResolver(ExecutorResolver)' not found in resolver.py\")\n+\n+    def test_class_threaded_resolver_exists(self):\n+        # Path to the file where the class should be checked\n+        file_path = 'tornado/resolver.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Read and parse the content of resolver.py\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        # Check if class ThreadedResolver(ExecutorResolver) is present\n+        class_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ClassDef) and node.name == 'ThreadedResolver':\n+                for base in node.bases:\n+                    if isinstance(base, ast.Name) and base.id == 'ExecutorResolver':\n+                        class_found = True\n+                        break\n+\n+        self.assertTrue(class_found, \"Class 'ThreadedResolver(ExecutorResolver)' not found in resolver.py\")\n+\n+    def test_class_override_resolver_exists(self):\n+            # Path to the file where the class should be checked\n+            file_path = 'tornado/resolver.py'\n+\n+            # Check if the file exists\n+            self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+            # Read and parse the content of resolver.py\n+            with open(file_path, 'r') as file:\n+                tree = ast.parse(file.read())\n+\n+            # Check if class OverrideResolver(Resolver) is present\n+            class_found = False\n+            for node in ast.walk(tree):\n+                if isinstance(node, ast.ClassDef) and node.name == 'OverrideResolver':\n+                    for base in node.bases:\n+                        if isinstance(base, ast.Name) and base.id == 'Resolver':\n+                            class_found = True\n+                            break\n+\n+            self.assertTrue(class_found, \"Class 'OverrideResolver(Resolver)' not found in resolver.py\")\n+\n+    def test_imports_in_simple_httpclient(self):\n+        # Path to the file where the imports should be checked\n+        file_path = 'tornado/simple_httpclient.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Read and parse the content of simple_httpclient.py\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        ssl_defaults_import_found = False\n+        is_valid_ip_import_found = False\n+        resolver_import_found = False\n+        override_resolver_import_found = False\n+\n+        # Check if 'from tornado.netutil import _client_ssl_defaults, is_valid_ip' \n+        # and 'from tornado.resolver import Resolver, OverrideResolver' are present\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom):\n+                if node.module == 'tornado.netutil':\n+                    ssl_defaults_import_found = any(alias.name == '_client_ssl_defaults' for alias in node.names)\n+                    is_valid_ip_import_found = any(alias.name == 'is_valid_ip' for alias in node.names)\n+                if node.module == 'tornado.resolver':\n+                    resolver_import_found = any(alias.name == 'Resolver' for alias in node.names)\n+                    override_resolver_import_found = any(alias.name == 'OverrideResolver' for alias in node.names)\n+\n+        self.assertTrue(ssl_defaults_import_found and is_valid_ip_import_found, \n+                        \"Import 'from tornado.netutil import _client_ssl_defaults, is_valid_ip' not found in simple_httpclient.py\")\n+        self.assertTrue(resolver_import_found and override_resolver_import_found, \n+                        \"Import 'from tornado.resolver import Resolver, OverrideResolver' not found in simple_httpclient.py\")\n+\n+if __name__ == '__main__':\n+    unittest.main()\n\\ No newline at end of file",
    "problem_statement": "Can you move the Resolver, and its child classes in tornado.netutils into a newly created file called resolver.py. Also update all usages through the repository.",
    "hints_text": "",
    "created_at": "2025-11-03 22:46:32+00:00",
    "language": "Python",
    "Dockerfile": "N/A",
    "test_command": "python3 -m unittest resolvers-as-separate-test.py",
    "task_category": "Refactoring",
    "data_source": "microsoft/RefactorBench",
    "scenario": "brownfield"
  },
  {
    "repo": "tornadoweb/tornado",
    "url": "https://github.com/tornadoweb/tornado",
    "instance_id": "rename-to-camel-case",
    "base_commit": "rename-to-camel-case",
    "patch": "N/A",
    "test_patch": "diff --git a/rename-to-camel-case-test.py b/rename-to-camel-case-test.py\nnew file mode 100644\nindex 0000000..a223adc\n--- /dev/null\n+++ b/rename-to-camel-case-test.py\n@@ -0,0 +1,102 @@\n+import unittest\n+import os\n+import ast\n+\n+class TestTornadoMigration(unittest.TestCase):\n+\n+    def test_getNewIoLoop_used_in_gen_test(self):\n+        # Path to the file to check for the function usage\n+        file_path = 'tornado/test/gen_test.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Read and parse the content of gen_test.py\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        getNewIoLoop_found = False\n+        get_new_ioloop_found = False\n+\n+        # Check for the usage of self.getNewIoLoop() and self.get_new_ioloop()\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.Call) and isinstance(node.func, ast.Attribute):\n+                if node.func.attr == 'getNewIoLoop':\n+                    getNewIoLoop_found = True\n+                elif node.func.attr == 'get_new_ioloop':\n+                    get_new_ioloop_found = True\n+\n+        self.assertTrue(getNewIoLoop_found, \"self.getNewIoLoop() not found in gen_test.py\")\n+        self.assertFalse(get_new_ioloop_found, \"self.get_new_ioloop() found in gen_test.py, but it should not be present\")\n+\n+\n+    def test_AsyncTestCase_getNewIoLoop_in_ast(self):\n+        # Path to the file to check for AST usage\n+        file_path = 'tornado/testing.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Parse the content of testing.py as an AST\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        # Check for AsyncTestCase.getNewIoLoop\n+        AsyncTestCase_getNewIoLoop_found = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.Attribute):\n+                if node.attr == 'getNewIoLoop' and isinstance(node.value, ast.Name) and node.value.id == 'AsyncTestCase':\n+                    AsyncTestCase_getNewIoLoop_found = True\n+\n+        self.assertTrue(AsyncTestCase_getNewIoLoop_found, \"AsyncTestCase.getNewIoLoop not found in testing.py\")\n+\n+    def test_self_getNewIoLoop_in_ast(self):\n+        # Path to the file to check for AST usage\n+        file_path = 'tornado/testing.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Parse the content of testing.py as an AST\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        # Check for self.getNewIoLoop()\n+        self_getNewIoLoop_found = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.Call) and isinstance(node.func, ast.Attribute):\n+                if node.func.attr == 'getNewIoLoop':\n+                    if isinstance(node.func.value, ast.Name) and node.func.value.id == 'self':\n+                        self_getNewIoLoop_found = True\n+\n+        self.assertTrue(self_getNewIoLoop_found, \"self.getNewIoLoop() not found in testing.py\")\n+\n+    def test_def_getNewIoLoop_in_ast(self):\n+        # Path to the file to check for AST usage\n+        file_path = 'tornado/testing.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Parse the content of testing.py as an AST\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        # Check for def getNewIoLoop(self)\n+        def_getNewIoLoop_found = False\n+        def_get_new_ioloop_found = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.FunctionDef):\n+                if node.name == 'getNewIoLoop':\n+                    def_getNewIoLoop_found = True\n+                elif node.name == 'get_new_ioloop':\n+                    def_get_new_ioloop_found = True\n+\n+        self.assertTrue(def_getNewIoLoop_found, \"def getNewIoLoop(self) not found in testing.py\")\n+        self.assertFalse(def_get_new_ioloop_found, \"def get_new_ioloop(self) found in testing.py, but it should not be present\")\n+\n+if __name__ == '__main__':\n+    unittest.main()\n\\ No newline at end of file",
    "problem_statement": "Rename the method `tornado.testing.AsyncTestCase.get_new_ioloop()` to camel case: getNewIoLoop() and update all references in the repo accordingly.",
    "hints_text": "",
    "created_at": "2025-11-03 22:46:32+00:00",
    "language": "Python",
    "Dockerfile": "N/A",
    "test_command": "python3 -m unittest rename-to-camel-case-test.py",
    "task_category": "Refactoring",
    "data_source": "microsoft/RefactorBench",
    "scenario": "brownfield"
  },
  {
    "repo": "tornadoweb/tornado",
    "url": "https://github.com/tornadoweb/tornado",
    "instance_id": "option-parser-with-pretty-print",
    "base_commit": "option-parser-with-pretty-print",
    "patch": "N/A",
    "test_patch": "diff --git a/option-parser-with-pretty-print-test.py b/option-parser-with-pretty-print-test.py\nnew file mode 100644\nindex 0000000..acd6f1f\n--- /dev/null\n+++ b/option-parser-with-pretty-print-test.py\n@@ -0,0 +1,116 @@\n+import unittest\n+import os\n+import ast\n+\n+class TestTornadoOptionsImports(unittest.TestCase):\n+\n+    def test_import_logging_in_options_py(self):\n+        # Path to the file where the import should be checked\n+        file_path = 'tornado/options.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Read and parse the content of options.py\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        # Check if 'import logging' exists\n+        import_logging_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.Import) and any(alias.name == 'logging' for alias in node.names):\n+                import_logging_found = True\n+                break\n+\n+        self.assertTrue(import_logging_found, \"'import logging' not found in options.py\")\n+\n+    def test_import_logging_handlers_in_options_py(self):\n+        # Path to the file where the import should be checked\n+        file_path = 'tornado/options.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Read and parse the content of options.py\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        # Check if 'import logging.handlers' exists\n+        import_logging_handlers_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.Import) and any(alias.name == 'logging.handlers' for alias in node.names):\n+                import_logging_handlers_found = True\n+                break\n+\n+        self.assertTrue(import_logging_handlers_found, \"'import logging.handlers' not found in options.py\")\n+\n+    def test_import_from_tornado_log_in_options_py(self):\n+        # Path to the file where the import should be checked\n+        file_path = 'tornado/options.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Read and parse the content of options.py\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        # Check if 'from tornado.log import define_logging_options, LogFormatter' exists\n+        import_from_tornado_log_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom) and node.module == 'tornado.log':\n+                imported_names = {alias.name for alias in node.names}\n+                if 'define_logging_options' in imported_names and 'LogFormatter' in imported_names:\n+                    import_from_tornado_log_found = True\n+                    break\n+\n+        self.assertTrue(import_from_tornado_log_found, \n+            \"'from tornado.log import define_logging_options, LogFormatter' not found in options.py\")\n+\n+    def test_no_enable_pretty_logging_in_log_py(self):\n+        # Path to the file where the function should be checked\n+        file_path = 'tornado/log.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Read and parse the content of log.py\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        # Check if 'def enable_pretty_logging' exists\n+        enable_pretty_logging_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.FunctionDef) and node.name == 'enable_pretty_logging':\n+                enable_pretty_logging_found = True\n+                break\n+\n+        self.assertFalse(enable_pretty_logging_found, \n+                         \"'enable_pretty_logging' function found in log.py, but it should not be present\")\n+\n+    def test_import_from_tornado_options_in_log_test_py(self):\n+        # Path to the file where the import should be checked\n+        file_path = 'tornado/test/log_test.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Read and parse the content of log_test.py\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        # Check if 'from tornado.options import OptionParser, options' exists\n+        import_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom) and node.module == 'tornado.options':\n+                imported_names = {alias.name for alias in node.names}\n+                if 'OptionParser' in imported_names and 'options' in imported_names:\n+                    import_found = True\n+                    break\n+\n+        self.assertTrue(import_found, \n+                        \"'from tornado.options import OptionParser, options' not found in log_test.py\")\n+\n+\n+if __name__ == '__main__':\n+    unittest.main()\n\\ No newline at end of file",
    "problem_statement": "Refactor the `enable_pretty_logging()` function from `tornado/log.py` as a method for the class `tornado.option.OptionParser`.",
    "hints_text": "",
    "created_at": "2025-11-03 22:46:32+00:00",
    "language": "Python",
    "Dockerfile": "N/A",
    "test_command": "python3 -m unittest option-parser-with-pretty-print-test.py",
    "task_category": "Refactoring",
    "data_source": "microsoft/RefactorBench",
    "scenario": "brownfield"
  },
  {
    "repo": "tornadoweb/tornado",
    "url": "https://github.com/tornadoweb/tornado",
    "instance_id": "remove-locale-data",
    "base_commit": "remove-locale-data",
    "patch": "N/A",
    "test_patch": "diff --git a/remove-locale-data-test.py b/remove-locale-data-test.py\nnew file mode 100644\nindex 0000000..e035c8e\n--- /dev/null\n+++ b/remove-locale-data-test.py\n@@ -0,0 +1,60 @@\n+import unittest\n+import os\n+import ast\n+\n+class TestTornadoMigration(unittest.TestCase):\n+\n+    def test_locale_names_constant_exists(self):\n+        # Path to the file where the constant should be defined\n+        file_path = 'tornado/locale.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Check if the constant LOCALE_NAMES is defined in locale.py\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        constant_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.Assign):\n+                for target in node.targets:\n+                    if isinstance(target, ast.Name) and target.id == 'LOCALE_NAMES':\n+                        constant_found = True\n+                        break\n+            if constant_found:\n+                break\n+\n+        self.assertTrue(constant_found, \"Constant 'LOCALE_NAMES' not found in locale.py\")\n+\n+    def test_locale_data_file_does_not_exist(self):\n+        # Path to the file that should not exist\n+        file_path = 'tornado/_locale_data.py'\n+\n+        # Check that the file does not exist\n+        self.assertFalse(os.path.exists(file_path), f\"{file_path} should not exist\")\n+\n+    def test_import_not_present(self):\n+        # Path to the file to check the import statement\n+        file_path = 'tornado/locale.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Read and parse the content of locale.py\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        # Check if 'from tornado._locale_data import LOCALE_NAMES' is present\n+        import_not_found = True\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom):\n+                if node.module == 'tornado._locale_data' and \\\n+                   any(alias.name == 'LOCALE_NAMES' for alias in node.names):\n+                    import_not_found = False\n+                    break\n+\n+        self.assertTrue(import_not_found, \"Import 'from tornado._locale_data import LOCALE_NAMES' found in locale.py, but it should not be present\")\n+\n+if __name__ == '__main__':\n+    unittest.main()",
    "problem_statement": "tornado._locale_data is only used by tornado.locale. Move the locale data into locale, and remove the original file.",
    "hints_text": "",
    "created_at": "2025-11-03 22:46:32+00:00",
    "language": "Python",
    "Dockerfile": "N/A",
    "test_command": "python3 -m unittest remove-locale-data-test.py",
    "task_category": "Refactoring",
    "data_source": "microsoft/RefactorBench",
    "scenario": "brownfield"
  },
  {
    "repo": "tornadoweb/tornado",
    "url": "https://github.com/tornadoweb/tornado",
    "instance_id": "log-utils",
    "base_commit": "log-utils",
    "patch": "N/A",
    "test_patch": "diff --git a/log-utils-test.py b/log-utils-test.py\nnew file mode 100644\nindex 0000000..7cd8902\n--- /dev/null\n+++ b/log-utils-test.py\n@@ -0,0 +1,132 @@\n+import unittest\n+import os\n+import ast\n+\n+class TestTornadoLogOptions(unittest.TestCase):\n+\n+    def test_global_log_options_file_exists(self):\n+        # Path to the file that should be checked\n+        file_path = 'tornado/global_log_options.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+    def test_enable_pretty_logging_exists(self):\n+        # Path to the file where the function should be checked\n+        file_path = 'tornado/global_log_options.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Read and parse the content of global_log_options.py\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        # Check if function enable_pretty_logging exists\n+        function_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.FunctionDef) and node.name == 'enable_pretty_logging':\n+                function_found = True\n+                break\n+\n+        self.assertTrue(function_found, \"Function 'enable_pretty_logging' not found in global_log_options.py\")\n+\n+    def test_define_logging_options_exists(self):\n+        # Path to the file where the function should be checked\n+        file_path = 'tornado/global_log_options.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Read and parse the content of global_log_options.py\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        # Check if function define_logging_options exists with correct signature\n+        function_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.FunctionDef) and node.name == 'define_logging_options':\n+                # Check if it has the expected argument signature\n+                arg_names = [arg.arg for arg in node.args.args]\n+                if len(arg_names) == 1 and arg_names[0] == 'options':\n+                    function_found = True\n+                    break\n+\n+        self.assertTrue(function_found, \"Function 'define_logging_options' with expected signature not found in global_log_options.py\")\n+\n+    def test_log_file_does_not_have_functions(self):\n+        # Path to the file where the functions should not be present\n+        file_path = 'tornado/log.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Read and parse the content of log.py\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        # Check if 'enable_pretty_logging' or 'define_logging_options' exists\n+        forbidden_functions = {'enable_pretty_logging', 'define_logging_options'}\n+        functions_found = set()\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.FunctionDef) and node.name in forbidden_functions:\n+                functions_found.add(node.name)\n+\n+        # Ensure none of the forbidden functions are present\n+        self.assertFalse(functions_found, f\"Functions {functions_found} found in log.py, but should not exist there\")\n+\n+    def test_import_in_options_py(self):\n+        # Path to the file where the import should be checked\n+        file_path = 'tornado/options.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Read and parse the content of options.py\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        # Check if 'from tornado.global_log_options import define_logging_options' exists\n+        import_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom) and node.module == 'tornado.global_log_options':\n+                if any(alias.name == 'define_logging_options' for alias in node.names):\n+                    import_found = True\n+                    break\n+\n+        self.assertTrue(import_found, \"'from tornado.global_log_options import define_logging_options' not found in options.py\")\n+\n+    def test_imports_in_log_test_py(self):\n+        # Path to the file where the imports should be checked\n+        file_path = 'tornado/test/log_test.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Read and parse the content of log_test.py\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        # Check if 'from tornado.global_log_options import define_logging_options, enable_pretty_logging' exists\n+        import_global_log_options_found = False\n+        import_log_formatter_found = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom):\n+                if node.module == 'tornado.global_log_options':\n+                    imported_names = {alias.name for alias in node.names}\n+                    if 'define_logging_options' in imported_names and 'enable_pretty_logging' in imported_names:\n+                        import_global_log_options_found = True\n+\n+                if node.module == 'tornado.log':\n+                    if any(alias.name == 'LogFormatter' for alias in node.names):\n+                        import_log_formatter_found = True\n+\n+        self.assertTrue(import_global_log_options_found, \"'from tornado.global_log_options import define_logging_options, enable_pretty_logging' not found in log_test.py\")\n+        self.assertTrue(import_log_formatter_found, \"'from tornado.log import LogFormatter' not found in log_test.py\")\n+\n+\n+    \n+if __name__ == '__main__':\n+    unittest.main()\n\\ No newline at end of file",
    "problem_statement": "Move the options related functions in tornado/log.py, `enable_pretty_logging()` and `define_logging_options()`, to a global_log_options.py",
    "hints_text": "",
    "created_at": "2025-11-03 22:46:32+00:00",
    "language": "Python",
    "Dockerfile": "N/A",
    "test_command": "python3 -m unittest log-utils-test.py",
    "task_category": "Refactoring",
    "data_source": "microsoft/RefactorBench",
    "scenario": "brownfield"
  },
  {
    "repo": "tornadoweb/tornado",
    "url": "https://github.com/tornadoweb/tornado",
    "instance_id": "rename-http1connection",
    "base_commit": "rename-http1connection",
    "patch": "N/A",
    "test_patch": "diff --git a/rename-http1connection-test.py b/rename-http1connection-test.py\nnew file mode 100644\nindex 0000000..cb7d9c6\n--- /dev/null\n+++ b/rename-http1connection-test.py\n@@ -0,0 +1,154 @@\n+import unittest\n+import os\n+import ast\n+\n+class TestTornadoHTTP1xConnectionMigration(unittest.TestCase):\n+\n+    def test_HTTP1xConnection_class_exists(self):\n+        # Path to the file to check for the class existence\n+        file_path = 'tornado/http1connection.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Read and parse the content of http1connection.py\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        HTTP1xConnection_found = False\n+        HTTP1Connection_found = False\n+\n+        # Check for the existence of HTTP1xConnection and HTTP1Connection\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ClassDef):\n+                if node.name == 'HTTP1xConnection':\n+                    HTTP1xConnection_found = True\n+                elif node.name == 'HTTP1Connection':\n+                    HTTP1Connection_found = True\n+\n+        self.assertTrue(HTTP1xConnection_found, \"Class 'HTTP1xConnection' not found in http1connection.py\")\n+        self.assertFalse(HTTP1Connection_found, \"Class 'HTTP1Connection' found in http1connection.py, but it should not be present\")\n+\n+    def test_imports_in_simple_httpclient(self):\n+        # Path to the file to check the import statement\n+        file_path = 'tornado/simple_httpclient.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Read and parse the content of simple_httpclient.py\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        imports_found = False\n+\n+        # Check if 'from tornado.http1connection import HTTP1xConnection, HTTP1ConnectionParameters' is present\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom):\n+                if node.module == 'tornado.http1connection' and \\\n+                   any(alias.name == 'HTTP1xConnection' for alias in node.names) and \\\n+                   any(alias.name == 'HTTP1ConnectionParameters' for alias in node.names):\n+                    imports_found = True\n+                    break\n+\n+        self.assertTrue(imports_found, \"'from tornado.http1connection import HTTP1xConnection, HTTP1ConnectionParameters' not found in simple_httpclient.py\")\n+\n+    def test_create_connection_method_in_simple_httpclient(self):\n+        # Path to the file to check the method definition\n+        file_path = 'tornado/simple_httpclient.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Read and parse the content of simple_httpclient.py\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        method_found = False\n+\n+        # Check if 'def _create_connection(self, stream: IOStream) -> HTTP1xConnection' is present\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.FunctionDef) and node.name == '_create_connection':\n+                for arg in node.args.args:\n+                    if hasattr(arg.annotation, 'id') and arg.annotation.id == 'IOStream':\n+                        if hasattr(node.returns, 'id') and node.returns.id == 'HTTP1xConnection':\n+                            method_found = True\n+                            break\n+\n+        self.assertTrue(method_found, \"'def _create_connection(self, stream: IOStream) -> HTTP1xConnection' not found in simple_httpclient.py\")\n+\n+    \n+    def test_import_HTTP1xConnection_in_http1connection_test(self):\n+        # Path to the file to check the import statement in http1connection_test.py\n+        file_path = 'tornado/test/http1connection_test.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Read and parse the content of http1connection_test.py\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        import_found = False\n+\n+        # Check if 'from tornado.http1connection import HTTP1xConnection' is present\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom):\n+                if node.module == 'tornado.http1connection' and \\\n+                   any(alias.name == 'HTTP1xConnection' for alias in node.names):\n+                    import_found = True\n+                    break\n+\n+        self.assertTrue(import_found, \"'from tornado.http1connection import HTTP1xConnection' not found in http1connection_test.py\")\n+\n+    def test_import_HTTP1xConnection_in_httpserver_test(self):\n+        # Path to the file to check the import statement in httpserver_test.py\n+        file_path = 'tornado/test/httpserver_test.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Read and parse the content of httpserver_test.py\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        import_found = False\n+\n+        # Check if 'from tornado.http1connection import HTTP1xConnection' is present\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom):\n+                if node.module == 'tornado.http1connection' and \\\n+                   any(alias.name == 'HTTP1xConnection' for alias in node.names):\n+                    import_found = True\n+                    break\n+\n+        self.assertTrue(import_found, \"'from tornado.http1connection import HTTP1xConnection' not found in httpserver_test.py\")\n+\n+    def test_HTTP1xConnection_in_comment_in_web_test(self):\n+        # Path to the file to check for the comment in web_test.py\n+        file_path = 'tornado/test/web_test.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Read the content of web_test.py\n+        with open(file_path, 'r') as file:\n+            lines = file.readlines()\n+\n+        comment_HTTP1xConnection_found = False\n+        comment_HTTP1Connection_found = False\n+\n+        # Check for 'HTTP1xConnection' and 'HTTP1Connection' in comments\n+        for line in lines:\n+            if line.lstrip().startswith('#'):\n+                if 'HTTP1xConnection' in line:\n+                    comment_HTTP1xConnection_found = True\n+                if 'HTTP1Connection' in line:\n+                    comment_HTTP1Connection_found = True\n+\n+        self.assertTrue(comment_HTTP1xConnection_found, \"'HTTP1xConnection' not found in a comment in web_test.py\")\n+        self.assertFalse(comment_HTTP1Connection_found, \"'HTTP1Connection' found in a comment in web_test.py, but it should not be present\")\n+\n+\n+if __name__ == '__main__':\n+    unittest.main()\n\\ No newline at end of file",
    "problem_statement": "Rename the HTTP1Connection class to HTTP1xConnection and do not change any related classes function or filenames because of this. Update all references and files though with the new name.",
    "hints_text": "",
    "created_at": "2025-11-03 22:46:32+00:00",
    "language": "Python",
    "Dockerfile": "N/A",
    "test_command": "python3 -m unittest rename-http1connection-test.py",
    "task_category": "Refactoring",
    "data_source": "microsoft/RefactorBench",
    "scenario": "brownfield"
  },
  {
    "repo": "tornadoweb/tornado",
    "url": "https://github.com/tornadoweb/tornado",
    "instance_id": "tcpclient-connect-params",
    "base_commit": "tcpclient-connect-params",
    "patch": "N/A",
    "test_patch": "diff --git a/tcpclient-connect-params-test.py b/tcpclient-connect-params-test.py\nnew file mode 100644\nindex 0000000..7a901ff\n--- /dev/null\n+++ b/tcpclient-connect-params-test.py\n@@ -0,0 +1,144 @@\n+import unittest\n+import os\n+import ast\n+\n+class TestTCPClientConfigImports(unittest.TestCase):\n+\n+    def test_import_in_tcpecho_client_py(self):\n+        # Path to the file where the import should be checked\n+        file_path = 'demos/tcpecho/client.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Read and parse the content of client.py\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        # Check if 'from tornado.tcpclientconfig import TCPClientConfig' exists\n+        import_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom) and node.module == 'tornado.tcpclientconfig':\n+                if any(alias.name == 'TCPClientConfig' for alias in node.names):\n+                    import_found = True\n+                    break\n+\n+        self.assertTrue(import_found, \"'from tornado.tcpclientconfig import TCPClientConfig' not found in client.py\")\n+\n+    def test_tcpclient_connect_usage_in_tcpecho_client_py(self):\n+        # Path to the file where the usage should be checked\n+        file_path = 'demos/tcpecho/client.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Read and parse the content of client.py\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        # Check if the usage 'stream = await TCPClient().connect(TCPClientConfig(options.host, options.port))' exists\n+        usage_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.Assign) and isinstance(node.value, ast.Await):\n+                if (isinstance(node.value.value, ast.Call) and\n+                    isinstance(node.value.value.func, ast.Attribute) and\n+                    node.value.value.func.attr == 'connect' and\n+                    isinstance(node.value.value.func.value, ast.Call) and\n+                    isinstance(node.value.value.func.value.func, ast.Name) and\n+                    node.value.value.func.value.func.id == 'TCPClient'):\n+                    # Check the argument passed to connect\n+                    if (isinstance(node.value.value.args[0], ast.Call) and\n+                        isinstance(node.value.value.args[0].func, ast.Name) and\n+                        node.value.value.args[0].func.id == 'TCPClientConfig'):\n+                        usage_found = True\n+                        break\n+\n+        self.assertTrue(usage_found, \"'stream = await TCPClient().connect(TCPClientConfig(options.host, options.port))' not found in client.py\")\n+\n+    def test_import_in_simple_httpclient_py(self):\n+        # Path to the file where the import should be checked\n+        file_path = 'tornado/simple_httpclient.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Read and parse the content of simple_httpclient.py\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        # Check if 'from tornado.tcpclientconfig import TCPClientConfig' exists\n+        import_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom) and node.module == 'tornado.tcpclientconfig':\n+                if any(alias.name == 'TCPClientConfig' for alias in node.names):\n+                    import_found = True\n+                    break\n+\n+        self.assertTrue(import_found, \"'from tornado.tcpclientconfig import TCPClientConfig' not found in simple_httpclient.py\")\n+\n+    def test_import_in_tcpclient_py(self):\n+        # Path to the file where the import should be checked\n+        file_path = 'tornado/tcpclient.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Read and parse the content of tcpclient.py\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        # Check if 'from tornado.tcpclientconfig import TCPClientConfig' exists\n+        import_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom) and node.module == 'tornado.tcpclientconfig':\n+                if any(alias.name == 'TCPClientConfig' for alias in node.names):\n+                    import_found = True\n+                    break\n+\n+        self.assertTrue(import_found, \"'from tornado.tcpclientconfig import TCPClientConfig' not found in tcpclient.py\")\n+\n+    def test_tcpclientconfig_py_exists_and_has_TCPClientConfig_class(self):\n+        # Path to the file where the existence and class definition should be checked\n+        file_path = 'tornado/tcpclientconfig.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Read and parse the content of tcpclientconfig.py\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        # Check if 'class TCPClientConfig' exists\n+        class_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ClassDef) and node.name == 'TCPClientConfig':\n+                class_found = True\n+                break\n+\n+        self.assertTrue(class_found, \"'class TCPClientConfig' not found in tcpclientconfig.py\")\n+\n+    \n+    def test_import_in_tcpclient_test_py(self):\n+        # Path to the file where the import should be checked\n+        file_path = 'tornado/test/tcpclient_test.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Read and parse the content of tcpclient_test.py\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        # Check if 'from tornado.tcpclientconfig import TCPClientConfig' exists\n+        import_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom) and node.module == 'tornado.tcpclientconfig':\n+                if any(alias.name == 'TCPClientConfig' for alias in node.names):\n+                    import_found = True\n+                    break\n+\n+        self.assertTrue(import_found, \"'from tornado.tcpclientconfig import TCPClientConfig' not found in tcpclient_test.py\")\n+\n+\n+if __name__ == '__main__':\n+    unittest.main()\n\\ No newline at end of file",
    "problem_statement": "Can you wrap up the parameters for TCPClient.connect() into a separate dataclass named TCPClientConfig in a new file tornado/tcpclientconfig.py and import and pass that for all the calls throughout the repo?",
    "hints_text": "",
    "created_at": "2025-11-03 22:46:32+00:00",
    "language": "Python",
    "Dockerfile": "N/A",
    "test_command": "python3 -m unittest tcpclient-connect-params-test.py",
    "task_category": "Refactoring",
    "data_source": "microsoft/RefactorBench",
    "scenario": "brownfield"
  },
  {
    "repo": "tornadoweb/tornado",
    "url": "https://github.com/tornadoweb/tornado",
    "instance_id": "options-utils",
    "base_commit": "options-utils",
    "patch": "N/A",
    "test_patch": "diff --git a/options-utils-test.py b/options-utils-test.py\nnew file mode 100644\nindex 0000000..a7182e8\n--- /dev/null\n+++ b/options-utils-test.py\n@@ -0,0 +1,487 @@\n+import unittest\n+import os\n+import ast\n+\n+class TestTornadoGlobalOptionsImports(unittest.TestCase):\n+\n+    def test_import_in_blog(self):\n+        # Path to the file where the import should be checked\n+        file_path = 'demos/blog/blog.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Read and parse the content of blog.py\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        # Check if 'from tornado.global_options import define, options' is present\n+        import_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom):\n+                if node.module == 'tornado.global_options' and \\\n+                   any(alias.name == 'define' for alias in node.names) and \\\n+                   any(alias.name == 'options' for alias in node.names):\n+                    import_found = True\n+                    break\n+\n+        self.assertTrue(import_found, \"Import 'from tornado.global_options import define, options' not found in blog.py\")\n+\n+    def test_import_in_facebook(self):\n+        file_path = 'demos/facebook/facebook.py'\n+\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        import_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom):\n+                if node.module == 'tornado.global_options' and \\\n+                   any(alias.name == 'define' for alias in node.names) and \\\n+                   any(alias.name == 'options' for alias in node.names):\n+                    import_found = True\n+                    break\n+\n+        self.assertTrue(import_found, \"Import 'from tornado.global_options import define, options' not found in facebook.py\")\n+\n+    def test_import_in_file_uploader(self):\n+        file_path = 'demos/file_upload/file_uploader.py'\n+\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        import_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom):\n+                if node.module == 'tornado.global_options' and \\\n+                   any(alias.name == 'define' for alias in node.names) and \\\n+                   any(alias.name == 'options' for alias in node.names):\n+                    import_found = True\n+                    break\n+\n+        self.assertTrue(import_found, \"Import 'from tornado.global_options import define, options' not found in file_uploader.py\")\n+\n+    def test_import_in_google_auth(self):\n+        file_path = 'demos/google_auth/main.py'\n+\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        import_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom):\n+                if node.module == 'tornado.global_options' and \\\n+                   any(alias.name == 'define' for alias in node.names) and \\\n+                   any(alias.name == 'options' for alias in node.names):\n+                    import_found = True\n+                    break\n+\n+        self.assertTrue(import_found, \"Import 'from tornado.global_options import define, options' not found in main.py\")\n+\n+    def test_import_in_helloworld(self):\n+        file_path = 'demos/helloworld/helloworld.py'\n+\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        import_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom):\n+                if node.module == 'tornado.global_options' and \\\n+                   any(alias.name == 'define' for alias in node.names) and \\\n+                   any(alias.name == 'options' for alias in node.names):\n+                    import_found = True\n+                    break\n+\n+        self.assertTrue(import_found, \"Import 'from tornado.global_options import define, options' not found in helloworld.py\")\n+\n+    def test_import_in_s3server(self):\n+        file_path = 'demos/s3server/s3server.py'\n+\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        import_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom):\n+                if node.module == 'tornado.global_options' and \\\n+                   any(alias.name == 'define' for alias in node.names) and \\\n+                   any(alias.name == 'options' for alias in node.names):\n+                    import_found = True\n+                    break\n+\n+        self.assertTrue(import_found, \"Import 'from tornado.global_options import define, options' not found in s3server.py\")\n+\n+    def test_import_in_tcp_client(self):\n+        file_path = 'demos/tcpecho/client.py'\n+\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        import_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom):\n+                if node.module == 'tornado.global_options' and \\\n+                   any(alias.name == 'define' for alias in node.names) and \\\n+                   any(alias.name == 'options' for alias in node.names):\n+                    import_found = True\n+                    break\n+\n+        self.assertTrue(import_found, \"Import 'from tornado.global_options import define, options' not found in client.py\")\n+\n+    def test_import_in_tcp_server(self):\n+        file_path = 'demos/tcpecho/server.py'\n+\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        import_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom):\n+                if node.module == 'tornado.global_options' and \\\n+                   any(alias.name == 'define' for alias in node.names) and \\\n+                   any(alias.name == 'options' for alias in node.names):\n+                    import_found = True\n+                    break\n+\n+        self.assertTrue(import_found, \"Import 'from tornado.global_options import define, options' not found in server.py\")\n+\n+    def test_import_in_chatdemo(self):\n+        file_path = 'demos/websocket/chatdemo.py'\n+\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        import_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom):\n+                if node.module == 'tornado.global_options' and \\\n+                   any(alias.name == 'define' for alias in node.names) and \\\n+                   any(alias.name == 'options' for alias in node.names):\n+                    import_found = True\n+                    break\n+\n+        self.assertTrue(import_found, \"Import 'from tornado.global_options import define, options' not found in chatdemo.py\")\n+    \n+    def test_import_in_chat_chatdemo(self):\n+        # Path to the file where the import should be checked\n+        file_path = 'demos/chat/chatdemo.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Read and parse the content of chatdemo.py\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        # Check if 'from tornado.global_options import define, options, parse_command_line' is present\n+        import_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom):\n+                if node.module == 'tornado.global_options' and \\\n+                any(alias.name == 'define' for alias in node.names) and \\\n+                any(alias.name == 'options' for alias in node.names) and \\\n+                any(alias.name == 'parse_command_line' for alias in node.names):\n+                    import_found = True\n+                    break\n+\n+        self.assertTrue(import_found, \"Import 'from tornado.global_options import define, options, parse_command_line' not found in chatdemo.py\")\n+\n+\n+    def test_import_in_benchmark(self):\n+        # Path to the file where the import should be checked\n+        file_path = 'maint/benchmark/benchmark.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Read and parse the content of benchmark.py\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        # Check if 'from tornado.global_options import define, options, parse_command_line' is present\n+        import_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom):\n+                if node.module == 'tornado.global_options' and \\\n+                any(alias.name == 'define' for alias in node.names) and \\\n+                any(alias.name == 'options' for alias in node.names) and \\\n+                any(alias.name == 'parse_command_line' for alias in node.names):\n+                    import_found = True\n+                    break\n+\n+        self.assertTrue(import_found, \"Import 'from tornado.global_options import define, options, parse_command_line' not found in benchmark.py\")\n+\n+\n+    def test_import_in_chunk_benchmark(self):\n+        # Path to the file where the import should be checked\n+        file_path = 'maint/benchmark/chunk_benchmark.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Read and parse the content of chunk_benchmark.py\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        # Check if 'from tornado.global_options import define, options, parse_command_line' is present\n+        import_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom):\n+                if node.module == 'tornado.global_options' and \\\n+                any(alias.name == 'define' for alias in node.names) and \\\n+                any(alias.name == 'options' for alias in node.names) and \\\n+                any(alias.name == 'parse_command_line' for alias in node.names):\n+                    import_found = True\n+                    break\n+\n+        self.assertTrue(import_found, \"Import 'from tornado.global_options import define, options, parse_command_line' not found in chunk_benchmark.py\")\n+    \n+    def test_import_in_gen_benchmark(self):\n+        # Path to the file where the import should be checked\n+        file_path = 'maint/benchmark/gen_benchmark.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Read and parse the content of gen_benchmark.py\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        # Check if 'from tornado.global_options import define, options, parse_command_line' is present\n+        import_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom):\n+                if node.module == 'tornado.global_options' and \\\n+                any(alias.name == 'define' for alias in node.names) and \\\n+                any(alias.name == 'options' for alias in node.names) and \\\n+                any(alias.name == 'parse_command_line' for alias in node.names):\n+                    import_found = True\n+                    break\n+\n+        self.assertTrue(import_found, \"Import 'from tornado.global_options import define, options, parse_command_line' not found in gen_benchmark.py\")\n+\n+    def test_import_in_parsing_benchmark(self):\n+        # Path to the file where the import should be checked\n+        file_path = 'maint/benchmark/parsing_benchmark.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Read and parse the content of chunk_benchmark.py\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        # Check if 'from tornado.global_options import define, options, parse_command_line' is present\n+        import_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom):\n+                if node.module == 'tornado.global_options' and \\\n+                any(alias.name == 'define' for alias in node.names) and \\\n+                any(alias.name == 'options' for alias in node.names) and \\\n+                any(alias.name == 'parse_command_line' for alias in node.names):\n+                    import_found = True\n+                    break\n+\n+        self.assertTrue(import_found, \"Import 'from tornado.global_options import define, options, parse_command_line' not found in parsing_benchmark.py\")\n+\n+    def test_import_in_template_benchmark(self):\n+        # Path to the file where the import should be checked\n+        file_path = 'maint/benchmark/template_benchmark.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Read and parse the content of chunk_benchmark.py\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        # Check if 'from tornado.global_options import define, options, parse_command_line' is present\n+        import_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom):\n+                if node.module == 'tornado.global_options' and \\\n+                any(alias.name == 'define' for alias in node.names) and \\\n+                any(alias.name == 'options' for alias in node.names) and \\\n+                any(alias.name == 'parse_command_line' for alias in node.names):\n+                    import_found = True\n+                    break\n+\n+        self.assertTrue(import_found, \"Import 'from tornado.global_options import define, options, parse_command_line' not found in template_benchmark.py\")\n+\n+    def test_import_in_chunk_benchmark(self):\n+        # Path to the file where the import should be checked\n+        file_path = 'maint/scripts/test_resolvers.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Read and parse the content of chunk_benchmark.py\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        # Check if 'from tornado.global_options import define, options, parse_command_line' is present\n+        import_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom):\n+                if node.module == 'tornado.global_options' and \\\n+                any(alias.name == 'define' for alias in node.names) and \\\n+                any(alias.name == 'options' for alias in node.names) and \\\n+                any(alias.name == 'parse_command_line' for alias in node.names):\n+                    import_found = True\n+                    break\n+\n+        self.assertTrue(import_found, \"Import 'from tornado.global_options import define, options, parse_command_line' not found in chunk_benchmark.py\")\n+\n+    def test_import_in_websocket_client(self):\n+        # Path to the file where the import should be checked\n+        file_path = 'maint/test/websocket/client.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Read and parse the content of client.py\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        # Check if 'from tornado.global_options import define, options, parse_command_line' is present\n+        import_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom):\n+                if node.module == 'tornado.global_options' and \\\n+                any(alias.name == 'define' for alias in node.names) and \\\n+                any(alias.name == 'options' for alias in node.names) and \\\n+                any(alias.name == 'parse_command_line' for alias in node.names):\n+                    import_found = True\n+                    break\n+\n+        self.assertTrue(import_found, \"Import 'from tornado.global_options import define, options, parse_command_line' not found in client.py\")\n+\n+\n+    def test_import_in_websocket_server(self):\n+        # Path to the file where the import should be checked\n+        file_path = 'maint/test/websocket/server.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Read and parse the content of server.py\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        # Check if 'from tornado.global_options import define, options, parse_command_line' is present\n+        import_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom):\n+                if node.module == 'tornado.global_options' and \\\n+                any(alias.name == 'define' for alias in node.names) and \\\n+                any(alias.name == 'options' for alias in node.names) and \\\n+                any(alias.name == 'parse_command_line' for alias in node.names):\n+                    import_found = True\n+                    break\n+\n+        self.assertTrue(import_found, \"Import 'from tornado.global_options import define, options, parse_command_line' not found in server.py\")\n+    def test_global_options_file_exists(self):\n+        # Path to the file that should be checked\n+        file_path = 'tornado/global_options.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+    def test_define_function_exists(self):\n+        # Path to the file where the function should be checked\n+        file_path = 'tornado/global_options.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Read and parse the content of global_options.py\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        # Check if function define exists with the correct signature\n+        function_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.FunctionDef) and node.name == 'define':\n+                # Check function arguments\n+                arg_names = [arg.arg for arg in node.args.args]\n+                if arg_names == ['name', 'default', 'type', 'help', 'metavar', 'multiple', 'group', 'callback']:\n+                    function_found = True\n+                    break\n+\n+        self.assertTrue(function_found, \"Function 'define' with the correct signature not found in global_options.py\")\n+\n+    def test_parse_command_line_function_exists(self):\n+        # Path to the file where the function should be checked\n+        file_path = 'tornado/global_options.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Read and parse the content of global_options.py\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        # Check if function parse_command_line exists\n+        function_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.FunctionDef) and node.name == 'parse_command_line':\n+                function_found = True\n+                break\n+\n+        self.assertTrue(function_found, \"Function 'parse_command_line' not found in global_options.py\")\n+\n+    def test_add_parse_callback_function_exists(self):\n+        # Path to the file where the function should be checked\n+        file_path = 'tornado/global_options.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Read and parse the content of global_options.py\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        # Check if function add_parse_callback exists\n+        function_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.FunctionDef) and node.name == 'add_parse_callback':\n+                function_found = True\n+                break\n+\n+        self.assertTrue(function_found, \"Function 'add_parse_callback' not found in global_options.py\")\n+\n+    def test_define_logging_options_exists(self):\n+        # Path to the file where the specific line should be checked\n+        file_path = 'tornado/global_options.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Read the file content\n+        with open(file_path, 'r') as file:\n+            content = file.read()\n+\n+        # Check if the line 'define_logging_options(options)' exists\n+        self.assertIn('define_logging_options(options)', content, \"Line 'define_logging_options(options)' not found in global_options.py\")\n+\n+\n+\n+if __name__ == '__main__':\n+    unittest.main()\n\\ No newline at end of file",
    "problem_statement": "Move all the stray functions in `tornado/options.py` and move them into a newly created `global_options.py`. Update all the imports in the repository accordingly.",
    "hints_text": "",
    "created_at": "2025-11-03 22:46:32+00:00",
    "language": "Python",
    "Dockerfile": "N/A",
    "test_command": "python3 -m unittest options-utils-test.py",
    "task_category": "Refactoring",
    "data_source": "microsoft/RefactorBench",
    "scenario": "brownfield"
  },
  {
    "repo": "pallets/flask",
    "url": "https://github.com/pallets/flask",
    "instance_id": "add-log-parameter-get-debug-flag",
    "base_commit": "add-log-parameter-get-debug-flag",
    "patch": "N/A",
    "test_patch": "diff --git a/add-log-parameter-get-debug-flag-test.py b/add-log-parameter-get-debug-flag-test.py\nnew file mode 100644\nindex 0000000..fa80c3c\n--- /dev/null\n+++ b/add-log-parameter-get-debug-flag-test.py\n@@ -0,0 +1,149 @@\n+import unittest\n+import os\n+import ast\n+\n+class TestHelpersFunctions(unittest.TestCase):\n+\n+    def setUp(self):\n+        # Path to the helpers.py file\n+        self.file_path = 'src/flask/helpers.py'\n+        self.assertTrue(os.path.exists(self.file_path), f\"{self.file_path} does not exist\")\n+\n+        # Parse the helpers.py file into an AST tree\n+        with open(self.file_path, 'r') as file:\n+            self.tree = ast.parse(file.read())\n+\n+    def test_logging_import_in_helpers(self):\n+        \"\"\"Test if logging is imported in helpers.py.\"\"\"\n+        import_found = False\n+        for node in ast.walk(self.tree):\n+            if isinstance(node, ast.Import):\n+                for alias in node.names:\n+                    if alias.name == 'logging':\n+                        import_found = True\n+                        break\n+            if import_found:\n+                break\n+\n+        self.assertTrue(import_found, \"'logging' not imported in helpers.py\")\n+\n+    def test_get_debug_flag_has_log_parameter(self):\n+        \"\"\"Test if get_debug_flag function has a log parameter.\"\"\"\n+        function_found = False\n+        log_parameter_found = False\n+\n+        for node in ast.walk(self.tree):\n+            if isinstance(node, ast.FunctionDef) and node.name == 'get_debug_flag':\n+                function_found = True\n+                for arg in node.args.args:\n+                    if arg.arg == 'log':\n+                        log_parameter_found = True\n+                        break\n+                break\n+\n+        self.assertTrue(function_found, \"Function 'get_debug_flag' not found in helpers.py\")\n+        self.assertTrue(log_parameter_found, \"'log' parameter not found in get_debug_flag function\")\n+\n+    def test_get_debug_flag_log_default_false(self):\n+        \"\"\"Test if the log parameter in get_debug_flag function is set to False by default.\"\"\"\n+        function_found = False\n+        log_default_false = False\n+\n+        for node in ast.walk(self.tree):\n+            if isinstance(node, ast.FunctionDef) and node.name == 'get_debug_flag':\n+                function_found = True\n+                for arg in node.args.defaults:\n+                    if isinstance(arg, ast.Constant) and arg.value is False:\n+                        log_default_false = True\n+                        break\n+                break\n+\n+        self.assertTrue(function_found, \"Function 'get_debug_flag' not found in helpers.py\")\n+        self.assertTrue(log_default_false, \"'log' parameter in get_debug_flag function is not set to False by default\")\n+\n+    def test_get_debug_flag_in_app(self):\n+        file_path = 'src/flask/app.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        log_true_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.Call):\n+                if isinstance(node.func, ast.Name) and node.func.id == 'get_debug_flag':\n+                    for keyword in node.keywords:\n+                        if keyword.arg == 'log' and isinstance(keyword.value, ast.Constant) and keyword.value.value is True:\n+                            log_true_found = True\n+                            break\n+                if log_true_found:\n+                    break\n+\n+        self.assertTrue(log_true_found, \"get_debug_flag call with log=True not found in app.py\")\n+\n+    def test_get_debug_flag_in_cli(self):\n+        file_path = 'src/flask/cli.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        log_true_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.Call):\n+                if isinstance(node.func, ast.Name) and node.func.id == 'get_debug_flag':\n+                    for keyword in node.keywords:\n+                        if keyword.arg == 'log' and isinstance(keyword.value, ast.Constant) and keyword.value.value is True:\n+                            log_true_found = True\n+                            break\n+                if log_true_found:\n+                    break\n+\n+        self.assertTrue(log_true_found, \"get_debug_flag call with log=True not found in cli.py\")\n+\n+    def test_get_debug_flag_in_sansio_app(self):\n+        file_path = 'src/flask/sansio/app.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        log_true_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.Call):\n+                if isinstance(node.func, ast.Name) and node.func.id == 'get_debug_flag':\n+                    for keyword in node.keywords:\n+                        if keyword.arg == 'log' and isinstance(keyword.value, ast.Constant) and keyword.value.value is True:\n+                            log_true_found = True\n+                            break\n+                if log_true_found:\n+                    break\n+\n+        self.assertTrue(log_true_found, \"get_debug_flag call with log=True not found in sansio/app.py\")\n+\n+    def test_get_debug_flag_calls_in_test_helpers(self):\n+        file_path = 'tests/test_helpers.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        all_calls_valid = True\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.Call):\n+                if isinstance(node.func, ast.Name) and node.func.id == 'get_debug_flag':\n+                    log_keyword = None\n+                    for keyword in node.keywords:\n+                        if keyword.arg == 'log':\n+                            log_keyword = keyword\n+                            break\n+                    if log_keyword is not None:\n+                        if not (isinstance(log_keyword.value, ast.Constant) and log_keyword.value.value is False):\n+                            all_calls_valid = False\n+                            break\n+\n+        self.assertTrue(all_calls_valid, \"Not all get_debug_flag calls have log=False or omit the log argument in test_helpers.py\")\n+\n+    \n+if __name__ == '__main__':\n+    unittest.main()",
    "problem_statement": "Import logging and add a log boolean parameter to get_debug_flag and make the base case false. Make all usages except the ones in tests as log=True.",
    "hints_text": "",
    "created_at": "2025-11-03 22:46:32+00:00",
    "language": "Python",
    "Dockerfile": "N/A",
    "test_command": "python3 -m unittest add-log-parameter-get-debug-flag-test.py",
    "task_category": "Refactoring",
    "data_source": "microsoft/RefactorBench",
    "scenario": "brownfield"
  },
  {
    "repo": "pallets/flask",
    "url": "https://github.com/pallets/flask",
    "instance_id": "debughelpers-to-helpers.py",
    "base_commit": "debughelpers-to-helpers.py",
    "patch": "N/A",
    "test_patch": "diff --git a/debughelpers-to-helpers.py-test.py b/debughelpers-to-helpers.py-test.py\nnew file mode 100644\nindex 0000000..c2afb46\n--- /dev/null\n+++ b/debughelpers-to-helpers.py-test.py\n@@ -0,0 +1,132 @@\n+import unittest\n+import os\n+import ast\n+\n+class TestHelpersFunctions(unittest.TestCase):\n+\n+    def test_attach_enctype_error_multidict_exists(self):\n+        # Path to the file where the function should be located\n+        file_path = 'src/flask/helpers.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Check if the function is defined in helpers.py\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        function_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.FunctionDef) and node.name == 'attach_enctype_error_multidict':\n+                function_found = True\n+                break\n+\n+        self.assertTrue(function_found, \"Function 'attach_enctype_error_multidict' not found in helpers.py\")\n+\n+    def test_dump_loader_info_exists(self):\n+        # Path to the file where the function should be located\n+        file_path = 'src/flask/helpers.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Check if the function is defined in helpers.py\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        function_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.FunctionDef) and node.name == '_dump_loader_info':\n+                function_found = True\n+                break\n+\n+        self.assertTrue(function_found, \"Function '_dump_loader_info' not found in helpers.py\")\n+\n+    def test_explain_template_loading_attempts_exists(self):\n+        # Path to the file where the function should be located\n+        file_path = 'src/flask/helpers.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Check if the function is defined in helpers.py\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        function_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.FunctionDef) and node.name == 'explain_template_loading_attempts':\n+                function_found = True\n+                break\n+\n+        self.assertTrue(function_found, \"Function 'explain_template_loading_attempts' not found in helpers.py\")\n+\n+    def test_functions_not_in_debughelpers(self):\n+        # Path to the debughelpers.py file\n+        file_path = 'src/flask/debughelpers.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Check if the functions are NOT defined in debughelpers.py\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        functions_to_check = [\n+            'attach_enctype_error_multidict',\n+            '_dump_loader_info',\n+            'explain_template_loading_attempts'\n+        ]\n+\n+        for function_name in functions_to_check:\n+            function_found = False\n+            for node in ast.walk(tree):\n+                if isinstance(node, ast.FunctionDef) and node.name == function_name:\n+                    function_found = True\n+                    break\n+            self.assertFalse(function_found, f\"Function '{function_name}' should not be in debughelpers.py but was found.\")\n+\n+    def test_helpers_py_imports(self):\n+        # Path to the helpers.py file\n+        file_path = 'src/flask/helpers.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Check if the specified imports are present in helpers.py\n+        with open(file_path, 'r') as file:\n+            content = file.read()\n+\n+        expected_imports = [\n+            \"from __future__ import annotations\",\n+            \"import importlib.util\",\n+            \"import os\",\n+            \"import sys\",\n+            \"import typing as t\",\n+            \"from datetime import datetime\",\n+            \"from functools import lru_cache\",\n+            \"from functools import update_wrapper\",\n+            \"import werkzeug.utils\",\n+            \"from werkzeug.exceptions import abort as _wz_abort\",\n+            \"from werkzeug.utils import redirect as _wz_redirect\",\n+            \"from werkzeug.wrappers import Response as BaseResponse\",\n+            \"from .blueprints import Blueprint\",\n+            \"from .debughelpers import DebugFilesKeyError\",\n+            \"from .globals import _cv_request\",\n+            \"from .globals import current_app\",\n+            \"from .globals import request\",\n+            \"from .globals import request_ctx\",\n+            \"from .globals import session\",\n+            \"from jinja2.loaders import BaseLoader\",\n+            \"from .signals import message_flashed\",\n+            \"from .sansio.app import App\",\n+            \"if t.TYPE_CHECKING:  # pragma: no cover\",\n+            \"from .sansio.scaffold import Scaffold\",\n+            \"from .wrappers import Response, Request\"\n+        ]\n+\n+        for expected_import in expected_imports:\n+            self.assertIn(expected_import, content, f\"Import '{expected_import}' not found in helpers.py\")\n+\n+if __name__ == '__main__':\n+    unittest.main()",
    "problem_statement": "Move the outside functions, not the classes, from debughelpers to helpers and update the repository imports accordingly",
    "hints_text": "",
    "created_at": "2025-11-03 22:46:32+00:00",
    "language": "Python",
    "Dockerfile": "N/A",
    "test_command": "python3 -m unittest debughelpers-to-helpers.py-test.py",
    "task_category": "Refactoring",
    "data_source": "microsoft/RefactorBench",
    "scenario": "brownfield"
  },
  {
    "repo": "pallets/flask",
    "url": "https://github.com/pallets/flask",
    "instance_id": "render-template-str",
    "base_commit": "render-template-str",
    "patch": "N/A",
    "test_patch": "diff --git a/render-template-str-test.py b/render-template-str-test.py\nnew file mode 100644\nindex 0000000..021c9da\n--- /dev/null\n+++ b/render-template-str-test.py\n@@ -0,0 +1,181 @@\n+import unittest\n+import os\n+import ast\n+\n+class TestHelpersFunctions(unittest.TestCase):\n+\n+    def test_render_template_string_not_in_templating(self):\n+        file_path = 'src/flask/templating.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        function_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.FunctionDef) and node.name == 'render_template_string':\n+                function_found = True\n+                break\n+\n+        self.assertFalse(function_found, \"'render_template_string' function found in templating.py\")\n+\n+    def test_render_template_str_exists_in_templating(self):\n+        file_path = 'src/flask/templating.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        function_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.FunctionDef) and node.name == 'render_template_str':\n+                function_found = True\n+                break\n+\n+        self.assertTrue(function_found, \"'render_template_str' function not found in templating.py\")\n+\n+    def test_render_template_str_import_in_init(self):\n+        file_path = 'src/flask/__init__.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        import_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom):\n+                if (node.module == 'templating' and\n+                    any(alias.name == 'render_template_str' and alias.asname == 'render_template_str' for alias in node.names)):\n+                    import_found = True\n+                    break\n+\n+        self.assertTrue(import_found, \"Import 'from .templating import render_template_str as render_template_string' not found in __init__.py\")\n+\n+    def test_render_template_str_call_in_test_templating(self):\n+        # Path to the test_templating.py file\n+        file_path = 'tests/test_templating.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Check if render_template_string is correctly aliased and called as render_template_str\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        correct_call_found = False\n+        incorrect_call_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.Call) and isinstance(node.func, ast.Attribute):\n+                if (isinstance(node.func.value, ast.Name) and\n+                    node.func.value.id == 'flask'):\n+                    if node.func.attr == 'render_template_str':\n+                        correct_call_found = True\n+                    elif node.func.attr == 'render_template_string':\n+                        incorrect_call_found = True\n+\n+        self.assertTrue(correct_call_found, \"Call to 'flask.render_template_string' not found in test_templating.py\")\n+        self.assertFalse(incorrect_call_found, \"Incorrect call to 'flask.render_template_str' found in test_templating.py\")\n+\n+    def test_render_template_usage_in_test_appctx(self):\n+        file_path = 'tests/test_appctx.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        correct_call_found = False\n+        incorrect_call_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.Call) and isinstance(node.func, ast.Attribute):\n+                if (isinstance(node.func.value, ast.Name) and node.func.value.id == 'flask'):\n+                    if node.func.attr == 'render_template_str':\n+                        correct_call_found = True\n+                    elif node.func.attr == 'render_template_string':\n+                        incorrect_call_found = True\n+\n+        self.assertTrue(correct_call_found, \"Call to 'flask.render_template_str' not found in test_appctx.py\")\n+        self.assertFalse(incorrect_call_found, \"Incorrect call to 'flask.render_template_string' found in test_appctx.py\")\n+\n+\n+    def test_render_template_usage_in_test_blueprints(self):\n+        file_path = 'tests/test_blueprints.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        correct_call_found = False\n+        incorrect_call_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.Call) and isinstance(node.func, ast.Attribute):\n+                if (isinstance(node.func.value, ast.Name) and node.func.value.id == 'flask'):\n+                    if node.func.attr == 'render_template_str':\n+                        correct_call_found = True\n+                    elif node.func.attr == 'render_template_string':\n+                        incorrect_call_found = True\n+\n+        self.assertTrue(correct_call_found, \"Call to 'flask.render_template_str' not found in test_blueprints.py\")\n+        self.assertFalse(incorrect_call_found, \"Incorrect call to 'flask.render_template_string' found in test_blueprints.py\")\n+\n+\n+    def test_render_template_usage_in_test_json(self):\n+        file_path = 'tests/test_json.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        correct_call_found = False\n+        incorrect_call_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.Call) and isinstance(node.func, ast.Attribute):\n+                if (isinstance(node.func.value, ast.Name) and node.func.value.id == 'flask'):\n+                    if node.func.attr == 'render_template_str':\n+                        correct_call_found = True\n+                    elif node.func.attr == 'render_template_string':\n+                        incorrect_call_found = True\n+\n+        self.assertTrue(correct_call_found, \"Call to 'flask.render_template_str' not found in test_json.py\")\n+        self.assertFalse(incorrect_call_found, \"Incorrect call to 'flask.render_template_string' found in test_json.py\")\n+\n+\n+    def test_render_template_usage_in_test_templating(self):\n+        file_path = 'tests/test_templating.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        correct_call_found = False\n+        incorrect_call_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.Call) and isinstance(node.func, ast.Attribute):\n+                if (isinstance(node.func.value, ast.Name) and node.func.value.id == 'flask'):\n+                    if node.func.attr == 'render_template_str':\n+                        correct_call_found = True\n+                    elif node.func.attr == 'render_template_string':\n+                        incorrect_call_found = True\n+\n+        self.assertTrue(correct_call_found, \"Call to 'flask.render_template_str' not found in test_templating.py\")\n+        self.assertFalse(incorrect_call_found, \"Incorrect call to 'flask.render_template_string' found in test_templating.py\")\n+\n+    def test_render_template_str_in_api_rst(self):\n+        file_path = 'docs/api.rst'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            content = file.read()\n+\n+        self.assertIn('render_template_str', content, \"Expected 'render_template_str' not found in api.rst\")\n+        self.assertNotIn('render_template_string', content, \"Unexpected 'render_template_string' found in api.rst\")\n+\n+    def test_flask_templating_render_template_str_in_templating_rst(self):\n+        file_path = 'docs/templating.rst'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            content = file.read()\n+\n+        self.assertIn('flask.templating.render_template_str', content, \"Expected 'flask.templating.render_template_str' not found in templating.rst\")\n+\n+    \n+if __name__ == '__main__':\n+    unittest.main()",
    "problem_statement": "Rename render_template_string to render_template_str and update the flask usage to also user render_template_str.",
    "hints_text": "",
    "created_at": "2025-11-03 22:46:32+00:00",
    "language": "Python",
    "Dockerfile": "N/A",
    "test_command": "python3 -m unittest render-template-str-test.py",
    "task_category": "Refactoring",
    "data_source": "microsoft/RefactorBench",
    "scenario": "brownfield"
  },
  {
    "repo": "pallets/flask",
    "url": "https://github.com/pallets/flask",
    "instance_id": "stream-template-str",
    "base_commit": "stream-template-str",
    "patch": "N/A",
    "test_patch": "diff --git a/stream-template-str-test.py b/stream-template-str-test.py\nnew file mode 100644\nindex 0000000..95c7ef7\n--- /dev/null\n+++ b/stream-template-str-test.py\n@@ -0,0 +1,76 @@\n+import unittest\n+import os\n+import ast\n+\n+class TestHelpersFunctions(unittest.TestCase):\n+\n+    def test_stream_template_string_not_in_templating(self):\n+        file_path = 'src/flask/templating.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        function_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.FunctionDef) and node.name == 'stream_template_string':\n+                function_found = True\n+                break\n+\n+        self.assertFalse(function_found, \"'stream_template_string' function found in templating.py\")\n+\n+    def test_stream_template_str_exists_in_templating(self):\n+        file_path = 'src/flask/templating.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        function_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.FunctionDef) and node.name == 'stream_template_str':\n+                function_found = True\n+                break\n+\n+        self.assertTrue(function_found, \"'stream_template_str' function not found in templating.py\")\n+\n+    def test_import_in_init(self):\n+        file_path = 'src/flask/__init__.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        import_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom):\n+                if (node.module == 'templating' and\n+                    any(alias.name == 'stream_template_str' and alias.asname == 'stream_template_string' for alias in node.names)):\n+                    import_found = True\n+                    break\n+\n+        self.assertTrue(import_found, \"Import 'from .templating import stream_template_str as stream_template_string' not found in __init__.py\")\n+\n+    def test_flask_stream_template_string_call(self):\n+        file_path = 'tests/test_templating.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        correct_call_found = False\n+        incorrect_call_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.Call) and isinstance(node.func, ast.Attribute):\n+                if (isinstance(node.func.value, ast.Name) and\n+                    node.func.value.id == 'flask'):\n+                    if node.func.attr == 'stream_template_string':\n+                        correct_call_found = True\n+                    elif node.func.attr == 'stream_template_str':\n+                        incorrect_call_found = True\n+\n+        self.assertTrue(correct_call_found, \"Call to 'flask.stream_template_string' not found in test_templating.py\")\n+        self.assertFalse(incorrect_call_found, \"Incorrect call to 'flask.stream_template_str' found in test_templating.py\")\n+\n+if __name__ == '__main__':\n+    unittest.main()",
    "problem_statement": "Rename the core function stream_template_string into stream_template_str but keep the package init to be stream_template_string.",
    "hints_text": "",
    "created_at": "2025-11-03 22:46:32+00:00",
    "language": "Python",
    "Dockerfile": "N/A",
    "test_command": "python3 -m unittest stream-template-str-test.py",
    "task_category": "Refactoring",
    "data_source": "microsoft/RefactorBench",
    "scenario": "brownfield"
  },
  {
    "repo": "pallets/flask",
    "url": "https://github.com/pallets/flask",
    "instance_id": "rename-send-from-directory",
    "base_commit": "rename-send-from-directory",
    "patch": "N/A",
    "test_patch": "diff --git a/rename-send-from-directory-test.py b/rename-send-from-directory-test.py\nnew file mode 100644\nindex 0000000..c9a4930\n--- /dev/null\n+++ b/rename-send-from-directory-test.py\n@@ -0,0 +1,92 @@\n+import unittest\n+import os\n+import ast\n+\n+class TestHelpersFunctions(unittest.TestCase):\n+\n+    def test_send_from_directory_helper_import_in_blueprints(self):\n+        file_path = 'src/flask/blueprints.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        import_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom):\n+                if node.module == 'helpers' and any(alias.name == 'send_from_directory_helper' for alias in node.names):\n+                    import_found = True\n+                    break\n+\n+        self.assertTrue(import_found, \"Import 'send_from_directory_helper' not found in blueprints.py\")\n+\n+    def test_send_from_directory_helper_import_in_init(self):\n+        file_path = 'src/flask/__init__.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        import_found = False\n+        alias_correct = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom):\n+                if node.module == 'helpers':\n+                    for alias in node.names:\n+                        if alias.name == 'send_from_directory_helper':\n+                            import_found = True\n+                            if alias.asname == 'send_from_directory':\n+                                alias_correct = True\n+                            break\n+\n+        self.assertTrue(import_found, \"Import 'send_from_directory_helper' not found in __init__.py\")\n+        self.assertTrue(alias_correct, \"Alias 'send_from_directory' not correctly assigned in __init__.py\")\n+\n+    def test_send_from_directory_helper_import_in_app(self):\n+        file_path = 'src/flask/app.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        import_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom):\n+                if node.module == 'helpers' and any(alias.name == 'send_from_directory_helper' for alias in node.names):\n+                    import_found = True\n+                    break\n+\n+        self.assertTrue(import_found, \"Import 'send_from_directory_helper' not found in app.py\")\n+\n+    def test_send_from_directory_call_in_test_helpers(self):\n+        # Path to the test_helpers.py file\n+        file_path = 'tests/test_helpers.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Check if rv = flask.send_from_directory(\"static\", \"hello.txt\") is called in a function within a class\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        call_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ClassDef):  # Check for class definition\n+                for class_node in node.body:\n+                    if isinstance(class_node, ast.FunctionDef):  # Check for function definition within the class\n+                        for func_node in class_node.body:\n+                            if isinstance(func_node, ast.Assign):  # Check if the statement is an assignment\n+                                if isinstance(func_node.value, ast.Call):\n+                                    call = func_node.value\n+                                    if (isinstance(call.func, ast.Attribute) and\n+                                            isinstance(call.func.value, ast.Name) and\n+                                            call.func.value.id == \"flask\" and\n+                                            call.func.attr == \"send_from_directory\" and\n+                                            len(call.args) == 2 and\n+                                            isinstance(call.args[0], ast.Constant) and call.args[0].value == \"static\" and\n+                                            isinstance(call.args[1], ast.Constant) and call.args[1].value == \"hello.txt\"):\n+                                        call_found = True\n+                                        break\n+\n+        self.assertTrue(call_found, \"Call to 'flask.send_from_directory(\\\"static\\\", \\\"hello.txt\\\")' not found in test_helpers.py\")\n+\n+if __name__ == '__main__':\n+    unittest.main()",
    "problem_statement": "Rename the helper function send_from_directory to send_from_directory_helper but keep the overall flask usage as send_from_directory",
    "hints_text": "",
    "created_at": "2025-11-03 22:46:32+00:00",
    "language": "Python",
    "Dockerfile": "N/A",
    "test_command": "python3 -m unittest rename-send-from-directory-test.py",
    "task_category": "Refactoring",
    "data_source": "microsoft/RefactorBench",
    "scenario": "brownfield"
  },
  {
    "repo": "pallets/flask",
    "url": "https://github.com/pallets/flask",
    "instance_id": "add-log-parameter-get-flashed-messages",
    "base_commit": "add-log-parameter-get-flashed-messages",
    "patch": "N/A",
    "test_patch": "diff --git a/add-log-parameter-get-flashed-messages-test.py b/add-log-parameter-get-flashed-messages-test.py\nnew file mode 100644\nindex 0000000..7abfa5d\n--- /dev/null\n+++ b/add-log-parameter-get-flashed-messages-test.py\n@@ -0,0 +1,77 @@\n+import unittest\n+import os\n+import ast\n+\n+class TestHelpersFunctions(unittest.TestCase):\n+\n+    def test_get_flashed_messages_param_in_helpers(self):\n+        file_path = 'src/flask/helpers.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        func_found = False\n+        log_param_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.FunctionDef) and node.name == 'get_flashed_messages':\n+                func_found = True\n+                for arg in node.args.args:\n+                    if arg.arg == 'log':\n+                        if isinstance(arg.annotation, ast.Name) and arg.annotation.id == 'bool':\n+                            log_param_found = True\n+                        break\n+\n+        self.assertTrue(func_found, \"Function 'get_flashed_messages' not found in helpers.py\")\n+        self.assertTrue(log_param_found, \"Parameter 'log: bool' not found in function 'get_flashed_messages'\")\n+\n+    def test_get_flashed_messages_param_default_value(self):\n+        file_path = 'src/flask/helpers.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        func_found = False\n+        log_default_false = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.FunctionDef) and node.name == 'get_flashed_messages':\n+                func_found = True\n+                for default, arg in zip(reversed(node.args.defaults), reversed(node.args.args)):\n+                    if arg.arg == 'log':\n+                        if isinstance(default, ast.Constant) and default.value is False:\n+                            log_default_false = True\n+                        break\n+\n+        self.assertTrue(func_found, \"Function 'get_flashed_messages' not found in helpers.py\")\n+        self.assertTrue(log_default_false, \"Default value for parameter 'log' is not False in 'get_flashed_messages'\")\n+\n+    \n+    def test_get_flashed_messages_calls_in_test_basic(self):\n+        file_path = 'tests/test_basic.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        call_log_true_found = True  # Assuming all are correct, set to False if any call fails\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.Call):\n+                # Check if it's a method call: flask.get_flashed_messages(...)\n+                if isinstance(node.func, ast.Attribute) and isinstance(node.func.value, ast.Name):\n+                    if node.func.value.id == 'flask' and node.func.attr == 'get_flashed_messages':\n+                        # Check if 'log=True' is in the keyword arguments\n+                        log_kwarg_found = False\n+                        for keyword in node.keywords:\n+                            if keyword.arg == 'log' and isinstance(keyword.value, ast.Constant) and keyword.value.value is True:\n+                                log_kwarg_found = True\n+                                break\n+                        if not log_kwarg_found:\n+                            call_log_true_found = False\n+                            break\n+\n+        self.assertTrue(call_log_true_found, \"Not all calls to 'flask.get_flashed_messages' have 'log=True' in test_basic.py\")\n+\n+    \n+if __name__ == '__main__':\n+    unittest.main()",
    "problem_statement": "Can you add a log boolean parameter to get_flashed_messages and keep the base case as false. In the test calls of the function make the log=True.",
    "hints_text": "",
    "created_at": "2025-11-03 22:46:32+00:00",
    "language": "Python",
    "Dockerfile": "N/A",
    "test_command": "python3 -m unittest add-log-parameter-get-flashed-messages-test.py",
    "task_category": "Refactoring",
    "data_source": "microsoft/RefactorBench",
    "scenario": "brownfield"
  },
  {
    "repo": "psf/requests",
    "url": "https://github.com/psf/requests",
    "instance_id": "new-cookie-utils-class",
    "base_commit": "new-cookie-utils-class",
    "patch": "N/A",
    "test_patch": "diff --git a/new-cookie-utils-class-test.py b/new-cookie-utils-class-test.py\nnew file mode 100644\nindex 0000000..605cb23\n--- /dev/null\n+++ b/new-cookie-utils-class-test.py\n@@ -0,0 +1,119 @@\n+import unittest\n+import os\n+import ast\n+\n+class TestCookieUtilsMigration(unittest.TestCase):\n+\n+    def test_cookie_utils_class_exists(self):\n+        # Path to the file where the CookieUtils class should be defined\n+        file_path = 'src/requests/cookies.py'  # adjust as needed\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Check if the CookieUtils class is defined in cookies.py\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        class_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ClassDef) and node.name == 'CookieUtils':\n+                class_found = True\n+                break\n+\n+        self.assertTrue(class_found, \"Class 'CookieUtils' not found in cookies.py\")\n+\n+    def test_functions_in_cookie_utils(self):\n+        # Path to the file where the CookieUtils class should be defined\n+        file_path = 'src/requests/cookies.py'  # adjust as needed\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Expected functions that should be in the CookieUtils class\n+        expected_functions = [\n+            'extract_cookies_to_jar',\n+            'get_cookie_header',\n+            'remove_cookie_by_name',\n+            'cookiejar_from_dict',\n+            'merge_cookies',\n+            '_copy_cookie_jar',\n+            'create_cookie',\n+            'morsel_to_cookie'\n+        ]\n+\n+        # Check if the functions are defined in the CookieUtils class\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        functions_found = {func: False for func in expected_functions}\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ClassDef) and node.name == 'CookieUtils':\n+                for class_node in ast.walk(node):\n+                    if isinstance(class_node, ast.FunctionDef) and class_node.name in functions_found:\n+                        functions_found[class_node.name] = True\n+\n+        missing_functions = [func for func, found in functions_found.items() if not found]\n+\n+        self.assertFalse(missing_functions, f\"Functions {missing_functions} not found in CookieUtils class\")\n+\n+    def test_file_imports_cookie_utils(self):\n+        # List of files where CookieUtils should be imported\n+        files_to_check = [\n+            'src/requests/adapters.py',\n+            'src/requests/auth.py',\n+            'src/requests/models.py',\n+            'src/requests/sessions.py',\n+            'src/requests/utils.py',\n+        ]\n+\n+        # Iterate through each file and check for the import statement\n+        for test_file_path in files_to_check:\n+            with self.subTest(test_file_path=test_file_path):\n+                # Check if the file exists\n+                self.assertTrue(os.path.exists(test_file_path), f\"Test file {test_file_path} does not exist\")\n+\n+                # Check if the import statement for CookieUtils is correct\n+                with open(test_file_path, 'r') as file:\n+                    tree = ast.parse(file.read())\n+\n+                import_found = False\n+                for node in ast.walk(tree):\n+                    if isinstance(node, ast.ImportFrom):\n+                        if node.module == 'cookies' and \\\n+                           any(alias.name == 'CookieUtils' for alias in node.names):\n+                            import_found = True\n+                            break\n+\n+                self.assertTrue(import_found, f\"Import 'from requests.cookies import CookieUtils' not found in {test_file_path}\")\n+\n+    def test_file_imports_cookie_utils_tests(self):\n+        # List of files where CookieUtils should be imported\n+        files_to_check = [\n+            'tests/test_requests.py'\n+        ]\n+\n+        # Iterate through each file and check for the import statement\n+        for test_file_path in files_to_check:\n+            with self.subTest(test_file_path=test_file_path):\n+                # Check if the file exists\n+                self.assertTrue(os.path.exists(test_file_path), f\"Test file {test_file_path} does not exist\")\n+\n+                # Check if the import statement for CookieUtils is correct\n+                with open(test_file_path, 'r') as file:\n+                    tree = ast.parse(file.read())\n+\n+                import_found = False\n+                for node in ast.walk(tree):\n+                    if isinstance(node, ast.ImportFrom):\n+                        if node.module == 'requests.cookies' and \\\n+                           any(alias.name == 'CookieUtils' for alias in node.names):\n+                            import_found = True\n+                            break\n+\n+                self.assertTrue(import_found, f\"Import 'from requests.cookies import CookieUtils' not found in {test_file_path}\")\n+\n+\n+if __name__ == '__main__':\n+    unittest.main()",
    "problem_statement": "Create a new class called CookieUtils for the functions in cookies.py 'extract_cookies_to_jar', 'get_cookie_header', 'remove_cookie_by_name', 'cookiejar_from_dict', 'merge_cookies', '_copy_cookie_jar', 'create_cookie', 'morsel_to_cookie'",
    "hints_text": "",
    "created_at": "2025-11-03 22:46:32+00:00",
    "language": "Python",
    "Dockerfile": "N/A",
    "test_command": "python3 -m unittest new-cookie-utils-class-test.py",
    "task_category": "Refactoring",
    "data_source": "microsoft/RefactorBench",
    "scenario": "brownfield"
  },
  {
    "repo": "psf/requests",
    "url": "https://github.com/psf/requests",
    "instance_id": "combine-internal-utils-utils",
    "base_commit": "combine-internal-utils-utils",
    "patch": "N/A",
    "test_patch": "diff --git a/combine-internal-utils-utils-test.py b/combine-internal-utils-utils-test.py\nnew file mode 100644\nindex 0000000..beeb567\n--- /dev/null\n+++ b/combine-internal-utils-utils-test.py\n@@ -0,0 +1,124 @@\n+import unittest\n+import os\n+import ast\n+\n+class TestCacheMigration(unittest.TestCase):\n+\n+    def test_internal_utils_py_removed(self):\n+        # Check if the _internal_utils.py file has been removed\n+        file_path = 'src/requests/_internal_utils.py'\n+        self.assertFalse(os.path.exists(file_path), f\"{file_path} should be removed but still exists\")\n+\n+    def test_internal_utils_py_not_a_file(self):\n+        # Check if _internal_utils.py is not a file (it should either be a directory or non-existent)\n+        file_path = 'src/requests/_internal_utils.py'\n+        self.assertFalse(os.path.isfile(file_path), f\"{file_path} is still a file\")\n+\n+    def test_auth_py_imports_updated(self):\n+        # Path to the auth.py file\n+        file_path = 'src/requests/auth.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        import_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom):\n+                if node.module == 'utils' and \\\n+                   any(alias.name == 'to_native_string' for alias in node.names):\n+                    import_found = True\n+                    break\n+\n+        self.assertTrue(import_found, f\"Import 'from requests.utils import to_native_string' not found in {file_path}\")\n+\n+    def test_cookies_py_imports_updated(self):\n+        # Path to the cookies.py file\n+        file_path = 'src/requests/cookies.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        import_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom):\n+                if node.module == 'utils' and \\\n+                   any(alias.name == 'to_native_string' for alias in node.names):\n+                    import_found = True\n+                    break\n+\n+        self.assertTrue(import_found, f\"Import 'from requests.utils import to_native_string' not found in {file_path}\")\n+\n+    def test_models_py_imports_updated(self):\n+        # Path to the models.py file\n+        file_path = 'src/requests/models.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        required_imports = {\n+            'check_header_validity',\n+            'get_auth_from_url',\n+            'guess_filename',\n+            'guess_json_utf',\n+            'iter_slices',\n+            'parse_header_links',\n+            'requote_uri',\n+            'stream_decode_response_unicode',\n+            'super_len',\n+            'to_key_val_list',\n+            'to_native_string',\n+            'unicode_is_ascii'\n+        }\n+\n+        imports_found = set()\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom):\n+                if node.module == 'utils':\n+                    for alias in node.names:\n+                        if alias.name in required_imports:\n+                            imports_found.add(alias.name)\n+\n+        missing_imports = required_imports - imports_found\n+        self.assertTrue(not missing_imports, f\"Imports from requests.utils not found in {file_path}: {missing_imports}\")\n+\n+    def test_sessions_py_imports_updated(self):\n+        # Path to the sessions.py file\n+        file_path = 'src/requests/sessions.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        import_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom):\n+                if node.module == 'utils' and \\\n+                   any(alias.name == 'to_native_string' for alias in node.names):\n+                    import_found = True\n+                    break\n+\n+        self.assertTrue(import_found, f\"Import 'from requests.utils import to_native_string' not found in {file_path}\")\n+\n+    def test_tests_py_imports_updated(self):\n+        # Path to the test_utils.py file\n+        file_path = 'tests/test_utils.py'\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        import_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom):\n+                if node.module == 'requests.utils' and \\\n+                   any(alias.name == 'to_native_string' for alias in node.names):\n+                    import_found = True\n+                    break\n+\n+        self.assertTrue(import_found, f\"Import 'from requests.utils import to_native_string' not found in {file_path}\")\n+\n+if __name__ == '__main__':\n+    unittest.main()",
    "problem_statement": "move everything from _internal_utils to utils and update all the references within the codebase",
    "hints_text": "",
    "created_at": "2025-11-03 22:46:32+00:00",
    "language": "Python",
    "Dockerfile": "N/A",
    "test_command": "python3 -m unittest combine-internal-utils-utils-test.py",
    "task_category": "Refactoring",
    "data_source": "microsoft/RefactorBench",
    "scenario": "brownfield"
  },
  {
    "repo": "psf/requests",
    "url": "https://github.com/psf/requests",
    "instance_id": "move-hooks-sessions",
    "base_commit": "move-hooks-sessions",
    "patch": "N/A",
    "test_patch": "diff --git a/move-hooks-sessions-test.py b/move-hooks-sessions-test.py\nnew file mode 100644\nindex 0000000..83b4617\n--- /dev/null\n+++ b/move-hooks-sessions-test.py\n@@ -0,0 +1,141 @@\n+import unittest\n+import os\n+import ast\n+\n+class TestHooksMigration(unittest.TestCase):\n+\n+    def test_hooks_py_removed(self):\n+        # Path to the hooks.py file that should be removed\n+        file_path = 'src/requests/hooks.py'\n+\n+        # Check if the file does not exist\n+        self.assertFalse(os.path.exists(file_path), f\"{file_path} should not exist\")\n+\n+    def test_default_hooks_in_sessions(self):\n+        # Path to the sessions.py file where the function should be located\n+        file_path = 'src/requests/sessions.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Parse the file to check if the default_hooks function is defined\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        function_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.FunctionDef) and node.name == 'default_hooks':\n+                function_found = True\n+                break\n+\n+        self.assertTrue(function_found, \"Function 'default_hooks' not found in sessions.py\")\n+\n+    def test_dispatch_hook_in_sessions(self):\n+        # Path to the sessions.py file where the function should be located\n+        file_path = 'src/requests/sessions.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Parse the file to check if the dispatch_hook function is defined\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        function_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.FunctionDef) and node.name == 'dispatch_hook':\n+                function_found = True\n+                break\n+\n+        self.assertTrue(function_found, \"Function 'dispatch_hook' not found in sessions.py\")\n+\n+    def test_models_imports_default_hooks(self):\n+        # Path to the models.py file where the import should be located\n+        file_path = 'src/requests/models.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Parse the file to check if default_hooks is imported from sessions\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        import_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom):\n+                if node.module == 'sessions':\n+                    for alias in node.names:\n+                        if alias.name == 'default_hooks':\n+                            import_found = True\n+                            break\n+\n+        self.assertTrue(import_found, \"Import 'from requests.sessions import default_hooks' not found in models.py\")\n+\n+    def test_test_requests_imports(self):\n+        # Path to the test_requests.py file where the imports should be located\n+        file_path = 'tests/test_requests.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Parse the file to check if SessionRedirectMixin and default_hooks are imported from sessions\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        session_redirect_mixin_found = False\n+        default_hooks_found = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom):\n+                if node.module == 'requests.sessions':\n+                    for alias in node.names:\n+                        if alias.name == 'SessionRedirectMixin':\n+                            session_redirect_mixin_found = True\n+                        if alias.name == 'default_hooks':\n+                            default_hooks_found = True\n+\n+        self.assertTrue(session_redirect_mixin_found, \"Import 'from requests.sessions import SessionRedirectMixin' not found in test_requests.py\")\n+        self.assertTrue(default_hooks_found, \"Import 'from requests.sessions import default_hooks' not found in test_requests.py\")\n+\n+    def test_test_hooks_imports_sessions(self):\n+        # Path to the test_hooks.py file where the import should be located\n+        file_path = 'tests/test_hooks.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Parse the file to check if sessions is imported from requests\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        import_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom):\n+                if node.module == 'requests' and any(alias.name == 'sessions' for alias in node.names):\n+                    import_found = True\n+                    break\n+\n+        self.assertTrue(import_found, \"Import 'from requests import sessions' not found in test_hooks.py\")\n+        \n+    def test_sessions_does_not_import_from_hooks(self):\n+        # Path to the sessions.py file where the import should not be located\n+        file_path = 'src/requests/sessions.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Parse the file to check if there is an import from hooks\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        import_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom) and node.module == 'requests.hooks':\n+                import_found = True\n+                break\n+\n+        self.assertFalse(import_found, \"Import 'from requests.hooks import ...' found in sessions.py, which should not be present\")\n+\n+\n+if __name__ == '__main__':\n+    unittest.main()",
    "problem_statement": "Remove the hooks.py file and put all that content in sessions.py and update throughout the repo accordingly",
    "hints_text": "",
    "created_at": "2025-11-03 22:46:32+00:00",
    "language": "Python",
    "Dockerfile": "N/A",
    "test_command": "python3 -m unittest move-hooks-sessions-test.py",
    "task_category": "Refactoring",
    "data_source": "microsoft/RefactorBench",
    "scenario": "brownfield"
  },
  {
    "repo": "psf/requests",
    "url": "https://github.com/psf/requests",
    "instance_id": "add-log-parameter-get-encoding-from-headers",
    "base_commit": "add-log-parameter-get-encoding-from-headers",
    "patch": "N/A",
    "test_patch": "diff --git a/add-log-parameter-get-encoding-from-headers-test.py b/add-log-parameter-get-encoding-from-headers-test.py\nnew file mode 100644\nindex 0000000..240c8b9\n--- /dev/null\n+++ b/add-log-parameter-get-encoding-from-headers-test.py\n@@ -0,0 +1,86 @@\n+import unittest\n+import os\n+import ast\n+\n+class TestFunctionParameter(unittest.TestCase):\n+\n+    def test_get_encoding_from_headers_log_param(self):\n+        # Path to the file where the function should be located\n+        file_path = 'src/requests/utils.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Parse the file to check the function's parameters\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        function_found = False\n+        param_is_boolean = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.FunctionDef) and node.name == 'get_encoding_from_headers':\n+                function_found = True\n+                # Check parameters for the 'log' argument\n+                for arg in node.args.args:\n+                    if arg.arg == 'log':\n+                        param_is_boolean = True  # Assume it's boolean, detailed type checks require running code or a type checker\n+                        break\n+                break\n+\n+        self.assertTrue(function_found, \"Function 'get_encoding_from_headers' not found in the file\")\n+        self.assertTrue(param_is_boolean, \"Function 'get_encoding_from_headers' does not have a 'log' parameter or it is not a boolean\")\n+\n+    def test_log_param_in_function_call(self):\n+        # Path to the file where the function call should be located\n+        call_file_path = 'src/requests/adapters.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(call_file_path), f\"{call_file_path} does not exist\")\n+\n+        # Parse the file to check the function call's arguments\n+        with open(call_file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        log_param_set_to_true = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.Call) and isinstance(node.func, ast.Name) and node.func.id == 'get_encoding_from_headers':\n+                # Check if 'log' parameter is set to True in the function call\n+                for keyword in node.keywords:\n+                    if keyword.arg == 'log' and isinstance(keyword.value, ast.Constant) and keyword.value.value is True:\n+                        log_param_set_to_true = True\n+                        break\n+                if log_param_set_to_true:\n+                    break\n+\n+        self.assertTrue(log_param_set_to_true, \"Function 'get_encoding_from_headers' is called without 'log=True' in the function call\")\n+\n+\n+    def test_log_param_in_function_call_false(self):\n+        # Path to the file where the function call should be located\n+        call_file_path = 'tests/test_utils.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(call_file_path), f\"{call_file_path} does not exist\")\n+\n+        # Parse the file to check the function call's arguments\n+        with open(call_file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        log_param_set_to_true = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.Call) and isinstance(node.func, ast.Name) and node.func.id == 'get_encoding_from_headers':\n+                # Check if 'log' parameter is set to True in the function call\n+                for keyword in node.keywords:\n+                    if keyword.arg == 'log' and isinstance(keyword.value, ast.Constant) and keyword.value.value is False:\n+                        log_param_set_to_true = True\n+                        break\n+                if log_param_set_to_true:\n+                    break\n+\n+        self.assertTrue(log_param_set_to_true, \"Function 'get_encoding_from_headers' is called without 'log=False' in the function call in tests\")\n+\n+if __name__ == '__main__':\n+    unittest.main()",
    "problem_statement": "Add a log parameter to get_encoding_from_headers, make the base case false in the utils file and all the other files except tests should have the log=True",
    "hints_text": "",
    "created_at": "2025-11-03 22:46:32+00:00",
    "language": "Python",
    "Dockerfile": "N/A",
    "test_command": "python3 -m unittest add-log-parameter-get-encoding-from-headers-test.py",
    "task_category": "Refactoring",
    "data_source": "microsoft/RefactorBench",
    "scenario": "brownfield"
  },
  {
    "repo": "psf/requests",
    "url": "https://github.com/psf/requests",
    "instance_id": "split-warnings-exceptions",
    "base_commit": "split-warnings-exceptions",
    "patch": "N/A",
    "test_patch": "diff --git a/split-warnings-exceptions-test.py b/split-warnings-exceptions-test.py\nnew file mode 100644\nindex 0000000..0166dfb\n--- /dev/null\n+++ b/split-warnings-exceptions-test.py\n@@ -0,0 +1,171 @@\n+import unittest\n+import os\n+import ast\n+\n+class TestWarningsFile(unittest.TestCase):\n+\n+    def test_warnings_file_exists(self):\n+        # Path to the file where the classes should be located\n+        file_path = 'src/requests/warnings.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+    def test_requests_warning_class_exists(self):\n+        # Path to the file where the class should be located\n+        file_path = 'src/requests/warnings.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Parse the file to check for the RequestsWarning class\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        class_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ClassDef) and node.name == 'RequestsWarning':\n+                class_found = True\n+                break\n+\n+        self.assertTrue(class_found, \"Class 'RequestsWarning' not found in warnings.py\")\n+\n+    def test_file_mode_warning_class_exists(self):\n+        # Path to the file where the class should be located\n+        file_path = 'src/requests/warnings.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Parse the file to check for the FileModeWarning class\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        class_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ClassDef) and node.name == 'FileModeWarning':\n+                class_found = True\n+                break\n+\n+        self.assertTrue(class_found, \"Class 'FileModeWarning' not found in warnings.py\")\n+\n+    def test_requests_dependency_warning_class_exists(self):\n+        # Path to the file where the class should be located\n+        file_path = 'src/requests/warnings.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Parse the file to check for the RequestsDependencyWarning class\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        class_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ClassDef) and node.name == 'RequestsDependencyWarning':\n+                class_found = True\n+                break\n+\n+        self.assertTrue(class_found, \"Class 'RequestsDependencyWarning' not found in warnings.py\")\n+\n+    def test_requests_warning_class_not_in_exceptions(self):\n+        # Path to the exceptions file\n+        file_path = 'src/requests/exceptions.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Parse the file to check that RequestsWarning is not present\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        class_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ClassDef) and node.name == 'RequestsWarning':\n+                class_found = True\n+                break\n+\n+        self.assertFalse(class_found, \"Class 'RequestsWarning' should not be present in exceptions.py\")\n+\n+    def test_file_mode_warning_class_not_in_exceptions(self):\n+        # Path to the exceptions file\n+        file_path = 'src/requests/exceptions.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Parse the file to check that FileModeWarning is not present\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        class_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ClassDef) and node.name == 'FileModeWarning':\n+                class_found = True\n+                break\n+\n+        self.assertFalse(class_found, \"Class 'FileModeWarning' should not be present in exceptions.py\")\n+\n+    def test_requests_dependency_warning_class_not_in_exceptions(self):\n+        # Path to the exceptions file\n+        file_path = 'src/requests/exceptions.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Parse the file to check that RequestsDependencyWarning is not present\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        class_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ClassDef) and node.name == 'RequestsDependencyWarning':\n+                class_found = True\n+                break\n+\n+        self.assertFalse(class_found, \"Class 'RequestsDependencyWarning' should not be present in exceptions.py\")\n+\n+    def test_init_imports_requests_dependency_warning(self):\n+        # Path to the __init__.py file\n+        file_path = 'src/requests/__init__.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Parse the file to check if the correct import is present\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        import_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom) and node.module == 'warnings':\n+                for alias in node.names:\n+                    if alias.name == 'RequestsDependencyWarning':\n+                        import_found = True\n+                        break\n+\n+        self.assertTrue(import_found, \"Import 'from .warnings import RequestsDependencyWarning' not found in __init__.py\")\n+\n+    def test_utils_imports_file_mode_warning(self):\n+        # Path to the utils.py file\n+        file_path = 'src/requests/utils.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Parse the file to check if the correct import is present\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        import_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom) and node.module == 'warnings':\n+                for alias in node.names:\n+                    if alias.name == 'FileModeWarning':\n+                        import_found = True\n+                        break\n+\n+        self.assertTrue(import_found, \"Import 'from .warnings import FileModeWarning' not found in utils.py\")\n+\n+if __name__ == '__main__':\n+    unittest.main()",
    "problem_statement": "Create a warnings.py file alongside the exceptions.py file and move all the warnings in exceptions to it and update all the references in the repository accordingly.",
    "hints_text": "",
    "created_at": "2025-11-03 22:46:32+00:00",
    "language": "Python",
    "Dockerfile": "N/A",
    "test_command": "python3 -m unittest split-warnings-exceptions-test.py",
    "task_category": "Refactoring",
    "data_source": "microsoft/RefactorBench",
    "scenario": "brownfield"
  },
  {
    "repo": "psf/requests",
    "url": "https://github.com/psf/requests",
    "instance_id": "add-log-parameter-select-proxy",
    "base_commit": "add-log-parameter-select-proxy",
    "patch": "N/A",
    "test_patch": "diff --git a/add-log-parameter-select-proxy-test.py b/add-log-parameter-select-proxy-test.py\nnew file mode 100644\nindex 0000000..3dc03f2\n--- /dev/null\n+++ b/add-log-parameter-select-proxy-test.py\n@@ -0,0 +1,60 @@\n+import unittest\n+import os\n+import ast\n+\n+class TestFunctionParameter(unittest.TestCase):\n+\n+    def test_select_proxy_log_param(self):\n+        # Path to the file where the function should be located\n+        file_path = 'src/requests/utils.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Parse the file to check the function's parameters\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        function_found = False\n+        param_is_boolean = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.FunctionDef) and node.name == 'select_proxy':\n+                function_found = True\n+                # Check parameters for the 'log' argument\n+                for arg in node.args.args:\n+                    if arg.arg == 'log':\n+                        param_is_boolean = True  # Assume it's boolean, detailed type checks require running code or a type checker\n+                        break\n+                break\n+\n+        self.assertTrue(function_found, \"Function 'select_proxy' not found in the file\")\n+        self.assertTrue(param_is_boolean, \"Function 'select_proxy' does not have a 'log' parameter or it is not a boolean\")\n+\n+    def test_log_param_in_select_proxy_call(self):\n+        # Path to the file where the function call should be located\n+        call_file_path = 'src/requests/adapters.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(call_file_path), f\"{call_file_path} does not exist\")\n+\n+        # Parse the file to check the function call's arguments\n+        with open(call_file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        log_param_set_to_true = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.Call) and isinstance(node.func, ast.Name) and node.func.id == 'select_proxy':\n+                # Check if 'log' parameter is set to True in the function call\n+                for keyword in node.keywords:\n+                    if keyword.arg == 'log' and isinstance(keyword.value, ast.Constant) and keyword.value.value is True:\n+                        log_param_set_to_true = True\n+                        break\n+                if log_param_set_to_true:\n+                    break\n+\n+        self.assertTrue(log_param_set_to_true, \"Function 'select_proxy' is called without 'log=True' in the function call\")\n+\n+if __name__ == '__main__':\n+    unittest.main()",
    "problem_statement": "Add a log parameter to the select proxy function and make the log=False and base and make log=True in all calls throughout the repository",
    "hints_text": "",
    "created_at": "2025-11-03 22:46:32+00:00",
    "language": "Python",
    "Dockerfile": "N/A",
    "test_command": "python3 -m unittest add-log-parameter-select-proxy-test.py",
    "task_category": "Refactoring",
    "data_source": "microsoft/RefactorBench",
    "scenario": "brownfield"
  },
  {
    "repo": "psf/requests",
    "url": "https://github.com/psf/requests",
    "instance_id": "add-log-parameter-resolve-proxies",
    "base_commit": "add-log-parameter-resolve-proxies",
    "patch": "N/A",
    "test_patch": "diff --git a/add-log-parameter-resolve-proxies-test.py b/add-log-parameter-resolve-proxies-test.py\nnew file mode 100644\nindex 0000000..ad9210d\n--- /dev/null\n+++ b/add-log-parameter-resolve-proxies-test.py\n@@ -0,0 +1,60 @@\n+import unittest\n+import os\n+import ast\n+\n+class TestFunctionParameter(unittest.TestCase):\n+\n+    def test_resolve_proxies_log_param(self):\n+        # Path to the file where the function should be located\n+        file_path = 'src/requests/utils.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Parse the file to check the function's parameters\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        function_found = False\n+        param_is_boolean = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.FunctionDef) and node.name == 'resolve_proxies':\n+                function_found = True\n+                # Check parameters for the 'log' argument\n+                for arg in node.args.args:\n+                    if arg.arg == 'log':\n+                        param_is_boolean = True  # Assume it's boolean, detailed type checks require running code or a type checker\n+                        break\n+                break\n+\n+        self.assertTrue(function_found, \"Function 'resolve_proxies' not found in the file\")\n+        self.assertTrue(param_is_boolean, \"Function 'resolve_proxies' does not have a 'log' parameter or it is not a boolean\")\n+\n+    def test_log_param_in_resolve_proxies_call(self):\n+        # Path to the file where the function call should be located\n+        call_file_path = 'src/requests/sessions.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(call_file_path), f\"{call_file_path} does not exist\")\n+\n+        # Parse the file to check the function call's arguments\n+        with open(call_file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        log_param_set_to_true = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.Call) and isinstance(node.func, ast.Name) and node.func.id == 'resolve_proxies':\n+                # Check if 'log' parameter is set to True in the function call\n+                for keyword in node.keywords:\n+                    if keyword.arg == 'log' and isinstance(keyword.value, ast.Constant) and keyword.value.value is True:\n+                        log_param_set_to_true = True\n+                        break\n+                if log_param_set_to_true:\n+                    break\n+\n+        self.assertTrue(log_param_set_to_true, \"Function 'resolve_proxies' is called without 'log=True' in the function call\")\n+\n+if __name__ == '__main__':\n+    unittest.main()",
    "problem_statement": "Add a log parameter to resolve_proxies, make the base case false in the utils file and all the other files except tests should have the log=True",
    "hints_text": "",
    "created_at": "2025-11-03 22:46:32+00:00",
    "language": "Python",
    "Dockerfile": "N/A",
    "test_command": "python3 -m unittest add-log-parameter-resolve-proxies-test.py",
    "task_category": "Refactoring",
    "data_source": "microsoft/RefactorBench",
    "scenario": "brownfield"
  },
  {
    "repo": "psf/requests",
    "url": "https://github.com/psf/requests",
    "instance_id": "rename-lookup-dict-dict-lookup",
    "base_commit": "rename-lookup-dict-dict-lookup",
    "patch": "N/A",
    "test_patch": "diff --git a/rename-lookup-dict-dict-lookup-test.py b/rename-lookup-dict-dict-lookup-test.py\nnew file mode 100644\nindex 0000000..a180210\n--- /dev/null\n+++ b/rename-lookup-dict-dict-lookup-test.py\n@@ -0,0 +1,154 @@\n+import unittest\n+import os\n+import ast\n+\n+class TestClassRenaming(unittest.TestCase):\n+\n+    def test_class_renamed_to_DictLookup(self):\n+        # Path to the file where the class should be located\n+        file_path = 'src/requests/structures.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Parse the file to check the class definition\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        class_found = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ClassDef) and node.name == 'DictLookup':\n+                class_found = True\n+                break\n+\n+        self.assertTrue(class_found, \"Class 'DictLookup' not found in the file\")\n+    \n+    def test_no_LookupDict_class(self):\n+        # Path to the file where the class should have been located\n+        file_path = 'src/requests/structures.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Parse the file to ensure LookupDict class no longer exists\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        class_found = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ClassDef) and node.name == 'LookupDict':\n+                class_found = True\n+                break\n+\n+        self.assertFalse(class_found, \"Class 'LookupDict' should not be present in the file\")\n+\n+    def test_usage_of_DictLookup(self):\n+        # Path to the file where the class usage should be located\n+        usage_file_path = 'src/requests/status_codes.py'  \n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(usage_file_path), f\"{usage_file_path} does not exist\")\n+\n+        # Parse the file to check the usage of the class\n+        with open(usage_file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        class_used = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.Call) and isinstance(node.func, ast.Name) and node.func.id == 'DictLookup':\n+                class_used = True\n+                break\n+\n+        self.assertTrue(class_used, \"Class 'DictLookup' is not used where it should be\")\n+    \n+    def test_DictLookup_imported_in_status_codes(self):\n+        # Path to the file where DictLookup should be imported\n+        file_path = 'src/requests/status_codes.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Parse the file to check the import statement\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        dictlookup_imported = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom) and node.module == 'structures':\n+                for alias in node.names:\n+                    if alias.name == 'DictLookup':\n+                        dictlookup_imported = True\n+                        break\n+                if dictlookup_imported:\n+                    break\n+\n+        self.assertTrue(dictlookup_imported, \"'DictLookup' is not imported from 'structures' in status_codes.py\")\n+    \n+    def test_specific_import_in_test_structures(self):\n+        # Path to the test file\n+        test_file_path = 'tests/test_structures.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(test_file_path), f\"{test_file_path} does not exist\")\n+\n+        # Parse the file to check the specific import statement\n+        with open(test_file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        specific_import_found = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom) and node.module == 'requests.structures':\n+                imported_names = {alias.name for alias in node.names}\n+                if 'CaseInsensitiveDict' in imported_names and 'DictLookup' in imported_names:\n+                    specific_import_found = True\n+                    break\n+\n+        self.assertTrue(specific_import_found, \"The specific import 'from requests.structures import CaseInsensitiveDict, DictLookup' is not found in test_structures.py\")\n+    \n+    def test_DictLookup_used_in_status_codes(self):\n+        # Path to the status_codes file\n+        status_codes_file_path = 'src/requests/status_codes.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(status_codes_file_path), f\"{status_codes_file_path} does not exist\")\n+\n+        # Parse the file to check if DictLookup is used\n+        with open(status_codes_file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        dictlookup_used = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.Name) and node.id == 'DictLookup':\n+                dictlookup_used = True\n+                break\n+\n+        self.assertTrue(dictlookup_used, \"'DictLookup' is not used in status_codes.py\")\n+    \n+    def test_DictLookup_used_in_test_structures(self):\n+        # Path to the test_structures file\n+        test_structures_file_path = 'tests/test_structures.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(test_structures_file_path), f\"{test_structures_file_path} does not exist\")\n+\n+        # Parse the file to check if DictLookup is used\n+        with open(test_structures_file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        dictlookup_used = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.Name) and node.id == 'DictLookup':\n+                dictlookup_used = True\n+                break\n+\n+        self.assertTrue(dictlookup_used, \"'DictLookup' is not used in test_structures.py\")\n+\n+if __name__ == '__main__':\n+    unittest.main()",
    "problem_statement": "Rename LookupDict in structures.py to DictLookup and update all the references in the repo",
    "hints_text": "",
    "created_at": "2025-11-03 22:46:32+00:00",
    "language": "Python",
    "Dockerfile": "N/A",
    "test_command": "python3 -m unittest rename-lookup-dict-dict-lookup-test.py",
    "task_category": "Refactoring",
    "data_source": "microsoft/RefactorBench",
    "scenario": "brownfield"
  },
  {
    "repo": "psf/requests",
    "url": "https://github.com/psf/requests",
    "instance_id": "combine-from-key-to-key",
    "base_commit": "combine-from-key-to-key",
    "patch": "N/A",
    "test_patch": "diff --git a/combine-from-key-to-key-test.py b/combine-from-key-to-key-test.py\nnew file mode 100644\nindex 0000000..0daebb0\n--- /dev/null\n+++ b/combine-from-key-to-key-test.py\n@@ -0,0 +1,149 @@\n+import unittest\n+import os\n+import ast\n+\n+class TestFunctionRefactoring(unittest.TestCase):\n+\n+    def test_old_functions_removed(self):\n+        # Path to the file where the functions should be located\n+        file_path = 'src/requests/utils.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Parse the file to check the presence of old functions\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        from_key_found = False\n+        to_key_found = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.FunctionDef):\n+                if node.name == 'from_key_val_list':\n+                    from_key_found = True\n+                if node.name == 'to_key_val_list':\n+                    to_key_found = True\n+\n+        self.assertFalse(from_key_found, \"Function 'from_key_val_list' is still present in the file\")\n+        self.assertFalse(to_key_found, \"Function 'to_key_val_list' is still present in the file\")\n+\n+    def test_new_function_exists(self):\n+        # Path to the file where the new function should be located\n+        file_path = 'src/requests/utils.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Parse the file to check the new function's parameters\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        function_found = False\n+        to_dict_is_second_param = False\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.FunctionDef) and node.name == 'key_val_convert':\n+                function_found = True\n+                # Check if the second parameter is 'to_dict'\n+                if len(node.args.args) > 1 and node.args.args[1].arg == 'to_dict':\n+                    to_dict_is_second_param = True\n+                break\n+\n+        self.assertTrue(function_found, \"Function 'key_val_convert' not found in the file\")\n+        self.assertTrue(to_dict_is_second_param, \"The 'to_dict' parameter in 'key_val_convert' is not the second parameter\")\n+\n+\n+\n+    def test_sessions_imports(self):\n+        # Path to the file where the imports should be located\n+        file_path = 'src/requests/sessions.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Parse the file to check for the imports\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        expected_imports = {\n+            \"DEFAULT_PORTS\", \"default_headers\", \"get_auth_from_url\", \"get_environ_proxies\",\n+            \"get_netrc_auth\", \"requote_uri\", \"resolve_proxies\", \"rewind_body\",\n+            \"should_bypass_proxies\", \"key_val_convert\"\n+        }\n+        actual_imports = set()\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom) and node.module == 'utils':\n+                for alias in node.names:\n+                    actual_imports.add(alias.name)\n+\n+        self.assertTrue(expected_imports.issubset(actual_imports), \n+                        f\"Not all expected imports are present in 'sessions.py'. Missing: {expected_imports - actual_imports}\")\n+\n+    def test_model_imports(self):\n+        # Path to the file where the imports should be located\n+        file_path = 'src/requests/models.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+        # Parse the file to check for the imports\n+        with open(file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        expected_imports = {\n+            \"check_header_validity\", \"get_auth_from_url\", \"guess_filename\", \"guess_json_utf\",\n+            \"iter_slices\", \"parse_header_links\", \"requote_uri\", \"stream_decode_response_unicode\",\n+            \"super_len\", \"key_val_convert\"\n+        }\n+        actual_imports = set()\n+\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.ImportFrom) and node.module == 'utils':\n+                for alias in node.names:\n+                    actual_imports.add(alias.name)\n+\n+        self.assertTrue(expected_imports.issubset(actual_imports), \n+                        f\"Not all expected imports are present in 'models.py'. Missing: {expected_imports - actual_imports}\")\n+\n+    def test_key_val_convert_to_dict_false(self):\n+        # Files to check for the correct usage of key_val_convert\n+        files_to_check = [\n+            'src/requests/models.py',\n+            'src/requests/sessions.py',\n+            'tests/test_utils.py'\n+        ]\n+\n+        for file_path in files_to_check:\n+            # Check if the file exists\n+            self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+            # Parse the file to check the function call's arguments\n+            with open(file_path, 'r') as file:\n+                tree = ast.parse(file.read())\n+\n+            key_val_convert_calls = 0\n+            correct_param_usage = 0\n+\n+            for node in ast.walk(tree):\n+                if isinstance(node, ast.FunctionDef):  # Look inside functions\n+                    for child in ast.walk(node):\n+                        if isinstance(child, ast.Call) and isinstance(child.func, ast.Name) and child.func.id == 'key_val_convert':\n+                            key_val_convert_calls += 1\n+                            \n+                            # Check if 'to_dict' parameter is set to False as the second argument\n+                            if len(child.args) > 1 and isinstance(child.args[1], ast.Constant) and child.args[1].value is False:\n+                                correct_param_usage += 1\n+                            else:\n+                                # Check keyword arguments for 'to_dict'\n+                                for keyword in child.keywords:\n+                                    if keyword.arg == 'to_dict' and isinstance(keyword.value, ast.Constant) and keyword.value.value is False:\n+                                        correct_param_usage += 1\n+                                        break\n+\n+            self.assertEqual(key_val_convert_calls, correct_param_usage, \n+                             f\"{key_val_convert_calls} != {correct_param_usage}  Not all 'key_val_convert' calls in {file_path} have 'to_dict=False' as the second argument\")\n+\n+if __name__ == '__main__':\n+    unittest.main()",
    "problem_statement": "Convert the from_key_val_list and the to_key_val_list functions into a singular function key_val_convert(value, to_dict=True) with the behavior that if to_dict is true, it behaves like from_key_val_list and If to_dict is False, it behaves like to_key_val_list. Update the rest of the repo accordingly.",
    "hints_text": "",
    "created_at": "2025-11-03 22:46:32+00:00",
    "language": "Python",
    "Dockerfile": "N/A",
    "test_command": "python3 -m unittest combine-from-key-to-key-test.py",
    "task_category": "Refactoring",
    "data_source": "microsoft/RefactorBench",
    "scenario": "brownfield"
  },
  {
    "repo": "psf/requests",
    "url": "https://github.com/psf/requests",
    "instance_id": "rename-super-len-complex-len",
    "base_commit": "rename-super-len-complex-len",
    "patch": "N/A",
    "test_patch": "diff --git a/rename-super-len-complex-len-test.py b/rename-super-len-complex-len-test.py\nnew file mode 100644\nindex 0000000..5f0ee23\n--- /dev/null\n+++ b/rename-super-len-complex-len-test.py\n@@ -0,0 +1,70 @@\n+import unittest\n+import os\n+import ast\n+\n+class TestFunctionRenaming(unittest.TestCase):\n+\n+    def test_super_len_renamed_to_complex_len(self):\n+        # List of files to check\n+        files_to_check = [\n+            'src/requests/models.py',\n+            'tests/test_utils.py',\n+        ]\n+\n+        for file_path in files_to_check:\n+            # Check if the file exists\n+            self.assertTrue(os.path.exists(file_path), f\"{file_path} does not exist\")\n+\n+            # Check if the import has been updated\n+            with open(file_path, 'r') as file:\n+                tree = ast.parse(file.read())\n+\n+            import_updated = False\n+            for node in ast.walk(tree):\n+                if isinstance(node, ast.ImportFrom):\n+                    # Check if there was an import of super_len and it got renamed to complex_len\n+                    if any(alias.name == 'complex_len' for alias in node.names):\n+                        import_updated = True\n+                        break\n+\n+            self.assertTrue(import_updated, f\"Import of 'complex_len' not found in {file_path}, it might still be using 'super_len'\")\n+\n+    def test_super_len_function_removed(self):\n+        # Path to the file where super_len was originally defined\n+        original_file_path = 'src/requests/utils.py'\n+\n+        # Check if the function super_len is no longer defined in the file\n+        self.assertTrue(os.path.exists(original_file_path), f\"{original_file_path} does not exist\")\n+\n+        with open(original_file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        function_still_exists = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.FunctionDef) and node.name == 'super_len':\n+                function_still_exists = True\n+                break\n+\n+        self.assertFalse(function_still_exists, \"Function 'super_len' still exists, it should have been removed or renamed to 'complex_len'\")\n+\n+    def test_complex_len_function_exists(self):\n+        # Path to the file where complex_len should be defined\n+        new_file_path = 'src/requests/utils.py'\n+\n+        # Check if the file exists\n+        self.assertTrue(os.path.exists(new_file_path), f\"{new_file_path} does not exist\")\n+\n+        # Check if the function complex_len is defined in the file\n+        with open(new_file_path, 'r') as file:\n+            tree = ast.parse(file.read())\n+\n+        function_found = False\n+        for node in ast.walk(tree):\n+            if isinstance(node, ast.FunctionDef) and node.name == 'complex_len':\n+                function_found = True\n+                break\n+\n+        self.assertTrue(function_found, \"Function 'complex_len' not found in the expected file\")\n+\n+if __name__ == '__main__':\n+    unittest.main()",
    "problem_statement": "Rename the super_len function in utils to complex_len and update the repo and tests",
    "hints_text": "",
    "created_at": "2025-11-03 22:46:32+00:00",
    "language": "Python",
    "Dockerfile": "N/A",
    "test_command": "python3 -m unittest rename-super-len-complex-len-test.py",
    "task_category": "Refactoring",
    "data_source": "microsoft/RefactorBench",
    "scenario": "brownfield"
  }
]